{"version":3,"sources":["../../node_modules/webpack-virtual-modules/src/virtual-stats.ts","../../node_modules/webpack-virtual-modules/src/index.ts","../../node_modules/web-streams-polyfill/src/utils.ts","../../node_modules/web-streams-polyfill/src/lib/helpers/miscellaneous.ts","../../node_modules/web-streams-polyfill/src/lib/helpers/webidl.ts","../../node_modules/web-streams-polyfill/src/lib/simple-queue.ts","../../node_modules/web-streams-polyfill/src/lib/abstract-ops/internal-methods.ts","../../node_modules/web-streams-polyfill/src/lib/readable-stream/generic-reader.ts","../../node_modules/web-streams-polyfill/src/stub/number-isfinite.ts","../../node_modules/web-streams-polyfill/src/stub/math-trunc.ts","../../node_modules/web-streams-polyfill/src/lib/validators/basic.ts","../../node_modules/web-streams-polyfill/src/lib/validators/readable-stream.ts","../../node_modules/web-streams-polyfill/src/lib/readable-stream/default-reader.ts","../../node_modules/web-streams-polyfill/src/target/es2018/stub/async-iterator-prototype.ts","../../node_modules/web-streams-polyfill/src/lib/readable-stream/async-iterator.ts","../../node_modules/web-streams-polyfill/src/stub/number-isnan.ts","../../node_modules/web-streams-polyfill/src/lib/abstract-ops/ecmascript.ts","../../node_modules/web-streams-polyfill/src/lib/abstract-ops/miscellaneous.ts","../../node_modules/web-streams-polyfill/src/lib/abstract-ops/queue-with-sizes.ts","../../node_modules/web-streams-polyfill/src/lib/helpers/array-buffer-view.ts","../../node_modules/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.ts","../../node_modules/web-streams-polyfill/src/lib/validators/reader-options.ts","../../node_modules/web-streams-polyfill/src/lib/readable-stream/byob-reader.ts","../../node_modules/web-streams-polyfill/src/lib/abstract-ops/queuing-strategy.ts","../../node_modules/web-streams-polyfill/src/lib/validators/queuing-strategy.ts","../../node_modules/web-streams-polyfill/src/lib/validators/underlying-sink.ts","../../node_modules/web-streams-polyfill/src/lib/validators/writable-stream.ts","../../node_modules/web-streams-polyfill/src/lib/abort-signal.ts","../../node_modules/web-streams-polyfill/src/lib/writable-stream.ts","../../node_modules/web-streams-polyfill/src/globals.ts","../../node_modules/web-streams-polyfill/src/stub/dom-exception.ts","../../node_modules/web-streams-polyfill/src/lib/readable-stream/pipe.ts","../../node_modules/web-streams-polyfill/src/lib/readable-stream/default-controller.ts","../../node_modules/web-streams-polyfill/src/lib/readable-stream/tee.ts","../../node_modules/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.ts","../../node_modules/web-streams-polyfill/src/lib/readable-stream/from.ts","../../node_modules/web-streams-polyfill/src/lib/validators/underlying-source.ts","../../node_modules/web-streams-polyfill/src/lib/validators/iterator-options.ts","../../node_modules/web-streams-polyfill/src/lib/validators/pipe-options.ts","../../node_modules/web-streams-polyfill/src/lib/validators/readable-writable-pair.ts","../../node_modules/web-streams-polyfill/src/lib/readable-stream.ts","../../node_modules/web-streams-polyfill/src/lib/validators/queuing-strategy-init.ts","../../node_modules/web-streams-polyfill/src/lib/byte-length-queuing-strategy.ts","../../node_modules/web-streams-polyfill/src/lib/count-queuing-strategy.ts","../../node_modules/web-streams-polyfill/src/lib/validators/transformer.ts","../../node_modules/web-streams-polyfill/src/lib/transform-stream.ts","../../node_modules/fetch-blob/streams.cjs","../../node_modules/fetch-blob/index.js","../../node_modules/fetch-blob/file.js","../../node_modules/formdata-polyfill/esm.min.js","../../node_modules/node-domexception/index.js","../../node_modules/fetch-blob/from.js","../../node_modules/node-fetch/src/utils/multipart-parser.js","../../node_modules/is-extglob/index.js","../../node_modules/is-glob/index.js","../../node_modules/balanced-match/index.js","../../node_modules/brace-expansion/index.js","../../node_modules/fast-xml-parser/src/util.js","../../node_modules/fast-xml-parser/src/validator.js","../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js","../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js","../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js","../../node_modules/strnum/strnum.js","../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js","../../node_modules/fast-xml-parser/src/xmlparser/node2json.js","../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js","../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js","../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js","../../node_modules/fast-xml-parser/src/fxp.js","../../src/server/lib/symfony.ts","../../node_modules/ts-dedent/src/index.ts","../../src/server/framework-preset.ts","../../src/server/lib/preview-compiler-plugin.ts","../../src/server/lib/injectPreviewHtml.ts","../../src/server/lib/dev-preview-compiler-plugin.ts","../../node_modules/node-fetch/src/index.js","../../node_modules/data-uri-to-buffer/src/index.ts","../../node_modules/node-fetch/src/body.js","../../node_modules/node-fetch/src/errors/base.js","../../node_modules/node-fetch/src/errors/fetch-error.js","../../node_modules/node-fetch/src/utils/is.js","../../node_modules/node-fetch/src/headers.js","../../node_modules/node-fetch/src/utils/is-redirect.js","../../node_modules/node-fetch/src/response.js","../../node_modules/node-fetch/src/request.js","../../node_modules/node-fetch/src/utils/get-search.js","../../node_modules/node-fetch/src/utils/referrer.js","../../node_modules/node-fetch/src/errors/abort-error.js","../../src/server/lib/symfony-api-http.ts","../../src/server/lib/computeAdditionalWatchPaths.ts","../../node_modules/glob/node_modules/minimatch/src/index.ts","../../node_modules/glob/node_modules/minimatch/src/assert-valid-pattern.ts","../../node_modules/glob/node_modules/minimatch/src/brace-expressions.ts","../../node_modules/glob/node_modules/minimatch/src/unescape.ts","../../node_modules/glob/node_modules/minimatch/src/ast.ts","../../node_modules/glob/node_modules/minimatch/src/escape.ts","../../node_modules/lru-cache/src/index.ts","../../node_modules/path-scurry/src/index.ts","../../node_modules/minipass/src/index.ts","../../node_modules/glob/src/glob.ts","../../node_modules/glob/src/pattern.ts","../../node_modules/glob/src/ignore.ts","../../node_modules/glob/src/processor.ts","../../node_modules/glob/src/walker.ts","../../node_modules/glob/src/has-magic.ts","../../node_modules/glob/src/index.ts","../../src/server/lib/twig-loader-plugin.ts","../../src/server/lib/extractComponentsFromTemplate.ts","../../src/server/lib/TwigComponentResolver.ts"],"names":["VirtualModulesPlugin","filter","e","noop","x","_a","F","i","stream","queueMicrotask","r","isAbortSignal","streamBrandCheckException","defaultControllerBrandCheckException","DOMException","ReadableStream","POOL_SIZE","process","emitWarning","Blob","clone","size","File","f","FormData","m","match","Body","clear","isGlob","expand","defaultOptions","t","val","entityName","result","XMLParser","attStr","join","previewHead","previewBody","createUnplugin","http","Stream","PassThrough","Buffer","toFormData","types","INTERNALS","deprecate","response","s","getPreviewHtml","glob","unescape","acc","ext","hasMagic","start","final","qmark","star","regExpEscape","v","bf","p","h","ret","res","path","sep","fs","sync","fileURLToPath","defaultPlatform","rest","abs","target","logger","HtmlWebpackPlugin","PLUGIN_NAME","file","name"],"mappings":"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","sourcesContent":["/**\n * Used to cache a stats object for the virtual file.\n * Extracted from the `mock-fs` package.\n *\n * @author Tim Schaub http://tschaub.net/\n * @author `webpack-virtual-modules` Contributors\n * @link https://github.com/tschaub/mock-fs/blob/master/lib/binding.js\n * @link https://github.com/tschaub/mock-fs/blob/master/license.md\n */\nimport constants from 'constants';\n\nexport class VirtualStats {\n  /**\n   * Create a new stats object.\n   *\n   * @param config Stats properties.\n   */\n  public constructor(config) {\n    for (const key in config) {\n      if (!Object.prototype.hasOwnProperty.call(config, key)) {\n        continue;\n      }\n      this[key] = config[key];\n    }\n  }\n\n  /**\n   * Check if mode indicates property.\n   */\n  private _checkModeProperty(property): boolean {\n    return ((this as any).mode & constants.S_IFMT) === property;\n  }\n\n  public isDirectory(): boolean {\n    return this._checkModeProperty(constants.S_IFDIR);\n  }\n\n  public isFile(): boolean {\n    return this._checkModeProperty(constants.S_IFREG);\n  }\n\n  public isBlockDevice(): boolean {\n    return this._checkModeProperty(constants.S_IFBLK);\n  }\n\n  public isCharacterDevice(): boolean {\n    return this._checkModeProperty(constants.S_IFCHR);\n  }\n\n  public isSymbolicLink(): boolean {\n    return this._checkModeProperty(constants.S_IFLNK);\n  }\n\n  public isFIFO(): boolean {\n    return this._checkModeProperty(constants.S_IFIFO);\n  }\n\n  public isSocket(): boolean {\n    return this._checkModeProperty(constants.S_IFSOCK);\n  }\n}\n","import path from 'path';\nimport { VirtualStats } from './virtual-stats';\nimport type { Compiler } from 'webpack';\n\nlet inode = 45000000;\nconst ALL = 'all';\nconst STATIC = 'static';\nconst DYNAMIC = 'dynamic';\n\ntype AvailableModules = typeof ALL | typeof STATIC | typeof DYNAMIC;\n\nfunction checkActivation(instance) {\n  if (!instance._compiler) {\n    throw new Error('You must use this plugin only after creating webpack instance!');\n  }\n}\n\nfunction getModulePath(filePath, compiler) {\n  return path.isAbsolute(filePath) ? filePath : path.join(compiler.context, filePath);\n}\n\nfunction createWebpackData(result) {\n  return (backendOrStorage) => {\n    // In Webpack v5, this variable is a \"Backend\", and has the data stored in a field\n    // _data. In V4, the `_` prefix isn't present.\n    if (backendOrStorage._data) {\n      const curLevelIdx = backendOrStorage._currentLevel;\n      const curLevel = backendOrStorage._levels[curLevelIdx];\n      return {\n        result,\n        level: curLevel,\n      };\n    }\n    // Webpack 4\n    return [null, result];\n  };\n}\n\nfunction getData(storage, key) {\n  // Webpack 5\n  if (storage._data instanceof Map) {\n    return storage._data.get(key);\n  } else if (storage._data) {\n    return storage.data[key];\n  } else if (storage.data instanceof Map) {\n    // Webpack v4\n    return storage.data.get(key);\n  } else {\n    return storage.data[key];\n  }\n}\n\nfunction setData(backendOrStorage, key, valueFactory) {\n  const value = valueFactory(backendOrStorage);\n\n  // Webpack v5\n  if (backendOrStorage._data instanceof Map) {\n    backendOrStorage._data.set(key, value);\n  } else if (backendOrStorage._data) {\n    backendOrStorage.data[key] = value;\n  } else if (backendOrStorage.data instanceof Map) {\n    // Webpack 4\n    backendOrStorage.data.set(key, value);\n  } else {\n    backendOrStorage.data[key] = value;\n  }\n}\n\nfunction getStatStorage(fileSystem) {\n  if (fileSystem._statStorage) {\n    // Webpack v4\n    return fileSystem._statStorage;\n  } else if (fileSystem._statBackend) {\n    // webpack v5\n    return fileSystem._statBackend;\n  } else {\n    // Unknown version?\n    throw new Error(\"Couldn't find a stat storage\");\n  }\n}\n\nfunction getFileStorage(fileSystem) {\n  if (fileSystem._readFileStorage) {\n    // Webpack v4\n    return fileSystem._readFileStorage;\n  } else if (fileSystem._readFileBackend) {\n    // Webpack v5\n    return fileSystem._readFileBackend;\n  } else {\n    throw new Error(\"Couldn't find a readFileStorage\");\n  }\n}\n\nfunction getReadDirBackend(fileSystem) {\n  if (fileSystem._readdirBackend) {\n    return fileSystem._readdirBackend;\n  } else if (fileSystem._readdirStorage) {\n    return fileSystem._readdirStorage;\n  } else {\n    throw new Error(\"Couldn't find a readDirStorage from Webpack Internals\");\n  }\n}\n\nclass VirtualModulesPlugin {\n  private _staticModules: Record<string, string> | null;\n  private _compiler: Compiler | null = null;\n  private _watcher: any = null;\n\n  public constructor(modules?: Record<string, string>) {\n    this._staticModules = modules || null;\n  }\n\n  public getModuleList(filter: AvailableModules = ALL) {\n    let modules = {};\n    const shouldGetStaticModules = filter === ALL || filter === STATIC;\n    const shouldGetDynamicModules = filter === ALL || filter === DYNAMIC;\n\n    if (shouldGetStaticModules) {\n      // Get static modules\n      modules = {\n        ...modules,\n        ...this._staticModules,\n      };\n    }\n\n    if (shouldGetDynamicModules) {\n      // Get dynamic modules\n      const finalInputFileSystem: any = this._compiler?.inputFileSystem;\n      const virtualFiles = finalInputFileSystem?._virtualFiles ?? {};\n\n      const dynamicModules: Record<string, string> = {};\n      Object.keys(virtualFiles).forEach((key: string) => {\n        dynamicModules[key] = virtualFiles[key].contents;\n      });\n\n      modules = {\n        ...modules,\n        ...dynamicModules,\n      };\n    }\n\n    return modules;\n  }\n\n  public writeModule(filePath: string, contents: string): void {\n    if (!this._compiler) {\n      throw new Error(`Plugin has not been initialized`);\n    }\n\n    checkActivation(this);\n\n    const len = contents ? contents.length : 0;\n    const time = Date.now();\n    const date = new Date(time);\n\n    const stats = new VirtualStats({\n      dev: 8675309,\n      nlink: 0,\n      uid: 1000,\n      gid: 1000,\n      rdev: 0,\n      blksize: 4096,\n      ino: inode++,\n      mode: 33188,\n      size: len,\n      blocks: Math.floor(len / 4096),\n      atime: date,\n      mtime: date,\n      ctime: date,\n      birthtime: date,\n    });\n    const modulePath = getModulePath(filePath, this._compiler);\n\n    if (process.env.WVM_DEBUG)\n      // eslint-disable-next-line no-console\n      console.log(this._compiler.name, 'Write virtual module:', modulePath, contents);\n\n    // When using the WatchIgnorePlugin (https://github.com/webpack/webpack/blob/52184b897f40c75560b3630e43ca642fcac7e2cf/lib/WatchIgnorePlugin.js),\n    // the original watchFileSystem is stored in `wfs`. The following \"unwraps\" the ignoring\n    // wrappers, giving us access to the \"real\" watchFileSystem.\n    let finalWatchFileSystem = this._watcher && this._watcher.watchFileSystem;\n\n    while (finalWatchFileSystem && finalWatchFileSystem.wfs) {\n      finalWatchFileSystem = finalWatchFileSystem.wfs;\n    }\n\n    let finalInputFileSystem: any = this._compiler.inputFileSystem;\n    while (finalInputFileSystem && finalInputFileSystem._inputFileSystem) {\n      finalInputFileSystem = finalInputFileSystem._inputFileSystem;\n    }\n\n    finalInputFileSystem._writeVirtualFile(modulePath, stats, contents);\n    if (\n      finalWatchFileSystem &&\n      finalWatchFileSystem.watcher &&\n      (finalWatchFileSystem.watcher.fileWatchers.size || finalWatchFileSystem.watcher.fileWatchers.length)\n    ) {\n      const fileWatchers =\n        finalWatchFileSystem.watcher.fileWatchers instanceof Map\n          ? Array.from(finalWatchFileSystem.watcher.fileWatchers.values())\n          : finalWatchFileSystem.watcher.fileWatchers;\n      for (let fileWatcher of fileWatchers) {\n        if ('watcher' in fileWatcher) {\n          fileWatcher = fileWatcher.watcher;\n        }\n        if (fileWatcher.path === modulePath) {\n          if (process.env.DEBUG)\n            // eslint-disable-next-line no-console\n            console.log(this._compiler.name, 'Emit file change:', modulePath, time);\n          delete fileWatcher.directoryWatcher._cachedTimeInfoEntries;\n          fileWatcher.emit('change', time, null);\n        }\n      }\n    }\n  }\n\n  public apply(compiler: Compiler) {\n    this._compiler = compiler;\n\n    const afterEnvironmentHook = () => {\n      let finalInputFileSystem: any = compiler.inputFileSystem;\n      while (finalInputFileSystem && finalInputFileSystem._inputFileSystem) {\n        finalInputFileSystem = finalInputFileSystem._inputFileSystem;\n      }\n\n      if (!finalInputFileSystem._writeVirtualFile) {\n        const originalPurge = finalInputFileSystem.purge;\n\n        finalInputFileSystem.purge = () => {\n          originalPurge.apply(finalInputFileSystem, []);\n          if (finalInputFileSystem._virtualFiles) {\n            Object.keys(finalInputFileSystem._virtualFiles).forEach((file) => {\n              const data = finalInputFileSystem._virtualFiles[file];\n              finalInputFileSystem._writeVirtualFile(file, data.stats, data.contents);\n            });\n          }\n        };\n\n        finalInputFileSystem._writeVirtualFile = (file, stats, contents) => {\n          const statStorage = getStatStorage(finalInputFileSystem);\n          const fileStorage = getFileStorage(finalInputFileSystem);\n          const readDirStorage = getReadDirBackend(finalInputFileSystem);\n          finalInputFileSystem._virtualFiles = finalInputFileSystem._virtualFiles || {};\n          finalInputFileSystem._virtualFiles[file] = { stats: stats, contents: contents };\n          setData(statStorage, file, createWebpackData(stats));\n          setData(fileStorage, file, createWebpackData(contents));\n          const segments = file.split(/[\\\\/]/);\n          let count = segments.length - 1;\n          const minCount = segments[0] ? 1 : 0;\n          while (count > minCount) {\n            const dir = segments.slice(0, count).join(path.sep) || path.sep;\n            try {\n              finalInputFileSystem.readdirSync(dir);\n            } catch (e) {\n              const time = Date.now();\n              const dirStats = new VirtualStats({\n                dev: 8675309,\n                nlink: 0,\n                uid: 1000,\n                gid: 1000,\n                rdev: 0,\n                blksize: 4096,\n                ino: inode++,\n                mode: 16877,\n                size: stats.size,\n                blocks: Math.floor(stats.size / 4096),\n                atime: time,\n                mtime: time,\n                ctime: time,\n                birthtime: time,\n              });\n\n              setData(readDirStorage, dir, createWebpackData([]));\n              setData(statStorage, dir, createWebpackData(dirStats));\n            }\n            let dirData = getData(getReadDirBackend(finalInputFileSystem), dir);\n            // Webpack v4 returns an array, webpack v5 returns an object\n            dirData = dirData[1] || dirData.result;\n            const filename = segments[count];\n            if (dirData.indexOf(filename) < 0) {\n              const files = dirData.concat([filename]).sort();\n              setData(getReadDirBackend(finalInputFileSystem), dir, createWebpackData(files));\n            } else {\n              break;\n            }\n            count--;\n          }\n        };\n      }\n    };\n    const afterResolversHook = () => {\n      if (this._staticModules) {\n        for (const [filePath, contents] of Object.entries(this._staticModules)) {\n          this.writeModule(filePath, contents);\n        }\n        this._staticModules = null;\n      }\n    };\n\n    // The webpack property is not exposed in webpack v4\n    const version = typeof (compiler as any).webpack === 'undefined' ? 4 : 5;\n\n    const watchRunHook = (watcher, callback) => {\n      this._watcher = watcher.compiler || watcher;\n      const virtualFiles = (compiler as any).inputFileSystem._virtualFiles;\n      const fts = compiler.fileTimestamps as any;\n\n      if (virtualFiles && fts && typeof fts.set === 'function') {\n        Object.keys(virtualFiles).forEach((file) => {\n          const mtime = +virtualFiles[file].stats.mtime;\n          // fts is\n          // Map<string, number> in webpack 4\n          // Map<string, { safeTime: number; timestamp: number; }> in webpack 5\n          fts.set(\n            file,\n            version === 4\n              ? mtime\n              : {\n                  safeTime: mtime,\n                  timestamp: mtime,\n                }\n          );\n        });\n      }\n      callback();\n    };\n\n    if (compiler.hooks) {\n      compiler.hooks.afterEnvironment.tap('VirtualModulesPlugin', afterEnvironmentHook);\n      compiler.hooks.afterResolvers.tap('VirtualModulesPlugin', afterResolversHook);\n      compiler.hooks.watchRun.tapAsync('VirtualModulesPlugin', watchRunHook);\n    } else {\n      (compiler as any).plugin('after-environment', afterEnvironmentHook);\n      (compiler as any).plugin('after-resolvers', afterResolversHook);\n      (compiler as any).plugin('watch-run', watchRunHook);\n    }\n  }\n}\n\nexport = VirtualModulesPlugin;\n","export function noop(): undefined {\n  return undefined;\n}\n","import { noop } from '../../utils';\nimport { AssertionError } from '../../stub/assert';\n\nexport function typeIsObject(x: any): x is object {\n  return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\n\nexport const rethrowAssertionErrorRejection: (e: any) => void =\n  DEBUG ? e => {\n    // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\n    // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\n    // expect any errors, but assertion errors are always problematic.\n    if (e && e instanceof AssertionError) {\n      setTimeout(() => {\n        throw e;\n      }, 0);\n    }\n  } : noop;\n\nexport function setFunctionName(fn: Function, name: string): void {\n  try {\n    Object.defineProperty(fn, 'name', {\n      value: name,\n      configurable: true\n    });\n  } catch {\n    // This property is non-configurable in older browsers, so ignore if this throws.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n  }\n}\n","import { rethrowAssertionErrorRejection } from './miscellaneous';\nimport assert from '../../stub/assert';\n\nconst originalPromise = Promise;\nconst originalPromiseThen = Promise.prototype.then;\nconst originalPromiseReject = Promise.reject.bind(originalPromise);\n\n// https://webidl.spec.whatwg.org/#a-new-promise\nexport function newPromise<T>(executor: (\n  resolve: (value: T | PromiseLike<T>) => void,\n  reject: (reason?: any) => void\n) => void): Promise<T> {\n  return new originalPromise(executor);\n}\n\n// https://webidl.spec.whatwg.org/#a-promise-resolved-with\nexport function promiseResolvedWith<T>(value: T | PromiseLike<T>): Promise<T> {\n  return newPromise(resolve => resolve(value));\n}\n\n// https://webidl.spec.whatwg.org/#a-promise-rejected-with\nexport function promiseRejectedWith<T = never>(reason: any): Promise<T> {\n  return originalPromiseReject(reason);\n}\n\nexport function PerformPromiseThen<T, TResult1 = T, TResult2 = never>(\n  promise: Promise<T>,\n  onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,\n  onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\n  // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n  // approximation.\n  return originalPromiseThen.call(promise, onFulfilled, onRejected) as Promise<TResult1 | TResult2>;\n}\n\n// Bluebird logs a warning when a promise is created within a fulfillment handler, but then isn't returned\n// from that handler. To prevent this, return null instead of void from all handlers.\n// http://bluebirdjs.com/docs/warning-explanations.html#warning-a-promise-was-created-in-a-handler-but-was-not-returned-from-it\nexport function uponPromise<T>(\n  promise: Promise<T>,\n  onFulfilled?: (value: T) => null | PromiseLike<null>,\n  onRejected?: (reason: any) => null | PromiseLike<null>): void {\n  PerformPromiseThen(\n    PerformPromiseThen(promise, onFulfilled, onRejected),\n    undefined,\n    rethrowAssertionErrorRejection\n  );\n}\n\nexport function uponFulfillment<T>(promise: Promise<T>, onFulfilled: (value: T) => null | PromiseLike<null>): void {\n  uponPromise(promise, onFulfilled);\n}\n\nexport function uponRejection(promise: Promise<unknown>, onRejected: (reason: any) => null | PromiseLike<null>): void {\n  uponPromise(promise, undefined, onRejected);\n}\n\nexport function transformPromiseWith<T, TResult1 = T, TResult2 = never>(\n  promise: Promise<T>,\n  fulfillmentHandler?: (value: T) => TResult1 | PromiseLike<TResult1>,\n  rejectionHandler?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\n  return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n}\n\nexport function setPromiseIsHandledToTrue(promise: Promise<unknown>): void {\n  PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n}\n\nlet _queueMicrotask: (callback: () => void) => void = callback => {\n  if (typeof queueMicrotask === 'function') {\n    _queueMicrotask = queueMicrotask;\n  } else {\n    const resolvedPromise = promiseResolvedWith(undefined);\n    _queueMicrotask = cb => PerformPromiseThen(resolvedPromise, cb);\n  }\n  return _queueMicrotask(callback);\n};\n\nexport { _queueMicrotask as queueMicrotask };\n\nexport function reflectCall<T, A extends any[], R>(F: (this: T, ...fnArgs: A) => R, V: T, args: A): R {\n  if (typeof F !== 'function') {\n    throw new TypeError('Argument is not a function');\n  }\n  return Function.prototype.apply.call(F, V, args);\n}\n\nexport function promiseCall<T, A extends any[], R>(F: (this: T, ...fnArgs: A) => R | PromiseLike<R>,\n                                                   V: T,\n                                                   args: A): Promise<R> {\n  assert(typeof F === 'function');\n  assert(V !== undefined);\n  assert(Array.isArray(args));\n  try {\n    return promiseResolvedWith(reflectCall(F, V, args));\n  } catch (value) {\n    return promiseRejectedWith(value);\n  }\n}\n","import assert from '../stub/assert';\n\n// Original from Chromium\n// https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n\nconst QUEUE_MAX_ARRAY_SIZE = 16384;\n\ninterface Node<T> {\n  _elements: T[];\n  _next: Node<T> | undefined;\n}\n\n/**\n * Simple queue structure.\n *\n * Avoids scalability issues with using a packed array directly by using\n * multiple arrays in a linked list and keeping the array size bounded.\n */\nexport class SimpleQueue<T> {\n  private _front: Node<T>;\n  private _back: Node<T>;\n  private _cursor = 0;\n  private _size = 0;\n\n  constructor() {\n    // _front and _back are always defined.\n    this._front = {\n      _elements: [],\n      _next: undefined\n    };\n    this._back = this._front;\n    // The cursor is used to avoid calling Array.shift().\n    // It contains the index of the front element of the array inside the\n    // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n    this._cursor = 0;\n    // When there is only one node, size === elements.length - cursor.\n    this._size = 0;\n  }\n\n  get length(): number {\n    return this._size;\n  }\n\n  // For exception safety, this method is structured in order:\n  // 1. Read state\n  // 2. Calculate required state mutations\n  // 3. Perform state mutations\n  push(element: T): void {\n    const oldBack = this._back;\n    let newBack = oldBack;\n    assert(oldBack._next === undefined);\n    if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n      newBack = {\n        _elements: [],\n        _next: undefined\n      };\n    }\n\n    // push() is the mutation most likely to throw an exception, so it\n    // goes first.\n    oldBack._elements.push(element);\n    if (newBack !== oldBack) {\n      this._back = newBack;\n      oldBack._next = newBack;\n    }\n    ++this._size;\n  }\n\n  // Like push(), shift() follows the read -> calculate -> mutate pattern for\n  // exception safety.\n  shift(): T {\n    assert(this._size > 0); // must not be called on an empty queue\n\n    const oldFront = this._front;\n    let newFront = oldFront;\n    const oldCursor = this._cursor;\n    let newCursor = oldCursor + 1;\n\n    const elements = oldFront._elements;\n    const element = elements[oldCursor];\n\n    if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n      assert(elements.length === QUEUE_MAX_ARRAY_SIZE);\n      assert(oldFront._next !== undefined);\n      newFront = oldFront._next!;\n      newCursor = 0;\n    }\n\n    // No mutations before this point.\n    --this._size;\n    this._cursor = newCursor;\n    if (oldFront !== newFront) {\n      this._front = newFront;\n    }\n\n    // Permit shifted element to be garbage collected.\n    elements[oldCursor] = undefined!;\n\n    return element;\n  }\n\n  // The tricky thing about forEach() is that it can be called\n  // re-entrantly. The queue may be mutated inside the callback. It is easy to\n  // see that push() within the callback has no negative effects since the end\n  // of the queue is checked for on every iteration. If shift() is called\n  // repeatedly within the callback then the next iteration may return an\n  // element that has been removed. In this case the callback will be called\n  // with undefined values until we either \"catch up\" with elements that still\n  // exist or reach the back of the queue.\n  forEach(callback: (element: T) => void): void {\n    let i = this._cursor;\n    let node = this._front;\n    let elements = node._elements;\n    while (i !== elements.length || node._next !== undefined) {\n      if (i === elements.length) {\n        assert(node._next !== undefined);\n        assert(i === QUEUE_MAX_ARRAY_SIZE);\n        node = node._next!;\n        elements = node._elements;\n        i = 0;\n        if (elements.length === 0) {\n          break;\n        }\n      }\n      callback(elements[i]);\n      ++i;\n    }\n  }\n\n  // Return the element that would be returned if shift() was called now,\n  // without modifying the queue.\n  peek(): T {\n    assert(this._size > 0); // must not be called on an empty queue\n\n    const front = this._front;\n    const cursor = this._cursor;\n    return front._elements[cursor];\n  }\n}\n","export const AbortSteps = Symbol('[[AbortSteps]]');\nexport const ErrorSteps = Symbol('[[ErrorSteps]]');\nexport const CancelSteps = Symbol('[[CancelSteps]]');\nexport const PullSteps = Symbol('[[PullSteps]]');\nexport const ReleaseSteps = Symbol('[[ReleaseSteps]]');\n","import assert from '../../stub/assert';\nimport { ReadableStream, ReadableStreamCancel, type ReadableStreamReader } from '../readable-stream';\nimport { newPromise, setPromiseIsHandledToTrue } from '../helpers/webidl';\nimport { ReleaseSteps } from '../abstract-ops/internal-methods';\n\nexport function ReadableStreamReaderGenericInitialize<R>(reader: ReadableStreamReader<R>, stream: ReadableStream<R>) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    assert(stream._state === 'errored');\n\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n  }\n}\n\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\nexport function ReadableStreamReaderGenericCancel(reader: ReadableStreamReader<any>, reason: any): Promise<undefined> {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  return ReadableStreamCancel(stream, reason);\n}\n\nexport function ReadableStreamReaderGenericRelease(reader: ReadableStreamReader<any>) {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  assert(stream._reader === reader);\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseReject(\n      reader,\n      new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(\n      reader,\n      new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  }\n\n  stream._readableStreamController[ReleaseSteps]();\n\n  stream._reader = undefined;\n  reader._ownerReadableStream = undefined!;\n}\n\n// Helper functions for the readers.\n\nexport function readerLockException(name: string): TypeError {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nexport function defaultReaderClosedPromiseInitialize(reader: ReadableStreamReader<any>) {\n  reader._closedPromise = newPromise((resolve, reject) => {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nexport function defaultReaderClosedPromiseInitializeAsRejected(reader: ReadableStreamReader<any>, reason: any) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseReject(reader, reason);\n}\n\nexport function defaultReaderClosedPromiseInitializeAsResolved(reader: ReadableStreamReader<any>) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseResolve(reader);\n}\n\nexport function defaultReaderClosedPromiseReject(reader: ReadableStreamReader<any>, reason: any) {\n  if (reader._closedPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(reader._closedPromise);\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nexport function defaultReaderClosedPromiseResetToRejected(reader: ReadableStreamReader<any>, reason: any) {\n  assert(reader._closedPromise_resolve === undefined);\n  assert(reader._closedPromise_reject === undefined);\n\n  defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n}\n\nexport function defaultReaderClosedPromiseResolve(reader: ReadableStreamReader<any>) {\n  if (reader._closedPromise_resolve === undefined) {\n    return;\n  }\n\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n","/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\nconst NumberIsFinite: typeof Number.isFinite = Number.isFinite || function (x) {\n  return typeof x === 'number' && isFinite(x);\n};\n\nexport default NumberIsFinite;\n","/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\nconst MathTrunc: typeof Math.trunc = Math.trunc || function (v) {\n  return v < 0 ? Math.ceil(v) : Math.floor(v);\n};\n\nexport default MathTrunc;\n","import NumberIsFinite from '../../stub/number-isfinite';\nimport MathTrunc from '../../stub/math-trunc';\n\n// https://heycam.github.io/webidl/#idl-dictionaries\nexport function isDictionary(x: any): x is object | null {\n  return typeof x === 'object' || typeof x === 'function';\n}\n\nexport function assertDictionary(obj: unknown,\n                                 context: string): asserts obj is object | null | undefined {\n  if (obj !== undefined && !isDictionary(obj)) {\n    throw new TypeError(`${context} is not an object.`);\n  }\n}\n\nexport type AnyFunction = (...args: any[]) => any;\n\n// https://heycam.github.io/webidl/#idl-callback-functions\nexport function assertFunction(x: unknown, context: string): asserts x is AnyFunction {\n  if (typeof x !== 'function') {\n    throw new TypeError(`${context} is not a function.`);\n  }\n}\n\n// https://heycam.github.io/webidl/#idl-object\nexport function isObject(x: any): x is object {\n  return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\n\nexport function assertObject(x: unknown,\n                             context: string): asserts x is object {\n  if (!isObject(x)) {\n    throw new TypeError(`${context} is not an object.`);\n  }\n}\n\nexport function assertRequiredArgument<T>(x: T | undefined,\n                                          position: number,\n                                          context: string): asserts x is T {\n  if (x === undefined) {\n    throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n  }\n}\n\nexport function assertRequiredField<T>(x: T | undefined,\n                                       field: string,\n                                       context: string): asserts x is T {\n  if (x === undefined) {\n    throw new TypeError(`${field} is required in '${context}'.`);\n  }\n}\n\n// https://heycam.github.io/webidl/#idl-unrestricted-double\nexport function convertUnrestrictedDouble(value: unknown): number {\n  return Number(value);\n}\n\nfunction censorNegativeZero(x: number): number {\n  return x === 0 ? 0 : x;\n}\n\nfunction integerPart(x: number): number {\n  return censorNegativeZero(MathTrunc(x));\n}\n\n// https://heycam.github.io/webidl/#idl-unsigned-long-long\nexport function convertUnsignedLongLongWithEnforceRange(value: unknown, context: string): number {\n  const lowerBound = 0;\n  const upperBound = Number.MAX_SAFE_INTEGER;\n\n  let x = Number(value);\n  x = censorNegativeZero(x);\n\n  if (!NumberIsFinite(x)) {\n    throw new TypeError(`${context} is not a finite number`);\n  }\n\n  x = integerPart(x);\n\n  if (x < lowerBound || x > upperBound) {\n    throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n  }\n\n  if (!NumberIsFinite(x) || x === 0) {\n    return 0;\n  }\n\n  // TODO Use BigInt if supported?\n  // let xBigInt = BigInt(integerPart(x));\n  // xBigInt = BigInt.asUintN(64, xBigInt);\n  // return Number(xBigInt);\n\n  return x;\n}\n","import { IsReadableStream, ReadableStream } from '../readable-stream';\n\nexport function assertReadableStream(x: unknown, context: string): asserts x is ReadableStream {\n  if (!IsReadableStream(x)) {\n    throw new TypeError(`${context} is not a ReadableStream.`);\n  }\n}\n","import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericInitialize,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport { IsReadableStreamLocked, ReadableStream } from '../readable-stream';\nimport { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\nimport { PullSteps } from '../abstract-ops/internal-methods';\nimport { newPromise, promiseRejectedWith } from '../helpers/webidl';\nimport { assertRequiredArgument } from '../validators/basic';\nimport { assertReadableStream } from '../validators/readable-stream';\n\n/**\n * A result returned by {@link ReadableStreamDefaultReader.read}.\n *\n * @public\n */\nexport type ReadableStreamDefaultReadResult<T> = {\n  done: false;\n  value: T;\n} | {\n  done: true;\n  value?: undefined;\n}\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamDefaultReader<R>(stream: ReadableStream): ReadableStreamDefaultReader<R> {\n  return new ReadableStreamDefaultReader(stream);\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamAddReadRequest<R>(stream: ReadableStream<R>,\n                                                readRequest: ReadRequest<R>): void {\n  assert(IsReadableStreamDefaultReader(stream._reader));\n  assert(stream._state === 'readable');\n\n  (stream._reader! as ReadableStreamDefaultReader<R>)._readRequests.push(readRequest);\n}\n\nexport function ReadableStreamFulfillReadRequest<R>(stream: ReadableStream<R>, chunk: R | undefined, done: boolean) {\n  const reader = stream._reader as ReadableStreamDefaultReader<R>;\n\n  assert(reader._readRequests.length > 0);\n\n  const readRequest = reader._readRequests.shift()!;\n  if (done) {\n    readRequest._closeSteps();\n  } else {\n    readRequest._chunkSteps(chunk!);\n  }\n}\n\nexport function ReadableStreamGetNumReadRequests<R>(stream: ReadableStream<R>): number {\n  return (stream._reader as ReadableStreamDefaultReader<R>)._readRequests.length;\n}\n\nexport function ReadableStreamHasDefaultReader(stream: ReadableStream): boolean {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (!IsReadableStreamDefaultReader(reader)) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nexport interface ReadRequest<R> {\n  _chunkSteps(chunk: R): void;\n\n  _closeSteps(): void;\n\n  _errorSteps(e: any): void;\n}\n\n/**\n * A default reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nexport class ReadableStreamDefaultReader<R = any> {\n  /** @internal */\n  _ownerReadableStream!: ReadableStream<R>;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readRequests: SimpleQueue<ReadRequest<R>>;\n\n  constructor(stream: ReadableStream<R>) {\n    assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n    assertReadableStream(stream, 'First parameter');\n\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readRequests = new SimpleQueue();\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed,\n   * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  /**\n   * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n   *\n   * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   */\n  read(): Promise<ReadableStreamDefaultReadResult<R>> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('read from'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamDefaultReadResult<R>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamDefaultReadResult<R>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n      _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n      _errorSteps: e => rejectPromise(e)\n    };\n    ReadableStreamDefaultReaderRead(this, readRequest);\n    return promise;\n  }\n\n  /**\n   * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n   * from now on; otherwise, the reader will appear closed.\n   *\n   * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n   * do so will throw a `TypeError` and leave the reader locked to the stream.\n   */\n  releaseLock(): void {\n    if (!IsReadableStreamDefaultReader(this)) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    ReadableStreamDefaultReaderRelease(this);\n  }\n}\n\nObject.defineProperties(ReadableStreamDefaultReader.prototype, {\n  cancel: { enumerable: true },\n  read: { enumerable: true },\n  releaseLock: { enumerable: true },\n  closed: { enumerable: true }\n});\nsetFunctionName(ReadableStreamDefaultReader.prototype.cancel, 'cancel');\nsetFunctionName(ReadableStreamDefaultReader.prototype.read, 'read');\nsetFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, 'releaseLock');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamDefaultReader',\n    configurable: true\n  });\n}\n\n// Abstract operations for the readers.\n\nexport function IsReadableStreamDefaultReader<R = any>(x: any): x is ReadableStreamDefaultReader<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamDefaultReader;\n}\n\nexport function ReadableStreamDefaultReaderRead<R>(reader: ReadableStreamDefaultReader<R>,\n                                                   readRequest: ReadRequest<R>): void {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    readRequest._closeSteps();\n  } else if (stream._state === 'errored') {\n    readRequest._errorSteps(stream._storedError);\n  } else {\n    assert(stream._state === 'readable');\n    stream._readableStreamController[PullSteps](readRequest as ReadRequest<any>);\n  }\n}\n\nexport function ReadableStreamDefaultReaderRelease(reader: ReadableStreamDefaultReader) {\n  ReadableStreamReaderGenericRelease(reader);\n  const e = new TypeError('Reader was released');\n  ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n}\n\nexport function ReadableStreamDefaultReaderErrorReadRequests(reader: ReadableStreamDefaultReader, e: any) {\n  const readRequests = reader._readRequests;\n  reader._readRequests = new SimpleQueue();\n  readRequests.forEach(readRequest => {\n    readRequest._errorSteps(e);\n  });\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction defaultReaderBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n","/// <reference lib=\"es2018.asynciterable\" />\n\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport const AsyncIteratorPrototype: AsyncIterable<any> =\n  Object.getPrototypeOf(Object.getPrototypeOf(async function* (): AsyncIterableIterator<any> {}).prototype);\n","/// <reference lib=\"es2018.asynciterable\" />\n\nimport { ReadableStream } from '../readable-stream';\nimport {\n  AcquireReadableStreamDefaultReader,\n  ReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderRead,\n  type ReadableStreamDefaultReadResult,\n  type ReadRequest\n} from './default-reader';\nimport { ReadableStreamReaderGenericCancel, ReadableStreamReaderGenericRelease } from './generic-reader';\nimport assert from '../../stub/assert';\nimport { AsyncIteratorPrototype } from '@@target/stub/async-iterator-prototype';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  queueMicrotask,\n  transformPromiseWith\n} from '../helpers/webidl';\n\n/**\n * An async iterator returned by {@link ReadableStream.values}.\n *\n * @public\n */\nexport interface ReadableStreamAsyncIterator<R> extends AsyncIterableIterator<R> {\n  next(): Promise<IteratorResult<R, undefined>>;\n\n  return(value?: any): Promise<IteratorResult<any>>;\n}\n\nexport class ReadableStreamAsyncIteratorImpl<R> {\n  private readonly _reader: ReadableStreamDefaultReader<R>;\n  private readonly _preventCancel: boolean;\n  private _ongoingPromise: Promise<ReadableStreamDefaultReadResult<R>> | undefined = undefined;\n  private _isFinished = false;\n\n  constructor(reader: ReadableStreamDefaultReader<R>, preventCancel: boolean) {\n    this._reader = reader;\n    this._preventCancel = preventCancel;\n  }\n\n  next(): Promise<ReadableStreamDefaultReadResult<R>> {\n    const nextSteps = () => this._nextSteps();\n    this._ongoingPromise = this._ongoingPromise ?\n      transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :\n      nextSteps();\n    return this._ongoingPromise;\n  }\n\n  return(value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    const returnSteps = () => this._returnSteps(value);\n    return this._ongoingPromise ?\n      transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :\n      returnSteps();\n  }\n\n  private _nextSteps(): Promise<ReadableStreamDefaultReadResult<R>> {\n    if (this._isFinished) {\n      return Promise.resolve({ value: undefined, done: true });\n    }\n\n    const reader = this._reader;\n    assert(reader._ownerReadableStream !== undefined);\n\n    let resolvePromise!: (result: ReadableStreamDefaultReadResult<R>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamDefaultReadResult<R>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => {\n        this._ongoingPromise = undefined;\n        // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n        // FIXME Is this a bug in the specification, or in the test?\n        queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n      },\n      _closeSteps: () => {\n        this._ongoingPromise = undefined;\n        this._isFinished = true;\n        ReadableStreamReaderGenericRelease(reader);\n        resolvePromise({ value: undefined, done: true });\n      },\n      _errorSteps: reason => {\n        this._ongoingPromise = undefined;\n        this._isFinished = true;\n        ReadableStreamReaderGenericRelease(reader);\n        rejectPromise(reason);\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n    return promise;\n  }\n\n  private _returnSteps(value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (this._isFinished) {\n      return Promise.resolve({ value, done: true });\n    }\n    this._isFinished = true;\n\n    const reader = this._reader;\n    assert(reader._ownerReadableStream !== undefined);\n    assert(reader._readRequests.length === 0);\n\n    if (!this._preventCancel) {\n      const result = ReadableStreamReaderGenericCancel(reader, value);\n      ReadableStreamReaderGenericRelease(reader);\n      return transformPromiseWith(result, () => ({ value, done: true }));\n    }\n\n    ReadableStreamReaderGenericRelease(reader);\n    return promiseResolvedWith({ value, done: true });\n  }\n}\n\ninterface ReadableStreamAsyncIteratorInstance<R> extends ReadableStreamAsyncIterator<R> {\n  /** @interal */\n  _asyncIteratorImpl: ReadableStreamAsyncIteratorImpl<R>;\n\n  next(): Promise<IteratorResult<R, undefined>>;\n\n  return(value?: any): Promise<IteratorResult<any>>;\n}\n\nconst ReadableStreamAsyncIteratorPrototype: ReadableStreamAsyncIteratorInstance<any> = {\n  next(this: ReadableStreamAsyncIteratorInstance<any>): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (!IsReadableStreamAsyncIterator(this)) {\n      return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n    }\n    return this._asyncIteratorImpl.next();\n  },\n\n  return(this: ReadableStreamAsyncIteratorInstance<any>, value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (!IsReadableStreamAsyncIterator(this)) {\n      return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n    }\n    return this._asyncIteratorImpl.return(value);\n  }\n} as any;\nObject.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamAsyncIterator<R>(stream: ReadableStream<R>,\n                                                      preventCancel: boolean): ReadableStreamAsyncIterator<R> {\n  const reader = AcquireReadableStreamDefaultReader<R>(stream);\n  const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n  const iterator: ReadableStreamAsyncIteratorInstance<R> = Object.create(ReadableStreamAsyncIteratorPrototype);\n  iterator._asyncIteratorImpl = impl;\n  return iterator;\n}\n\nfunction IsReadableStreamAsyncIterator<R = any>(x: any): x is ReadableStreamAsyncIterator<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n    return false;\n  }\n\n  try {\n    // noinspection SuspiciousTypeOfGuard\n    return (x as ReadableStreamAsyncIteratorInstance<any>)._asyncIteratorImpl instanceof\n      ReadableStreamAsyncIteratorImpl;\n  } catch {\n    return false;\n  }\n}\n\n// Helper functions for the ReadableStream.\n\nfunction streamAsyncIteratorBrandCheckException(name: string): TypeError {\n  return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n}\n","/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN: typeof Number.isNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nexport default NumberIsNaN;\n","import { reflectCall } from 'lib/helpers/webidl';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport assert from '../../stub/assert';\n\ndeclare global {\n  interface ArrayBuffer {\n    readonly detached: boolean;\n\n    transfer(): ArrayBuffer;\n  }\n\n  function structuredClone<T>(value: T, options: { transfer: ArrayBuffer[] }): T;\n}\n\nexport function CreateArrayFromList<T extends any[]>(elements: T): T {\n  // We use arrays to represent lists, so this is basically a no-op.\n  // Do a slice though just in case we happen to depend on the unique-ness.\n  return elements.slice() as T;\n}\n\nexport function CopyDataBlockBytes(dest: ArrayBuffer,\n                                   destOffset: number,\n                                   src: ArrayBuffer,\n                                   srcOffset: number,\n                                   n: number) {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n}\n\nexport let TransferArrayBuffer = (O: ArrayBuffer): ArrayBuffer => {\n  if (typeof O.transfer === 'function') {\n    TransferArrayBuffer = buffer => buffer.transfer();\n  } else if (typeof structuredClone === 'function') {\n    TransferArrayBuffer = buffer => structuredClone(buffer, { transfer: [buffer] });\n  } else {\n    // Not implemented correctly\n    TransferArrayBuffer = buffer => buffer;\n  }\n  return TransferArrayBuffer(O);\n};\n\nexport function CanTransferArrayBuffer(O: ArrayBuffer): boolean {\n  return !IsDetachedBuffer(O);\n}\n\nexport let IsDetachedBuffer = (O: ArrayBuffer): boolean => {\n  if (typeof O.detached === 'boolean') {\n    IsDetachedBuffer = buffer => buffer.detached;\n  } else {\n    // Not implemented correctly\n    IsDetachedBuffer = buffer => buffer.byteLength === 0;\n  }\n  return IsDetachedBuffer(O);\n};\n\nexport function ArrayBufferSlice(buffer: ArrayBuffer, begin: number, end: number): ArrayBuffer {\n  // ArrayBuffer.prototype.slice is not available on IE10\n  // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n  if (buffer.slice) {\n    return buffer.slice(begin, end);\n  }\n  const length = end - begin;\n  const slice = new ArrayBuffer(length);\n  CopyDataBlockBytes(slice, 0, buffer, begin, length);\n  return slice;\n}\n\nexport type MethodName<T> = {\n  [P in keyof T]: T[P] extends Function | undefined ? P : never;\n}[keyof T];\n\nexport function GetMethod<T, K extends MethodName<T>>(receiver: T, prop: K): T[K] | undefined {\n  const func = receiver[prop];\n  if (func === undefined || func === null) {\n    return undefined;\n  }\n  if (typeof func !== 'function') {\n    throw new TypeError(`${String(prop)} is not a function`);\n  }\n  return func;\n}\n\nexport interface SyncIteratorRecord<T> {\n  iterator: Iterator<T>,\n  nextMethod: Iterator<T>['next'],\n  done: boolean;\n}\n\nexport interface AsyncIteratorRecord<T> {\n  iterator: AsyncIterator<T>,\n  nextMethod: AsyncIterator<T>['next'],\n  done: boolean;\n}\n\nexport type SyncOrAsyncIteratorRecord<T> = SyncIteratorRecord<T> | AsyncIteratorRecord<T>;\n\nexport function CreateAsyncFromSyncIterator<T>(syncIteratorRecord: SyncIteratorRecord<T>): AsyncIteratorRecord<T> {\n  // Instead of re-implementing CreateAsyncFromSyncIterator and %AsyncFromSyncIteratorPrototype%,\n  // we use yield* inside an async generator function to achieve the same result.\n\n  // Wrap the sync iterator inside a sync iterable, so we can use it with yield*.\n  const syncIterable = {\n    [Symbol.iterator]: () => syncIteratorRecord.iterator\n  };\n  // Create an async generator function and immediately invoke it.\n  const asyncIterator = (async function* () {\n    return yield* syncIterable;\n  }());\n  // Return as an async iterator record.\n  const nextMethod = asyncIterator.next;\n  return { iterator: asyncIterator, nextMethod, done: false };\n}\n\n// Aligns with core-js/modules/es.symbol.async-iterator.js\nexport const SymbolAsyncIterator: (typeof Symbol)['asyncIterator'] =\n  Symbol.asyncIterator ??\n  Symbol.for?.('Symbol.asyncIterator') ??\n  '@@asyncIterator';\n\nexport type SyncOrAsyncIterable<T> = Iterable<T> | AsyncIterable<T>;\nexport type SyncOrAsyncIteratorMethod<T> = () => (Iterator<T> | AsyncIterator<T>);\n\nfunction GetIterator<T>(\n  obj: SyncOrAsyncIterable<T>,\n  hint: 'async',\n  method?: SyncOrAsyncIteratorMethod<T>\n): AsyncIteratorRecord<T>;\nfunction GetIterator<T>(\n  obj: Iterable<T>,\n  hint: 'sync',\n  method?: SyncOrAsyncIteratorMethod<T>\n): SyncIteratorRecord<T>;\nfunction GetIterator<T>(\n  obj: SyncOrAsyncIterable<T>,\n  hint = 'sync',\n  method?: SyncOrAsyncIteratorMethod<T>\n): SyncOrAsyncIteratorRecord<T> {\n  assert(hint === 'sync' || hint === 'async');\n  if (method === undefined) {\n    if (hint === 'async') {\n      method = GetMethod(obj as AsyncIterable<T>, SymbolAsyncIterator);\n      if (method === undefined) {\n        const syncMethod = GetMethod(obj as Iterable<T>, Symbol.iterator);\n        const syncIteratorRecord = GetIterator(obj as Iterable<T>, 'sync', syncMethod);\n        return CreateAsyncFromSyncIterator(syncIteratorRecord);\n      }\n    } else {\n      method = GetMethod(obj as Iterable<T>, Symbol.iterator);\n    }\n  }\n  if (method === undefined) {\n    throw new TypeError('The object is not iterable');\n  }\n  const iterator = reflectCall(method, obj, []);\n  if (!typeIsObject(iterator)) {\n    throw new TypeError('The iterator method must return an object');\n  }\n  const nextMethod = iterator.next;\n  return { iterator, nextMethod, done: false } as SyncOrAsyncIteratorRecord<T>;\n}\n\nexport { GetIterator };\n\nexport function IteratorNext<T>(iteratorRecord: AsyncIteratorRecord<T>): Promise<IteratorResult<T>> {\n  const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);\n  if (!typeIsObject(result)) {\n    throw new TypeError('The iterator.next() method must return an object');\n  }\n  return result;\n}\n\nexport function IteratorComplete<TReturn>(\n  iterResult: IteratorResult<unknown, TReturn>\n): iterResult is IteratorReturnResult<TReturn> {\n  assert(typeIsObject(iterResult));\n  return Boolean(iterResult.done);\n}\n\nexport function IteratorValue<T>(iterResult: IteratorYieldResult<T>): T {\n  assert(typeIsObject(iterResult));\n  return iterResult.value;\n}\n","import NumberIsNaN from '../../stub/number-isnan';\nimport { ArrayBufferSlice } from './ecmascript';\nimport type { NonShared } from '../helpers/array-buffer-view';\n\nexport function IsNonNegativeNumber(v: number): boolean {\n  if (typeof v !== 'number') {\n    return false;\n  }\n\n  if (NumberIsNaN(v)) {\n    return false;\n  }\n\n  if (v < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function CloneAsUint8Array(O: NonShared<ArrayBufferView>): NonShared<Uint8Array> {\n  const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n  return new Uint8Array(buffer) as NonShared<Uint8Array>;\n}\n","import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport { IsNonNegativeNumber } from './miscellaneous';\n\nexport interface QueueContainer<T> {\n  _queue: SimpleQueue<T>;\n  _queueTotalSize: number;\n}\n\nexport interface QueuePair<T> {\n  value: T;\n  size: number;\n}\n\nexport function DequeueValue<T>(container: QueueContainer<QueuePair<T>>): T {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.shift()!;\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n\n  return pair.value;\n}\n\nexport function EnqueueValueWithSize<T>(container: QueueContainer<QueuePair<T>>, value: T, size: number) {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  if (!IsNonNegativeNumber(size) || size === Infinity) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  container._queue.push({ value, size });\n  container._queueTotalSize += size;\n}\n\nexport function PeekQueueValue<T>(container: QueueContainer<QueuePair<T>>): T {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.peek();\n  return pair.value;\n}\n\nexport function ResetQueue<T>(container: QueueContainer<T>) {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  container._queue = new SimpleQueue<T>();\n  container._queueTotalSize = 0;\n}\n","export type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array;\n\nexport type NonShared<T extends ArrayBufferView> = T & {\n  buffer: ArrayBuffer;\n}\n\nexport interface ArrayBufferViewConstructor<T extends ArrayBufferView = ArrayBufferView> {\n  new(buffer: ArrayBuffer, byteOffset: number, length?: number): T;\n\n  readonly prototype: T;\n}\n\nexport interface TypedArrayConstructor<T extends TypedArray = TypedArray> extends ArrayBufferViewConstructor<T> {\n  readonly BYTES_PER_ELEMENT: number;\n}\n\nexport type DataViewConstructor = ArrayBufferViewConstructor<DataView>;\n\nfunction isDataViewConstructor(ctor: Function): ctor is DataViewConstructor {\n  return ctor === DataView;\n}\n\nexport function isDataView(view: ArrayBufferView): view is DataView {\n  return isDataViewConstructor(view.constructor);\n}\n\nexport function arrayBufferViewElementSize<T extends ArrayBufferView>(ctor: ArrayBufferViewConstructor<T>): number {\n  if (isDataViewConstructor(ctor)) {\n    return 1;\n  }\n  return (ctor as unknown as TypedArrayConstructor).BYTES_PER_ELEMENT;\n}\n","import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport { ResetQueue } from '../abstract-ops/queue-with-sizes';\nimport {\n  IsReadableStreamDefaultReader,\n  ReadableStreamAddReadRequest,\n  ReadableStreamFulfillReadRequest,\n  ReadableStreamGetNumReadRequests,\n  ReadableStreamHasDefaultReader,\n  type ReadRequest\n} from './default-reader';\nimport {\n  ReadableStreamAddReadIntoRequest,\n  ReadableStreamFulfillReadIntoRequest,\n  ReadableStreamGetNumReadIntoRequests,\n  ReadableStreamHasBYOBReader,\n  type ReadIntoRequest\n} from './byob-reader';\nimport NumberIsInteger from '../../stub/number-isinteger';\nimport {\n  IsReadableStreamLocked,\n  type ReadableByteStream,\n  ReadableStreamClose,\n  ReadableStreamError\n} from '../readable-stream';\nimport type { ValidatedUnderlyingByteSource } from './underlying-source';\nimport { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\nimport {\n  ArrayBufferSlice,\n  CanTransferArrayBuffer,\n  CopyDataBlockBytes,\n  IsDetachedBuffer,\n  TransferArrayBuffer\n} from '../abstract-ops/ecmascript';\nimport { CancelSteps, PullSteps, ReleaseSteps } from '../abstract-ops/internal-methods';\nimport { promiseResolvedWith, uponPromise } from '../helpers/webidl';\nimport { assertRequiredArgument, convertUnsignedLongLongWithEnforceRange } from '../validators/basic';\nimport {\n  type ArrayBufferViewConstructor,\n  arrayBufferViewElementSize,\n  type NonShared,\n  type TypedArrayConstructor\n} from '../helpers/array-buffer-view';\n\n/**\n * A pull-into request in a {@link ReadableByteStreamController}.\n *\n * @public\n */\nexport class ReadableStreamBYOBRequest {\n  /** @internal */\n  _associatedReadableByteStreamController!: ReadableByteStreamController;\n  /** @internal */\n  _view!: NonShared<ArrayBufferView> | null;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n   */\n  get view(): ArrayBufferView | null {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('view');\n    }\n\n    return this._view;\n  }\n\n  /**\n   * Indicates to the associated readable byte stream that `bytesWritten` bytes were written into\n   * {@link ReadableStreamBYOBRequest.view | view}, causing the result be surfaced to the consumer.\n   *\n   * After this method is called, {@link ReadableStreamBYOBRequest.view | view} will be transferred and no longer\n   * modifiable.\n   */\n  respond(bytesWritten: number): void;\n  respond(bytesWritten: number | undefined): void {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('respond');\n    }\n    assertRequiredArgument(bytesWritten, 1, 'respond');\n    bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(this._view!.buffer)) {\n      throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);\n    }\n\n    assert(this._view!.byteLength > 0);\n    assert(this._view!.buffer.byteLength > 0);\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  }\n\n  /**\n   * Indicates to the associated readable byte stream that instead of writing into\n   * {@link ReadableStreamBYOBRequest.view | view}, the underlying byte source is providing a new `ArrayBufferView`,\n   * which will be given to the consumer of the readable byte stream.\n   *\n   * After this method is called, `view` will be transferred and no longer modifiable.\n   */\n  respondWithNewView(view: ArrayBufferView): void;\n  respondWithNewView(view: NonShared<ArrayBufferView>): void {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('respondWithNewView');\n    }\n    assertRequiredArgument(view, 1, 'respondWithNewView');\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(view.buffer)) {\n      throw new TypeError('The given view\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  }\n}\n\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, {\n  respond: { enumerable: true },\n  respondWithNewView: { enumerable: true },\n  view: { enumerable: true }\n});\nsetFunctionName(ReadableStreamBYOBRequest.prototype.respond, 'respond');\nsetFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, 'respondWithNewView');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamBYOBRequest',\n    configurable: true\n  });\n}\n\ninterface ByteQueueElement {\n  buffer: ArrayBuffer;\n  byteOffset: number;\n  byteLength: number;\n}\n\ntype PullIntoDescriptor<T extends NonShared<ArrayBufferView> = NonShared<ArrayBufferView>> =\n  DefaultPullIntoDescriptor\n  | BYOBPullIntoDescriptor<T>;\n\ninterface DefaultPullIntoDescriptor {\n  buffer: ArrayBuffer;\n  bufferByteLength: number;\n  byteOffset: number;\n  byteLength: number;\n  bytesFilled: number;\n  minimumFill: number;\n  elementSize: number;\n  viewConstructor: TypedArrayConstructor<Uint8Array>;\n  readerType: 'default' | 'none';\n}\n\ninterface BYOBPullIntoDescriptor<T extends NonShared<ArrayBufferView> = NonShared<ArrayBufferView>> {\n  buffer: ArrayBuffer;\n  bufferByteLength: number;\n  byteOffset: number;\n  byteLength: number;\n  bytesFilled: number;\n  minimumFill: number;\n  elementSize: number;\n  viewConstructor: ArrayBufferViewConstructor<T>;\n  readerType: 'byob' | 'none';\n}\n\n/**\n * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n *\n * @public\n */\nexport class ReadableByteStreamController {\n  /** @internal */\n  _controlledReadableByteStream!: ReadableByteStream;\n  /** @internal */\n  _queue!: SimpleQueue<ByteQueueElement>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _closeRequested!: boolean;\n  /** @internal */\n  _pullAgain!: boolean;\n  /** @internal */\n  _pulling !: boolean;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _pullAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm!: (reason: any) => Promise<void>;\n  /** @internal */\n  _autoAllocateChunkSize: number | undefined;\n  /** @internal */\n  _byobRequest: ReadableStreamBYOBRequest | null;\n  /** @internal */\n  _pendingPullIntos!: SimpleQueue<PullIntoDescriptor>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the current BYOB pull request, or `null` if there isn't one.\n   */\n  get byobRequest(): ReadableStreamBYOBRequest | null {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n\n    return ReadableByteStreamControllerGetBYOBRequest(this);\n  }\n\n  /**\n   * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n   * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n   */\n  get desiredSize(): number | null {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n\n  /**\n   * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   * the stream, but once those are read, the stream will become closed.\n   */\n  close(): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableByteStreamControllerClose(this);\n  }\n\n  /**\n   * Enqueues the given chunk chunk in the controlled readable stream.\n   * The chunk has to be an `ArrayBufferView` instance, or else a `TypeError` will be thrown.\n   */\n  enqueue(chunk: ArrayBufferView): void;\n  enqueue(chunk: NonShared<ArrayBufferView>): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    assertRequiredArgument(chunk, 1, 'enqueue');\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('chunk must be an array buffer view');\n    }\n    if (chunk.byteLength === 0) {\n      throw new TypeError('chunk must have non-zero byteLength');\n    }\n    if (chunk.buffer.byteLength === 0) {\n      throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n    }\n\n    if (this._closeRequested) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   */\n  error(e: any = undefined): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  }\n\n  /** @internal */\n  [CancelSteps](reason: any): Promise<void> {\n    ReadableByteStreamControllerClearPendingPullIntos(this);\n\n    ResetQueue(this);\n\n    const result = this._cancelAlgorithm(reason);\n    ReadableByteStreamControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [PullSteps](readRequest: ReadRequest<NonShared<Uint8Array>>): void {\n    const stream = this._controlledReadableByteStream;\n    assert(ReadableStreamHasDefaultReader(stream));\n\n    if (this._queueTotalSize > 0) {\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\n\n      ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);\n      return;\n    }\n\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n      let buffer: ArrayBuffer;\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        readRequest._errorSteps(bufferE);\n        return;\n      }\n\n      const pullIntoDescriptor: DefaultPullIntoDescriptor = {\n        buffer,\n        bufferByteLength: autoAllocateChunkSize,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        minimumFill: 1,\n        elementSize: 1,\n        viewConstructor: Uint8Array,\n        readerType: 'default'\n      };\n\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n\n    ReadableStreamAddReadRequest(stream, readRequest);\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n  }\n\n  /** @internal */\n  [ReleaseSteps](): void {\n    if (this._pendingPullIntos.length > 0) {\n      const firstPullInto = this._pendingPullIntos.peek();\n      firstPullInto.readerType = 'none';\n\n      this._pendingPullIntos = new SimpleQueue();\n      this._pendingPullIntos.push(firstPullInto);\n    }\n  }\n}\n\nObject.defineProperties(ReadableByteStreamController.prototype, {\n  close: { enumerable: true },\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  byobRequest: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nsetFunctionName(ReadableByteStreamController.prototype.close, 'close');\nsetFunctionName(ReadableByteStreamController.prototype.enqueue, 'enqueue');\nsetFunctionName(ReadableByteStreamController.prototype.error, 'error');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {\n    value: 'ReadableByteStreamController',\n    configurable: true\n  });\n}\n\n// Abstract operations for the ReadableByteStreamController.\n\nexport function IsReadableByteStreamController(x: any): x is ReadableByteStreamController {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n    return false;\n  }\n\n  return x instanceof ReadableByteStreamController;\n}\n\nfunction IsReadableStreamBYOBRequest(x: any): x is ReadableStreamBYOBRequest {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamBYOBRequest;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller: ReadableByteStreamController): void {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (!shouldPull) {\n    return;\n  }\n\n  if (controller._pulling) {\n    controller._pullAgain = true;\n    return;\n  }\n\n  assert(!controller._pullAgain);\n\n  controller._pulling = true;\n\n  // TODO: Test controller argument\n  const pullPromise = controller._pullAlgorithm();\n  uponPromise(\n    pullPromise,\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n\n      return null;\n    },\n    e => {\n      ReadableByteStreamControllerError(controller, e);\n      return null;\n    }\n  );\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller: ReadableByteStreamController) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = new SimpleQueue();\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor<T extends NonShared<ArrayBufferView>>(\n  stream: ReadableByteStream,\n  pullIntoDescriptor: PullIntoDescriptor<T>\n) {\n  assert(stream._state !== 'errored');\n  assert(pullIntoDescriptor.readerType !== 'none');\n\n  let done = false;\n  if (stream._state === 'closed') {\n    assert(pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize === 0);\n    done = true;\n  }\n\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor<T>(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView as unknown as NonShared<Uint8Array>, done);\n  } else {\n    assert(pullIntoDescriptor.readerType === 'byob');\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor<T extends NonShared<ArrayBufferView>>(\n  pullIntoDescriptor: PullIntoDescriptor<T>\n): T {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\n  assert(bytesFilled % elementSize === 0);\n\n  return new pullIntoDescriptor.viewConstructor(\n    pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize) as T;\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller: ReadableByteStreamController,\n                                                         buffer: ArrayBuffer,\n                                                         byteOffset: number,\n                                                         byteLength: number) {\n  controller._queue.push({ buffer, byteOffset, byteLength });\n  controller._queueTotalSize += byteLength;\n}\n\nfunction ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller: ReadableByteStreamController,\n                                                               buffer: ArrayBuffer,\n                                                               byteOffset: number,\n                                                               byteLength: number) {\n  let clonedChunk;\n  try {\n    clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);\n  } catch (cloneE) {\n    ReadableByteStreamControllerError(controller, cloneE);\n    throw cloneE;\n  }\n  ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);\n}\n\nfunction ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller: ReadableByteStreamController,\n                                                                    firstDescriptor: PullIntoDescriptor) {\n  assert(firstDescriptor.readerType === 'none');\n  if (firstDescriptor.bytesFilled > 0) {\n    ReadableByteStreamControllerEnqueueClonedChunkToQueue(\n      controller,\n      firstDescriptor.buffer,\n      firstDescriptor.byteOffset,\n      firstDescriptor.bytesFilled\n    );\n  }\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller: ReadableByteStreamController,\n                                                                     pullIntoDescriptor: PullIntoDescriptor) {\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n  const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n  const maxAlignedBytes = maxBytesFilled - remainderBytes;\n  // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  // of the queue, so the underlying source can keep filling it.\n  if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  const queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue.peek();\n\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._queueTotalSize -= bytesToCopy;\n\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (!ready) {\n    assert(controller._queueTotalSize === 0);\n    assert(pullIntoDescriptor.bytesFilled > 0);\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller: ReadableByteStreamController,\n                                                                size: number,\n                                                                pullIntoDescriptor: PullIntoDescriptor) {\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos.peek() === pullIntoDescriptor);\n  assert(controller._byobRequest === null);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller: ReadableByteStreamController) {\n  assert(controller._controlledReadableByteStream._state === 'readable');\n\n  if (controller._queueTotalSize === 0 && controller._closeRequested) {\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller: ReadableByteStreamController) {\n  if (controller._byobRequest === null) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined!;\n  controller._byobRequest._view = null!;\n  controller._byobRequest = null;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller: ReadableByteStreamController) {\n  assert(!controller._closeRequested);\n\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n\n    const pullIntoDescriptor = controller._pendingPullIntos.peek();\n    assert(pullIntoDescriptor.readerType !== 'none');\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\n        controller._controlledReadableByteStream,\n        pullIntoDescriptor\n      );\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller: ReadableByteStreamController) {\n  const reader = controller._controlledReadableByteStream._reader;\n  assert(IsReadableStreamDefaultReader(reader));\n  while (reader._readRequests.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n    const readRequest = reader._readRequests.shift();\n    ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);\n  }\n}\n\nexport function ReadableByteStreamControllerPullInto<T extends NonShared<ArrayBufferView>>(\n  controller: ReadableByteStreamController,\n  view: T,\n  min: number,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  const stream = controller._controlledReadableByteStream;\n\n  const ctor = view.constructor as ArrayBufferViewConstructor<T>;\n  const elementSize = arrayBufferViewElementSize(ctor);\n\n  const { byteOffset, byteLength } = view;\n\n  const minimumFill = min * elementSize;\n  assert(minimumFill >= elementSize && minimumFill <= byteLength);\n  assert(minimumFill % elementSize === 0);\n\n  let buffer: ArrayBuffer;\n  try {\n    buffer = TransferArrayBuffer(view.buffer);\n  } catch (e) {\n    readIntoRequest._errorSteps(e);\n    return;\n  }\n\n  const pullIntoDescriptor: BYOBPullIntoDescriptor<T> = {\n    buffer,\n    bufferByteLength: buffer.byteLength,\n    byteOffset,\n    byteLength,\n    bytesFilled: 0,\n    minimumFill,\n    elementSize,\n    viewConstructor: ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n    return;\n  }\n\n  if (stream._state === 'closed') {\n    const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n    readIntoRequest._closeSteps(emptyView);\n    return;\n  }\n\n  if (controller._queueTotalSize > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor<T>(pullIntoDescriptor);\n\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n\n      readIntoRequest._chunkSteps(filledView);\n      return;\n    }\n\n    if (controller._closeRequested) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      readIntoRequest._errorSteps(e);\n      return;\n    }\n  }\n\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  ReadableStreamAddReadIntoRequest<T>(stream, readIntoRequest);\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller: ReadableByteStreamController,\n                                                          firstDescriptor: PullIntoDescriptor) {\n  assert(firstDescriptor.bytesFilled % firstDescriptor.elementSize === 0);\n\n  if (firstDescriptor.readerType === 'none') {\n    ReadableByteStreamControllerShiftPendingPullInto(controller);\n  }\n\n  const stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream)) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller: ReadableByteStreamController,\n                                                            bytesWritten: number,\n                                                            pullIntoDescriptor: PullIntoDescriptor) {\n  assert(pullIntoDescriptor.bytesFilled + bytesWritten <= pullIntoDescriptor.byteLength);\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.readerType === 'none') {\n    ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    return;\n  }\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n    // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n    // of the queue, so the underlying source can keep filling it.\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    ReadableByteStreamControllerEnqueueClonedChunkToQueue(\n      controller,\n      pullIntoDescriptor.buffer,\n      end - remainderSize,\n      remainderSize\n    );\n  }\n\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller: ReadableByteStreamController, bytesWritten: number) {\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  assert(CanTransferArrayBuffer(firstDescriptor.buffer));\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n\n  const state = controller._controlledReadableByteStream._state;\n  if (state === 'closed') {\n    assert(bytesWritten === 0);\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    assert(state === 'readable');\n    assert(bytesWritten > 0);\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(\n  controller: ReadableByteStreamController\n): PullIntoDescriptor {\n  assert(controller._byobRequest === null);\n  const descriptor = controller._pendingPullIntos.shift()!;\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller: ReadableByteStreamController): boolean {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested) {\n    return false;\n  }\n\n  if (!controller._started) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize! > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableByteStreamControllerClearAlgorithms(controller: ReadableByteStreamController) {\n  controller._pullAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n}\n\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\nexport function ReadableByteStreamControllerClose(controller: ReadableByteStreamController) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (controller._closeRequested || stream._state !== 'readable') {\n    return;\n  }\n\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos.peek();\n    if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamClose(stream);\n}\n\nexport function ReadableByteStreamControllerEnqueue(\n  controller: ReadableByteStreamController,\n  chunk: NonShared<ArrayBufferView>\n) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (controller._closeRequested || stream._state !== 'readable') {\n    return;\n  }\n\n  const { buffer, byteOffset, byteLength } = chunk;\n  if (IsDetachedBuffer(buffer)) {\n    throw new TypeError('chunk\\'s buffer is detached and so cannot be enqueued');\n  }\n  const transferredBuffer = TransferArrayBuffer(buffer);\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos.peek();\n    if (IsDetachedBuffer(firstPendingPullInto.buffer)) {\n      throw new TypeError(\n        'The BYOB request\\'s buffer has been detached and so cannot be filled with an enqueued chunk'\n      );\n    }\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n    if (firstPendingPullInto.readerType === 'none') {\n      ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);\n    }\n  }\n\n  if (ReadableStreamHasDefaultReader(stream)) {\n    ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      assert(controller._pendingPullIntos.length === 0);\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(controller._queue.length === 0);\n      if (controller._pendingPullIntos.length > 0) {\n        assert(controller._pendingPullIntos.peek().readerType === 'default');\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\n      }\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView as NonShared<Uint8Array>, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream)) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(!IsReadableStreamLocked(stream));\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nexport function ReadableByteStreamControllerError(controller: ReadableByteStreamController, e: any) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  ResetQueue(controller);\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nexport function ReadableByteStreamControllerFillReadRequestFromQueue(\n  controller: ReadableByteStreamController,\n  readRequest: ReadRequest<NonShared<Uint8Array>>\n) {\n  assert(controller._queueTotalSize > 0);\n\n  const entry = controller._queue.shift();\n  controller._queueTotalSize -= entry.byteLength;\n\n  ReadableByteStreamControllerHandleQueueDrain(controller);\n\n  const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n  readRequest._chunkSteps(view as NonShared<Uint8Array>);\n}\n\nexport function ReadableByteStreamControllerGetBYOBRequest(\n  controller: ReadableByteStreamController\n): ReadableStreamBYOBRequest | null {\n  if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const view = new Uint8Array(firstDescriptor.buffer,\n                                firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n                                firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n\n    const byobRequest: ReadableStreamBYOBRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n    SetUpReadableStreamBYOBRequest(byobRequest, controller, view as NonShared<Uint8Array>);\n    controller._byobRequest = byobRequest;\n  }\n  return controller._byobRequest;\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller: ReadableByteStreamController): number | null {\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nexport function ReadableByteStreamControllerRespond(controller: ReadableByteStreamController, bytesWritten: number) {\n  assert(controller._pendingPullIntos.length > 0);\n\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n  } else {\n    assert(state === 'readable');\n    if (bytesWritten === 0) {\n      throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n    }\n    if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n      throw new RangeError('bytesWritten out of range');\n    }\n  }\n\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nexport function ReadableByteStreamControllerRespondWithNewView(controller: ReadableByteStreamController,\n                                                               view: NonShared<ArrayBufferView>) {\n  assert(controller._pendingPullIntos.length > 0);\n  assert(!IsDetachedBuffer(view.buffer));\n\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'closed') {\n    if (view.byteLength !== 0) {\n      throw new TypeError('The view\\'s length must be 0 when calling respondWithNewView() on a closed stream');\n    }\n  } else {\n    assert(state === 'readable');\n    if (view.byteLength === 0) {\n      throw new TypeError(\n        'The view\\'s length must be greater than 0 when calling respondWithNewView() on a readable stream'\n      );\n    }\n  }\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n  if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n    throw new RangeError('The region specified by view is larger than byobRequest');\n  }\n\n  const viewByteLength = view.byteLength;\n  firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n  ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n}\n\nexport function SetUpReadableByteStreamController(stream: ReadableByteStream,\n                                                  controller: ReadableByteStreamController,\n                                                  startAlgorithm: () => void | PromiseLike<void>,\n                                                  pullAlgorithm: () => Promise<void>,\n                                                  cancelAlgorithm: (reason: any) => Promise<void>,\n                                                  highWaterMark: number,\n                                                  autoAllocateChunkSize: number | undefined) {\n  assert(stream._readableStreamController === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(NumberIsInteger(autoAllocateChunkSize));\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  controller._controlledReadableByteStream = stream;\n\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._byobRequest = null;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._closeRequested = false;\n  controller._started = false;\n\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n\n  controller._pendingPullIntos = new SimpleQueue();\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  uponPromise(\n    promiseResolvedWith(startResult),\n    () => {\n      controller._started = true;\n\n      assert(!controller._pulling);\n      assert(!controller._pullAgain);\n\n      ReadableByteStreamControllerCallPullIfNeeded(controller);\n      return null;\n    },\n    r => {\n      ReadableByteStreamControllerError(controller, r);\n      return null;\n    }\n  );\n}\n\nexport function SetUpReadableByteStreamControllerFromUnderlyingSource(\n  stream: ReadableByteStream,\n  underlyingByteSource: ValidatedUnderlyingByteSource,\n  highWaterMark: number\n) {\n  const controller: ReadableByteStreamController = Object.create(ReadableByteStreamController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void>;\n  let pullAlgorithm: () => Promise<void>;\n  let cancelAlgorithm: (reason: any) => Promise<void>;\n\n  if (underlyingByteSource.start !== undefined) {\n    startAlgorithm = () => underlyingByteSource.start!(controller);\n  } else {\n    startAlgorithm = () => undefined;\n  }\n  if (underlyingByteSource.pull !== undefined) {\n    pullAlgorithm = () => underlyingByteSource.pull!(controller);\n  } else {\n    pullAlgorithm = () => promiseResolvedWith(undefined);\n  }\n  if (underlyingByteSource.cancel !== undefined) {\n    cancelAlgorithm = reason => underlyingByteSource.cancel!(reason);\n  } else {\n    cancelAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize === 0) {\n    throw new TypeError('autoAllocateChunkSize must be greater than 0');\n  }\n\n  SetUpReadableByteStreamController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize\n  );\n}\n\nfunction SetUpReadableStreamBYOBRequest(request: ReadableStreamBYOBRequest,\n                                        controller: ReadableByteStreamController,\n                                        view: NonShared<ArrayBufferView>) {\n  assert(IsReadableByteStreamController(controller));\n  assert(typeof view === 'object');\n  assert(ArrayBuffer.isView(view));\n  assert(!IsDetachedBuffer(view.buffer));\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n}\n\n// Helper functions for the ReadableStreamBYOBRequest.\n\nfunction byobRequestBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n\n// Helper functions for the ReadableByteStreamController.\n\nfunction byteStreamControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n","import { assertDictionary, convertUnsignedLongLongWithEnforceRange } from './basic';\nimport type {\n  ReadableStreamBYOBReaderReadOptions,\n  ReadableStreamGetReaderOptions,\n  ValidatedReadableStreamBYOBReaderReadOptions\n} from '../readable-stream/reader-options';\n\nexport function convertReaderOptions(options: ReadableStreamGetReaderOptions | null | undefined,\n                                     context: string): ReadableStreamGetReaderOptions {\n  assertDictionary(options, context);\n  const mode = options?.mode;\n  return {\n    mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n  };\n}\n\nfunction convertReadableStreamReaderMode(mode: string, context: string): 'byob' {\n  mode = `${mode}`;\n  if (mode !== 'byob') {\n    throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n  }\n  return mode;\n}\n\nexport function convertByobReadOptions(\n  options: ReadableStreamBYOBReaderReadOptions | null | undefined,\n  context: string\n): ValidatedReadableStreamBYOBReaderReadOptions {\n  assertDictionary(options, context);\n  const min = options?.min ?? 1;\n  return {\n    min: convertUnsignedLongLongWithEnforceRange(\n      min,\n      `${context} has member 'min' that`\n    )\n  };\n}\n","import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericInitialize,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport { IsReadableStreamLocked, type ReadableByteStream, type ReadableStream } from '../readable-stream';\nimport {\n  IsReadableByteStreamController,\n  ReadableByteStreamController,\n  ReadableByteStreamControllerPullInto\n} from './byte-stream-controller';\nimport { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\nimport { newPromise, promiseRejectedWith } from '../helpers/webidl';\nimport { assertRequiredArgument } from '../validators/basic';\nimport { assertReadableStream } from '../validators/readable-stream';\nimport { IsDetachedBuffer } from '../abstract-ops/ecmascript';\nimport type {\n  ReadableStreamBYOBReaderReadOptions,\n  ValidatedReadableStreamBYOBReaderReadOptions\n} from './reader-options';\nimport { convertByobReadOptions } from '../validators/reader-options';\nimport { isDataView, type NonShared, type TypedArray } from '../helpers/array-buffer-view';\n\n/**\n * A result returned by {@link ReadableStreamBYOBReader.read}.\n *\n * @public\n */\nexport type ReadableStreamBYOBReadResult<T extends ArrayBufferView> = {\n  done: false;\n  value: T;\n} | {\n  done: true;\n  value: T | undefined;\n};\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamBYOBReader(stream: ReadableByteStream): ReadableStreamBYOBReader {\n  return new ReadableStreamBYOBReader(stream as ReadableStream<Uint8Array>);\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamAddReadIntoRequest<T extends NonShared<ArrayBufferView>>(\n  stream: ReadableByteStream,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  assert(IsReadableStreamBYOBReader(stream._reader));\n  assert(stream._state === 'readable' || stream._state === 'closed');\n\n  (stream._reader! as ReadableStreamBYOBReader)._readIntoRequests.push(readIntoRequest);\n}\n\nexport function ReadableStreamFulfillReadIntoRequest(stream: ReadableByteStream,\n                                                     chunk: ArrayBufferView,\n                                                     done: boolean) {\n  const reader = stream._reader as ReadableStreamBYOBReader;\n\n  assert(reader._readIntoRequests.length > 0);\n\n  const readIntoRequest = reader._readIntoRequests.shift()!;\n  if (done) {\n    readIntoRequest._closeSteps(chunk);\n  } else {\n    readIntoRequest._chunkSteps(chunk);\n  }\n}\n\nexport function ReadableStreamGetNumReadIntoRequests(stream: ReadableByteStream): number {\n  return (stream._reader as ReadableStreamBYOBReader)._readIntoRequests.length;\n}\n\nexport function ReadableStreamHasBYOBReader(stream: ReadableByteStream): boolean {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (!IsReadableStreamBYOBReader(reader)) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nexport interface ReadIntoRequest<T extends NonShared<ArrayBufferView>> {\n  _chunkSteps(chunk: T): void;\n\n  _closeSteps(chunk: T | undefined): void;\n\n  _errorSteps(e: any): void;\n}\n\n/**\n * A BYOB reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nexport class ReadableStreamBYOBReader {\n  /** @internal */\n  _ownerReadableStream!: ReadableByteStream;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readIntoRequests: SimpleQueue<ReadIntoRequest<any>>;\n\n  constructor(stream: ReadableStream<Uint8Array>) {\n    assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n    assertReadableStream(stream, 'First parameter');\n\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    if (!IsReadableByteStreamController(stream._readableStreamController)) {\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n        'source');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readIntoRequests = new SimpleQueue();\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   * the reader's lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  /**\n   * Attempts to reads bytes into view, and returns a promise resolved with the result.\n   *\n   * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   */\n  read<T extends ArrayBufferView>(\n    view: T,\n    options?: ReadableStreamBYOBReaderReadOptions\n  ): Promise<ReadableStreamBYOBReadResult<T>>;\n  read<T extends NonShared<ArrayBufferView>>(\n    view: T,\n    rawOptions: ReadableStreamBYOBReaderReadOptions | null | undefined = {}\n  ): Promise<ReadableStreamBYOBReadResult<T>> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('read'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n    }\n    if (view.byteLength === 0) {\n      return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n    }\n    if (view.buffer.byteLength === 0) {\n      return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n    }\n    if (IsDetachedBuffer(view.buffer)) {\n      return promiseRejectedWith(new TypeError('view\\'s buffer has been detached'));\n    }\n\n    let options: ValidatedReadableStreamBYOBReaderReadOptions;\n    try {\n      options = convertByobReadOptions(rawOptions, 'options');\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    const min = options.min;\n    if (min === 0) {\n      return promiseRejectedWith(new TypeError('options.min must be greater than 0'));\n    }\n    if (!isDataView(view)) {\n      if (min > (view as unknown as TypedArray).length) {\n        return promiseRejectedWith(new RangeError('options.min must be less than or equal to view\\'s length'));\n      }\n    } else if (min > view.byteLength) {\n      return promiseRejectedWith(new RangeError('options.min must be less than or equal to view\\'s byteLength'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('read from'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamBYOBReadResult<T>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamBYOBReadResult<T>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readIntoRequest: ReadIntoRequest<T> = {\n      _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n      _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n      _errorSteps: e => rejectPromise(e)\n    };\n    ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);\n    return promise;\n  }\n\n  /**\n   * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n   * from now on; otherwise, the reader will appear closed.\n   *\n   * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n   * do so will throw a `TypeError` and leave the reader locked to the stream.\n   */\n  releaseLock(): void {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    ReadableStreamBYOBReaderRelease(this);\n  }\n}\n\nObject.defineProperties(ReadableStreamBYOBReader.prototype, {\n  cancel: { enumerable: true },\n  read: { enumerable: true },\n  releaseLock: { enumerable: true },\n  closed: { enumerable: true }\n});\nsetFunctionName(ReadableStreamBYOBReader.prototype.cancel, 'cancel');\nsetFunctionName(ReadableStreamBYOBReader.prototype.read, 'read');\nsetFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, 'releaseLock');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamBYOBReader',\n    configurable: true\n  });\n}\n\n// Abstract operations for the readers.\n\nexport function IsReadableStreamBYOBReader(x: any): x is ReadableStreamBYOBReader {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamBYOBReader;\n}\n\nexport function ReadableStreamBYOBReaderRead<T extends NonShared<ArrayBufferView>>(\n  reader: ReadableStreamBYOBReader,\n  view: T,\n  min: number,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    readIntoRequest._errorSteps(stream._storedError);\n  } else {\n    ReadableByteStreamControllerPullInto(\n      stream._readableStreamController as ReadableByteStreamController,\n      view,\n      min,\n      readIntoRequest\n    );\n  }\n}\n\nexport function ReadableStreamBYOBReaderRelease(reader: ReadableStreamBYOBReader) {\n  ReadableStreamReaderGenericRelease(reader);\n  const e = new TypeError('Reader was released');\n  ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n}\n\nexport function ReadableStreamBYOBReaderErrorReadIntoRequests(reader: ReadableStreamBYOBReader, e: any) {\n  const readIntoRequests = reader._readIntoRequests;\n  reader._readIntoRequests = new SimpleQueue();\n  readIntoRequests.forEach(readIntoRequest => {\n    readIntoRequest._errorSteps(e);\n  });\n}\n\n// Helper functions for the ReadableStreamBYOBReader.\n\nfunction byobReaderBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n","import type { QueuingStrategy, QueuingStrategySizeCallback } from '../queuing-strategy';\nimport NumberIsNaN from '../../stub/number-isnan';\n\nexport function ExtractHighWaterMark(strategy: QueuingStrategy, defaultHWM: number): number {\n  const { highWaterMark } = strategy;\n\n  if (highWaterMark === undefined) {\n    return defaultHWM;\n  }\n\n  if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n    throw new RangeError('Invalid highWaterMark');\n  }\n\n  return highWaterMark;\n}\n\nexport function ExtractSizeAlgorithm<T>(strategy: QueuingStrategy<T>): QueuingStrategySizeCallback<T> {\n  const { size } = strategy;\n\n  if (!size) {\n    return () => 1;\n  }\n\n  return size;\n}\n","import type { QueuingStrategy, QueuingStrategySizeCallback } from '../queuing-strategy';\nimport { assertDictionary, assertFunction, convertUnrestrictedDouble } from './basic';\n\nexport function convertQueuingStrategy<T>(init: QueuingStrategy<T> | null | undefined,\n                                          context: string): QueuingStrategy<T> {\n  assertDictionary(init, context);\n  const highWaterMark = init?.highWaterMark;\n  const size = init?.size;\n  return {\n    highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n    size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n  };\n}\n\nfunction convertQueuingStrategySize<T>(fn: QueuingStrategySizeCallback<T>,\n                                       context: string): QueuingStrategySizeCallback<T> {\n  assertFunction(fn, context);\n  return chunk => convertUnrestrictedDouble(fn(chunk));\n}\n","import { assertDictionary, assertFunction } from './basic';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\nimport type {\n  UnderlyingSink,\n  UnderlyingSinkAbortCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  ValidatedUnderlyingSink\n} from '../writable-stream/underlying-sink';\nimport { WritableStreamDefaultController } from '../writable-stream';\n\nexport function convertUnderlyingSink<W>(original: UnderlyingSink<W> | null,\n                                         context: string): ValidatedUnderlyingSink<W> {\n  assertDictionary(original, context);\n  const abort = original?.abort;\n  const close = original?.close;\n  const start = original?.start;\n  const type = original?.type;\n  const write = original?.write;\n  return {\n    abort: abort === undefined ?\n      undefined :\n      convertUnderlyingSinkAbortCallback(abort, original!, `${context} has member 'abort' that`),\n    close: close === undefined ?\n      undefined :\n      convertUnderlyingSinkCloseCallback(close, original!, `${context} has member 'close' that`),\n    start: start === undefined ?\n      undefined :\n      convertUnderlyingSinkStartCallback(start, original!, `${context} has member 'start' that`),\n    write: write === undefined ?\n      undefined :\n      convertUnderlyingSinkWriteCallback(write, original!, `${context} has member 'write' that`),\n    type\n  };\n}\n\nfunction convertUnderlyingSinkAbortCallback(\n  fn: UnderlyingSinkAbortCallback,\n  original: UnderlyingSink,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n\nfunction convertUnderlyingSinkCloseCallback(\n  fn: UnderlyingSinkCloseCallback,\n  original: UnderlyingSink,\n  context: string\n): () => Promise<void> {\n  assertFunction(fn, context);\n  return () => promiseCall(fn, original, []);\n}\n\nfunction convertUnderlyingSinkStartCallback(\n  fn: UnderlyingSinkStartCallback,\n  original: UnderlyingSink,\n  context: string\n): UnderlyingSinkStartCallback {\n  assertFunction(fn, context);\n  return (controller: WritableStreamDefaultController) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertUnderlyingSinkWriteCallback<W>(\n  fn: UnderlyingSinkWriteCallback<W>,\n  original: UnderlyingSink<W>,\n  context: string\n): (chunk: W, controller: WritableStreamDefaultController) => Promise<void> {\n  assertFunction(fn, context);\n  return (chunk: W, controller: WritableStreamDefaultController) => promiseCall(fn, original, [chunk, controller]);\n}\n","import { IsWritableStream, WritableStream } from '../writable-stream';\n\nexport function assertWritableStream(x: unknown, context: string): asserts x is WritableStream {\n  if (!IsWritableStream(x)) {\n    throw new TypeError(`${context} is not a WritableStream.`);\n  }\n}\n","/**\n * A signal object that allows you to communicate with a request and abort it if required\n * via its associated `AbortController` object.\n *\n * @remarks\n *   This interface is compatible with the `AbortSignal` interface defined in TypeScript's DOM types.\n *   It is redefined here, so it can be polyfilled without a DOM, for example with\n *   {@link https://www.npmjs.com/package/abortcontroller-polyfill | abortcontroller-polyfill} in a Node environment.\n *\n * @public\n */\nexport interface AbortSignal {\n  /**\n   * Whether the request is aborted.\n   */\n  readonly aborted: boolean;\n\n  /**\n   * If aborted, returns the reason for aborting.\n   */\n  readonly reason?: any;\n\n  /**\n   * Add an event listener to be triggered when this signal becomes aborted.\n   */\n  addEventListener(type: 'abort', listener: () => void): void;\n\n  /**\n   * Remove an event listener that was previously added with {@link AbortSignal.addEventListener}.\n   */\n  removeEventListener(type: 'abort', listener: () => void): void;\n}\n\nexport function isAbortSignal(value: unknown): value is AbortSignal {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n  try {\n    return typeof (value as AbortSignal).aborted === 'boolean';\n  } catch {\n    // AbortSignal.prototype.aborted throws if its brand check fails\n    return false;\n  }\n}\n\n/**\n * A controller object that allows you to abort an `AbortSignal` when desired.\n *\n * @remarks\n *   This interface is compatible with the `AbortController` interface defined in TypeScript's DOM types.\n *   It is redefined here, so it can be polyfilled without a DOM, for example with\n *   {@link https://www.npmjs.com/package/abortcontroller-polyfill | abortcontroller-polyfill} in a Node environment.\n *\n * @internal\n */\nexport interface AbortController {\n  readonly signal: AbortSignal;\n\n  abort(reason?: any): void;\n}\n\ninterface AbortControllerConstructor {\n  new(): AbortController;\n}\n\nconst supportsAbortController = typeof (AbortController as any) === 'function';\n\n/**\n * Construct a new AbortController, if supported by the platform.\n *\n * @internal\n */\nexport function createAbortController(): AbortController | undefined {\n  if (supportsAbortController) {\n    return new (AbortController as AbortControllerConstructor)();\n  }\n  return undefined;\n}\n","import assert from '../stub/assert';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  uponPromise\n} from './helpers/webidl';\nimport {\n  DequeueValue,\n  EnqueueValueWithSize,\n  PeekQueueValue,\n  type QueuePair,\n  ResetQueue\n} from './abstract-ops/queue-with-sizes';\nimport type { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { SimpleQueue } from './simple-queue';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { AbortSteps, ErrorSteps } from './abstract-ops/internal-methods';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport type {\n  UnderlyingSink,\n  UnderlyingSinkAbortCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  ValidatedUnderlyingSink\n} from './writable-stream/underlying-sink';\nimport { assertObject, assertRequiredArgument } from './validators/basic';\nimport { convertUnderlyingSink } from './validators/underlying-sink';\nimport { assertWritableStream } from './validators/writable-stream';\nimport { type AbortController, type AbortSignal, createAbortController } from './abort-signal';\n\ntype WritableStreamState = 'writable' | 'closed' | 'erroring' | 'errored';\n\ninterface WriteOrCloseRequest {\n  _resolve: (value?: undefined) => void;\n  _reject: (reason: any) => void;\n}\n\ntype WriteRequest = WriteOrCloseRequest;\ntype CloseRequest = WriteOrCloseRequest;\n\ninterface PendingAbortRequest {\n  _promise: Promise<undefined>;\n  _resolve: (value?: undefined) => void;\n  _reject: (reason: any) => void;\n  _reason: any;\n  _wasAlreadyErroring: boolean;\n}\n\n/**\n * A writable stream represents a destination for data, into which you can write.\n *\n * @public\n */\nclass WritableStream<W = any> {\n  /** @internal */\n  _state!: WritableStreamState;\n  /** @internal */\n  _storedError: any;\n  /** @internal */\n  _writer: WritableStreamDefaultWriter<W> | undefined;\n  /** @internal */\n  _writableStreamController!: WritableStreamDefaultController<W>;\n  /** @internal */\n  _writeRequests!: SimpleQueue<WriteRequest>;\n  /** @internal */\n  _inFlightWriteRequest: WriteRequest | undefined;\n  /** @internal */\n  _closeRequest: CloseRequest | undefined;\n  /** @internal */\n  _inFlightCloseRequest: CloseRequest | undefined;\n  /** @internal */\n  _pendingAbortRequest: PendingAbortRequest | undefined;\n  /** @internal */\n  _backpressure!: boolean;\n\n  constructor(underlyingSink?: UnderlyingSink<W>, strategy?: QueuingStrategy<W>);\n  constructor(rawUnderlyingSink: UnderlyingSink<W> | null | undefined = {},\n              rawStrategy: QueuingStrategy<W> | null | undefined = {}) {\n    if (rawUnderlyingSink === undefined) {\n      rawUnderlyingSink = null;\n    } else {\n      assertObject(rawUnderlyingSink, 'First parameter');\n    }\n\n    const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n    const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n\n    InitializeWritableStream(this);\n\n    const type = underlyingSink.type;\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n    const highWaterMark = ExtractHighWaterMark(strategy, 1);\n\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n\n  /**\n   * Returns whether or not the writable stream is locked to a writer.\n   */\n  get locked(): boolean {\n    if (!IsWritableStream(this)) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsWritableStreamLocked(this);\n  }\n\n  /**\n   * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n   * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n   * mechanism of the underlying sink.\n   *\n   * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n   * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n   * the stream) if the stream is currently locked.\n   */\n  abort(reason: any = undefined): Promise<void> {\n    if (!IsWritableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  }\n\n  /**\n   * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n   * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n   *\n   * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n   * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n   * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n   */\n  close() {\n    if (!IsWritableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('close'));\n    }\n\n    if (IsWritableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(this)) {\n      return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n    }\n\n    return WritableStreamClose(this);\n  }\n\n  /**\n   * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n   * is locked, no other writer can be acquired until this one is released.\n   *\n   * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n   * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n   * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n   */\n  getWriter(): WritableStreamDefaultWriter<W> {\n    if (!IsWritableStream(this)) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  }\n}\n\nObject.defineProperties(WritableStream.prototype, {\n  abort: { enumerable: true },\n  close: { enumerable: true },\n  getWriter: { enumerable: true },\n  locked: { enumerable: true }\n});\nsetFunctionName(WritableStream.prototype.abort, 'abort');\nsetFunctionName(WritableStream.prototype.close, 'close');\nsetFunctionName(WritableStream.prototype.getWriter, 'getWriter');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {\n    value: 'WritableStream',\n    configurable: true\n  });\n}\n\nexport {\n  AcquireWritableStreamDefaultWriter,\n  CreateWritableStream,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamDefaultControllerErrorIfNeeded,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite,\n  WritableStreamCloseQueuedOrInFlight\n};\n\nexport type {\n  UnderlyingSink,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkAbortCallback\n};\n\n// Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter<W>(stream: WritableStream<W>): WritableStreamDefaultWriter<W> {\n  return new WritableStreamDefaultWriter(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream<W>(startAlgorithm: () => void | PromiseLike<void>,\n                                 writeAlgorithm: (chunk: W) => Promise<void>,\n                                 closeAlgorithm: () => Promise<void>,\n                                 abortAlgorithm: (reason: any) => Promise<void>,\n                                 highWaterMark = 1,\n                                 sizeAlgorithm: QueuingStrategySizeCallback<W> = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark));\n\n  const stream: WritableStream<W> = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n\n  const controller: WritableStreamDefaultController<W> = Object.create(WritableStreamDefaultController.prototype);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n}\n\nfunction InitializeWritableStream<W>(stream: WritableStream<W>) {\n  stream._state = 'writable';\n\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n  stream._storedError = undefined;\n\n  stream._writer = undefined;\n\n  // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n  stream._writableStreamController = undefined!;\n\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n  stream._writeRequests = new SimpleQueue();\n\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  stream._inFlightWriteRequest = undefined;\n\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n  stream._closeRequest = undefined;\n\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  stream._inFlightCloseRequest = undefined;\n\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  stream._pendingAbortRequest = undefined;\n\n  // The backpressure signal set by the controller.\n  stream._backpressure = false;\n}\n\nfunction IsWritableStream(x: unknown): x is WritableStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return x instanceof WritableStream;\n}\n\nfunction IsWritableStreamLocked(stream: WritableStream): boolean {\n  assert(IsWritableStream(stream));\n\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream: WritableStream, reason: any): Promise<undefined> {\n  if (stream._state === 'closed' || stream._state === 'errored') {\n    return promiseResolvedWith(undefined);\n  }\n  stream._writableStreamController._abortReason = reason;\n  stream._writableStreamController._abortController?.abort(reason);\n\n  // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n  // but it doesn't know that signaling abort runs author code that might have changed the state.\n  // Widen the type again by casting to WritableStreamState.\n  const state = stream._state as WritableStreamState;\n\n  if (state === 'closed' || state === 'errored') {\n    return promiseResolvedWith(undefined);\n  }\n  if (stream._pendingAbortRequest !== undefined) {\n    return stream._pendingAbortRequest._promise;\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    // reason will not be used, so don't keep a reference to it.\n    reason = undefined;\n  }\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    stream._pendingAbortRequest = {\n      _promise: undefined!,\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring\n    };\n  });\n  stream._pendingAbortRequest!._promise = promise;\n\n  if (!wasAlreadyErroring) {\n    WritableStreamStartErroring(stream, reason);\n  }\n\n  return promise;\n}\n\nfunction WritableStreamClose(stream: WritableStream<any>): Promise<undefined> {\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return promiseRejectedWith(new TypeError(\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n  assert(!WritableStreamCloseQueuedOrInFlight(stream));\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    const closeRequest: CloseRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._closeRequest = closeRequest;\n  });\n\n  const writer = stream._writer;\n  if (writer !== undefined && stream._backpressure && state === 'writable') {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n\n  return promise;\n}\n\n// WritableStream API exposed for controllers.\n\nfunction WritableStreamAddWriteRequest(stream: WritableStream): Promise<undefined> {\n  assert(IsWritableStreamLocked(stream));\n  assert(stream._state === 'writable');\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    const writeRequest: WriteRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n\n  return promise;\n}\n\nfunction WritableStreamDealWithRejection(stream: WritableStream, error: any) {\n  const state = stream._state;\n\n  if (state === 'writable') {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  WritableStreamFinishErroring(stream);\n}\n\nfunction WritableStreamStartErroring(stream: WritableStream, reason: any) {\n  assert(stream._storedError === undefined);\n  assert(stream._state === 'writable');\n\n  const controller = stream._writableStreamController;\n  assert(controller !== undefined);\n\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n\n  if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n    WritableStreamFinishErroring(stream);\n  }\n}\n\nfunction WritableStreamFinishErroring(stream: WritableStream) {\n  assert(stream._state === 'erroring');\n  assert(!WritableStreamHasOperationMarkedInFlight(stream));\n  stream._state = 'errored';\n  stream._writableStreamController[ErrorSteps]();\n\n  const storedError = stream._storedError;\n  stream._writeRequests.forEach(writeRequest => {\n    writeRequest._reject(storedError);\n  });\n  stream._writeRequests = new SimpleQueue();\n\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n\n  if (abortRequest._wasAlreadyErroring) {\n    abortRequest._reject(storedError);\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n  uponPromise(\n    promise,\n    () => {\n      abortRequest._resolve();\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      return null;\n    },\n    (reason: any) => {\n      abortRequest._reject(reason);\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      return null;\n    });\n}\n\nfunction WritableStreamFinishInFlightWrite(stream: WritableStream) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest!._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n}\n\nfunction WritableStreamFinishInFlightWriteWithError(stream: WritableStream, error: any) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest!._reject(error);\n  stream._inFlightWriteRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  WritableStreamDealWithRejection(stream, error);\n}\n\nfunction WritableStreamFinishInFlightClose(stream: WritableStream) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest!._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n\n  const state = stream._state;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  if (state === 'erroring') {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n\n  stream._state = 'closed';\n\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n\n  assert(stream._pendingAbortRequest === undefined);\n  assert(stream._storedError === undefined);\n}\n\nfunction WritableStreamFinishInFlightCloseWithError(stream: WritableStream, error: any) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest!._reject(error);\n  stream._inFlightCloseRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  // Never execute sink abort() after sink close().\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n    stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n}\n\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream: WritableStream): boolean {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamHasOperationMarkedInFlight(stream: WritableStream): boolean {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamMarkCloseRequestInFlight(stream: WritableStream) {\n  assert(stream._inFlightCloseRequest === undefined);\n  assert(stream._closeRequest !== undefined);\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\n\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream: WritableStream) {\n  assert(stream._inFlightWriteRequest === undefined);\n  assert(stream._writeRequests.length !== 0);\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\n\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream: WritableStream) {\n  assert(stream._state === 'errored');\n  if (stream._closeRequest !== undefined) {\n    assert(stream._inFlightCloseRequest === undefined);\n\n    stream._closeRequest._reject(stream._storedError);\n    stream._closeRequest = undefined;\n  }\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream: WritableStream, backpressure: boolean) {\n  assert(stream._state === 'writable');\n  assert(!WritableStreamCloseQueuedOrInFlight(stream));\n\n  const writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      assert(!backpressure);\n\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n\n  stream._backpressure = backpressure;\n}\n\n/**\n * A default writer vended by a {@link WritableStream}.\n *\n * @public\n */\nexport class WritableStreamDefaultWriter<W = any> {\n  /** @internal */\n  _ownerWritableStream: WritableStream<W>;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _closedPromiseState!: 'pending' | 'resolved' | 'rejected';\n  /** @internal */\n  _readyPromise!: Promise<undefined>;\n  /** @internal */\n  _readyPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _readyPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readyPromiseState!: 'pending' | 'fulfilled' | 'rejected';\n\n  constructor(stream: WritableStream<W>) {\n    assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n    assertWritableStream(stream, 'First parameter');\n\n    if (IsWritableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n\n    const state = stream._state;\n\n    if (state === 'writable') {\n      if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'erroring') {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      assert(state === 'errored');\n\n      const storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n    }\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   * the writer’s lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.\n   * A producer can use this information to determine the right amount of data to write.\n   *\n   * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n   * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n   * the writer’s lock is released.\n   */\n  get desiredSize(): number | null {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      throw defaultWriterBrandCheckException('desiredSize');\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      throw defaultWriterLockException('desiredSize');\n    }\n\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions\n   * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n   * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n   *\n   * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become\n   * rejected.\n   */\n  get ready(): Promise<undefined> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n    }\n\n    return this._readyPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n   */\n  abort(reason: any = undefined): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n   */\n  close(): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('close'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream)) {\n      return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  }\n\n  /**\n   * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n   * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n   * now on; otherwise, the writer will appear closed.\n   *\n   * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n   * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n   * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n   * other producers from writing in an interleaved manner.\n   */\n  releaseLock(): void {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    assert(stream._writer !== undefined);\n\n    WritableStreamDefaultWriterRelease(this);\n  }\n\n  /**\n   * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n   * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n   * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n   * errored before the writing process is initiated.\n   *\n   * Note that what \"success\" means is up to the underlying sink; it might indicate simply that the chunk has been\n   * accepted, and not necessarily that it is safely saved to its ultimate destination.\n   */\n  write(chunk: W): Promise<void>;\n  write(chunk: W = undefined!): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('write to'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  }\n}\n\nObject.defineProperties(WritableStreamDefaultWriter.prototype, {\n  abort: { enumerable: true },\n  close: { enumerable: true },\n  releaseLock: { enumerable: true },\n  write: { enumerable: true },\n  closed: { enumerable: true },\n  desiredSize: { enumerable: true },\n  ready: { enumerable: true }\n});\nsetFunctionName(WritableStreamDefaultWriter.prototype.abort, 'abort');\nsetFunctionName(WritableStreamDefaultWriter.prototype.close, 'close');\nsetFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, 'releaseLock');\nsetFunctionName(WritableStreamDefaultWriter.prototype.write, 'write');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {\n    value: 'WritableStreamDefaultWriter',\n    configurable: true\n  });\n}\n\n// Abstract operations for the WritableStreamDefaultWriter.\n\nfunction IsWritableStreamDefaultWriter<W = any>(x: any): x is WritableStreamDefaultWriter<W> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return x instanceof WritableStreamDefaultWriter;\n}\n\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultWriterAbort(writer: WritableStreamDefaultWriter, reason: any) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer: WritableStreamDefaultWriter): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamClose(stream);\n}\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer: WritableStreamDefaultWriter): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return promiseResolvedWith(undefined);\n  }\n\n  if (state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer: WritableStreamDefaultWriter, error: any) {\n  if (writer._closedPromiseState === 'pending') {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n}\n\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer: WritableStreamDefaultWriter, error: any) {\n  if (writer._readyPromiseState === 'pending') {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer: WritableStreamDefaultWriter): number | null {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n\n  if (state === 'errored' || state === 'erroring') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer: WritableStreamDefaultWriter) {\n  const stream = writer._ownerWritableStream;\n  assert(stream !== undefined);\n  assert(stream._writer === writer);\n\n  const releasedError = new TypeError(\n    `Writer was released and can no longer be used to monitor the stream's closedness`);\n\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined!;\n}\n\nfunction WritableStreamDefaultWriterWrite<W>(writer: WritableStreamDefaultWriter<W>, chunk: W): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const controller = stream._writableStreamController;\n\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n  if (stream !== writer._ownerWritableStream) {\n    return promiseRejectedWith(defaultWriterLockException('write to'));\n  }\n\n  const state = stream._state;\n  if (state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n  if (state === 'erroring') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  assert(state === 'writable');\n\n  const promise = WritableStreamAddWriteRequest(stream);\n\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n\n  return promise;\n}\n\nconst closeSentinel: unique symbol = {} as any;\n\ntype QueueRecord<W> = W | typeof closeSentinel;\n\n/**\n * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n *\n * @public\n */\nexport class WritableStreamDefaultController<W = any> {\n  /** @internal */\n  _controlledWritableStream!: WritableStream<W>;\n  /** @internal */\n  _queue!: SimpleQueue<QueuePair<QueueRecord<W>>>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _abortReason: any;\n  /** @internal */\n  _abortController: AbortController | undefined;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _strategySizeAlgorithm!: QueuingStrategySizeCallback<W>;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _writeAlgorithm!: (chunk: W) => Promise<void>;\n  /** @internal */\n  _closeAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _abortAlgorithm!: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n   *\n   * @deprecated\n   *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n   *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n   */\n  get abortReason(): any {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('abortReason');\n    }\n    return this._abortReason;\n  }\n\n  /**\n   * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n   */\n  get signal(): AbortSignal {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('signal');\n    }\n    if (this._abortController === undefined) {\n      // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n      // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n      // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n      throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');\n    }\n    return this._abortController.signal;\n  }\n\n  /**\n   * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n   *\n   * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n   * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n   * normal lifecycle of interactions with the underlying sink.\n   */\n  error(e: any = undefined): void {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n    const state = this._controlledWritableStream._state;\n    if (state !== 'writable') {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  }\n\n  /** @internal */\n  [AbortSteps](reason: any): Promise<void> {\n    const result = this._abortAlgorithm(reason);\n    WritableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [ErrorSteps]() {\n    ResetQueue(this);\n  }\n}\n\nObject.defineProperties(WritableStreamDefaultController.prototype, {\n  abortReason: { enumerable: true },\n  signal: { enumerable: true },\n  error: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'WritableStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Abstract operations implementing interface required by the WritableStream.\n\nfunction IsWritableStreamDefaultController(x: any): x is WritableStreamDefaultController<any> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n    return false;\n  }\n\n  return x instanceof WritableStreamDefaultController;\n}\n\nfunction SetUpWritableStreamDefaultController<W>(stream: WritableStream<W>,\n                                                 controller: WritableStreamDefaultController<W>,\n                                                 startAlgorithm: () => void | PromiseLike<void>,\n                                                 writeAlgorithm: (chunk: W) => Promise<void>,\n                                                 closeAlgorithm: () => Promise<void>,\n                                                 abortAlgorithm: (reason: any) => Promise<void>,\n                                                 highWaterMark: number,\n                                                 sizeAlgorithm: QueuingStrategySizeCallback<W>) {\n  assert(IsWritableStream(stream));\n  assert(stream._writableStreamController === undefined);\n\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = undefined!;\n  controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._abortReason = undefined;\n  controller._abortController = createAbortController();\n  controller._started = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n\n  const startResult = startAlgorithm();\n  const startPromise = promiseResolvedWith(startResult);\n  uponPromise(\n    startPromise,\n    () => {\n      assert(stream._state === 'writable' || stream._state === 'erroring');\n      controller._started = true;\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      return null;\n    },\n    r => {\n      assert(stream._state === 'writable' || stream._state === 'erroring');\n      controller._started = true;\n      WritableStreamDealWithRejection(stream, r);\n      return null;\n    }\n  );\n}\n\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink<W>(stream: WritableStream<W>,\n                                                                   underlyingSink: ValidatedUnderlyingSink<W>,\n                                                                   highWaterMark: number,\n                                                                   sizeAlgorithm: QueuingStrategySizeCallback<W>) {\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void>;\n  let writeAlgorithm: (chunk: W) => Promise<void>;\n  let closeAlgorithm: () => Promise<void>;\n  let abortAlgorithm: (reason: any) => Promise<void>;\n\n  if (underlyingSink.start !== undefined) {\n    startAlgorithm = () => underlyingSink.start!(controller);\n  } else {\n    startAlgorithm = () => undefined;\n  }\n  if (underlyingSink.write !== undefined) {\n    writeAlgorithm = chunk => underlyingSink.write!(chunk, controller);\n  } else {\n    writeAlgorithm = () => promiseResolvedWith(undefined);\n  }\n  if (underlyingSink.close !== undefined) {\n    closeAlgorithm = () => underlyingSink.close!();\n  } else {\n    closeAlgorithm = () => promiseResolvedWith(undefined);\n  }\n  if (underlyingSink.abort !== undefined) {\n    abortAlgorithm = reason => underlyingSink.abort!(reason);\n  } else {\n    abortAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  SetUpWritableStreamDefaultController(\n    stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm\n  );\n}\n\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller: WritableStreamDefaultController<any>) {\n  controller._writeAlgorithm = undefined!;\n  controller._closeAlgorithm = undefined!;\n  controller._abortAlgorithm = undefined!;\n  controller._strategySizeAlgorithm = undefined!;\n}\n\nfunction WritableStreamDefaultControllerClose<W>(controller: WritableStreamDefaultController<W>) {\n  EnqueueValueWithSize(controller, closeSentinel, 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetChunkSize<W>(controller: WritableStreamDefaultController<W>,\n                                                        chunk: W): number {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller: WritableStreamDefaultController<any>): number {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction WritableStreamDefaultControllerWrite<W>(controller: WritableStreamDefaultController<W>,\n                                                 chunk: W,\n                                                 chunkSize: number) {\n  try {\n    EnqueueValueWithSize(controller, chunk, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  const stream = controller._controlledWritableStream;\n  if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\n// Abstract operations for the WritableStreamDefaultController.\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded<W>(controller: WritableStreamDefaultController<W>) {\n  const stream = controller._controlledWritableStream;\n\n  if (!controller._started) {\n    return;\n  }\n\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n\n  const state = stream._state;\n  assert(state !== 'closed' && state !== 'errored');\n  if (state === 'erroring') {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  const value = PeekQueueValue(controller);\n  if (value === closeSentinel) {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, value);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller: WritableStreamDefaultController<any>, error: any) {\n  if (controller._controlledWritableStream._state === 'writable') {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller: WritableStreamDefaultController<any>) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkCloseRequestInFlight(stream);\n\n  DequeueValue(controller);\n  assert(controller._queue.length === 0);\n\n  const sinkClosePromise = controller._closeAlgorithm();\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  uponPromise(\n    sinkClosePromise,\n    () => {\n      WritableStreamFinishInFlightClose(stream);\n      return null;\n    },\n    reason => {\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\n      return null;\n    }\n  );\n}\n\nfunction WritableStreamDefaultControllerProcessWrite<W>(controller: WritableStreamDefaultController<W>, chunk: W) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\n  uponPromise(\n    sinkWritePromise,\n    () => {\n      WritableStreamFinishInFlightWrite(stream);\n\n      const state = stream._state;\n      assert(state === 'writable' || state === 'erroring');\n\n      DequeueValue(controller);\n\n      if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n      }\n\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      return null;\n    },\n    reason => {\n      if (stream._state === 'writable') {\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n      }\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\n      return null;\n    }\n  );\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller: WritableStreamDefaultController<any>): boolean {\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n}\n\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultControllerError(controller: WritableStreamDefaultController<any>, error: any) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'writable');\n\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  WritableStreamStartErroring(stream, error);\n}\n\n// Helper functions for the WritableStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n\n// Helper functions for the WritableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n}\n\n\n// Helper functions for the WritableStreamDefaultWriter.\n\nfunction defaultWriterBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\n\nfunction defaultWriterLockException(name: string): TypeError {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer: WritableStreamDefaultWriter) {\n  writer._closedPromise = newPromise((resolve, reject) => {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = 'pending';\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseReject(writer, reason);\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer: WritableStreamDefaultWriter) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseResolve(writer);\n}\n\nfunction defaultWriterClosedPromiseReject(writer: WritableStreamDefaultWriter, reason: any) {\n  if (writer._closedPromise_reject === undefined) {\n    return;\n  }\n  assert(writer._closedPromiseState === 'pending');\n\n  setPromiseIsHandledToTrue(writer._closedPromise);\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  assert(writer._closedPromise_resolve === undefined);\n  assert(writer._closedPromise_reject === undefined);\n  assert(writer._closedPromiseState !== 'pending');\n\n  defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n}\n\nfunction defaultWriterClosedPromiseResolve(writer: WritableStreamDefaultWriter) {\n  if (writer._closedPromise_resolve === undefined) {\n    return;\n  }\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer: WritableStreamDefaultWriter) {\n  writer._readyPromise = newPromise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseReject(writer, reason);\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer: WritableStreamDefaultWriter) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseResolve(writer);\n}\n\nfunction defaultWriterReadyPromiseReject(writer: WritableStreamDefaultWriter, reason: any) {\n  if (writer._readyPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(writer._readyPromise);\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseReset(writer: WritableStreamDefaultWriter) {\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  defaultWriterReadyPromiseInitialize(writer);\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n}\n\nfunction defaultWriterReadyPromiseResolve(writer: WritableStreamDefaultWriter) {\n  if (writer._readyPromise_resolve === undefined) {\n    return;\n  }\n\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n","/// <reference lib=\"dom\" />\n\nfunction getGlobals(): typeof globalThis | undefined {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n","/// <reference types=\"node\" />\nimport { globals } from '../globals';\nimport { setFunctionName } from '../lib/helpers/miscellaneous';\n\ninterface DOMException extends Error {\n  name: string;\n  message: string;\n}\n\ntype DOMExceptionConstructor = new (message?: string, name?: string) => DOMException;\n\nfunction isDOMExceptionConstructor(ctor: unknown): ctor is DOMExceptionConstructor {\n  if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n    return false;\n  }\n  if ((ctor as DOMExceptionConstructor).name !== 'DOMException') {\n    return false;\n  }\n  try {\n    new (ctor as DOMExceptionConstructor)();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Support:\n * - Web browsers\n * - Node 18 and higher (https://github.com/nodejs/node/commit/e4b1fb5e6422c1ff151234bb9de792d45dd88d87)\n */\nfunction getFromGlobal(): DOMExceptionConstructor | undefined {\n  const ctor = globals?.DOMException;\n  return isDOMExceptionConstructor(ctor) ? ctor : undefined;\n}\n\n/**\n * Support:\n * - All platforms\n */\nfunction createPolyfill(): DOMExceptionConstructor {\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  const ctor = function DOMException(this: DOMException, message?: string, name?: string) {\n    this.message = message || '';\n    this.name = name || 'Error';\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  } as any;\n  setFunctionName(ctor, 'DOMException');\n  ctor.prototype = Object.create(Error.prototype);\n  Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n  return ctor;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nconst DOMException: DOMExceptionConstructor = getFromGlobal() || createPolyfill();\n\nexport { DOMException };\n","import { IsReadableStream, IsReadableStreamLocked, ReadableStream, ReadableStreamCancel } from '../readable-stream';\nimport { AcquireReadableStreamDefaultReader, ReadableStreamDefaultReaderRead } from './default-reader';\nimport { ReadableStreamReaderGenericRelease } from './generic-reader';\nimport {\n  AcquireWritableStreamDefaultWriter,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamCloseQueuedOrInFlight,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite\n} from '../writable-stream';\nimport assert from '../../stub/assert';\nimport {\n  newPromise,\n  PerformPromiseThen,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  uponFulfillment,\n  uponPromise,\n  uponRejection\n} from '../helpers/webidl';\nimport { noop } from '../../utils';\nimport { type AbortSignal, isAbortSignal } from '../abort-signal';\nimport { DOMException } from '../../stub/dom-exception';\n\nexport function ReadableStreamPipeTo<T>(source: ReadableStream<T>,\n                                        dest: WritableStream<T>,\n                                        preventClose: boolean,\n                                        preventAbort: boolean,\n                                        preventCancel: boolean,\n                                        signal: AbortSignal | undefined): Promise<undefined> {\n  assert(IsReadableStream(source));\n  assert(IsWritableStream(dest));\n  assert(typeof preventClose === 'boolean');\n  assert(typeof preventAbort === 'boolean');\n  assert(typeof preventCancel === 'boolean');\n  assert(signal === undefined || isAbortSignal(signal));\n  assert(!IsReadableStreamLocked(source));\n  assert(!IsWritableStreamLocked(dest));\n\n  const reader = AcquireReadableStreamDefaultReader<T>(source);\n  const writer = AcquireWritableStreamDefaultWriter<T>(dest);\n\n  source._disturbed = true;\n\n  let shuttingDown = false;\n\n  // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n  let currentWrite = promiseResolvedWith<void>(undefined);\n\n  return newPromise((resolve, reject) => {\n    let abortAlgorithm: () => void;\n    if (signal !== undefined) {\n      abortAlgorithm = () => {\n        const error = signal.reason !== undefined ? signal.reason : new DOMException('Aborted', 'AbortError');\n        const actions: Array<() => Promise<void>> = [];\n        if (!preventAbort) {\n          actions.push(() => {\n            if (dest._state === 'writable') {\n              return WritableStreamAbort(dest, error);\n            }\n            return promiseResolvedWith(undefined);\n          });\n        }\n        if (!preventCancel) {\n          actions.push(() => {\n            if (source._state === 'readable') {\n              return ReadableStreamCancel(source, error);\n            }\n            return promiseResolvedWith(undefined);\n          });\n        }\n        shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n      };\n\n      if (signal.aborted) {\n        abortAlgorithm();\n        return;\n      }\n\n      signal.addEventListener('abort', abortAlgorithm);\n    }\n\n    // Using reader and writer, read all chunks from this and write them to dest\n    // - Backpressure must be enforced\n    // - Shutdown must stop all activity\n    function pipeLoop() {\n      return newPromise<void>((resolveLoop, rejectLoop) => {\n        function next(done: boolean) {\n          if (done) {\n            resolveLoop();\n          } else {\n            // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n            PerformPromiseThen(pipeStep(), next, rejectLoop);\n          }\n        }\n\n        next(false);\n      });\n    }\n\n    function pipeStep(): Promise<boolean> {\n      if (shuttingDown) {\n        return promiseResolvedWith(true);\n      }\n\n      return PerformPromiseThen(writer._readyPromise, () => {\n        return newPromise<boolean>((resolveRead, rejectRead) => {\n          ReadableStreamDefaultReaderRead(\n            reader,\n            {\n              _chunkSteps: chunk => {\n                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                resolveRead(false);\n              },\n              _closeSteps: () => resolveRead(true),\n              _errorSteps: rejectRead\n            }\n          );\n        });\n      });\n    }\n\n    // Errors must be propagated forward\n    isOrBecomesErrored(source, reader._closedPromise, storedError => {\n      if (!preventAbort) {\n        shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n      return null;\n    });\n\n    // Errors must be propagated backward\n    isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n      if (!preventCancel) {\n        shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n      return null;\n    });\n\n    // Closing must be propagated forward\n    isOrBecomesClosed(source, reader._closedPromise, () => {\n      if (!preventClose) {\n        shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n      } else {\n        shutdown();\n      }\n      return null;\n    });\n\n    // Closing must be propagated backward\n    if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n      const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n      if (!preventCancel) {\n        shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n      } else {\n        shutdown(true, destClosed);\n      }\n    }\n\n    setPromiseIsHandledToTrue(pipeLoop());\n\n    function waitForWritesToFinish(): Promise<void> {\n      // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n      // for that too.\n      const oldCurrentWrite = currentWrite;\n      return PerformPromiseThen(\n        currentWrite,\n        () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined\n      );\n    }\n\n    function isOrBecomesErrored(stream: ReadableStream | WritableStream,\n                                promise: Promise<void>,\n                                action: (reason: any) => null) {\n      if (stream._state === 'errored') {\n        action(stream._storedError);\n      } else {\n        uponRejection(promise, action);\n      }\n    }\n\n    function isOrBecomesClosed(stream: ReadableStream | WritableStream, promise: Promise<void>, action: () => null) {\n      if (stream._state === 'closed') {\n        action();\n      } else {\n        uponFulfillment(promise, action);\n      }\n    }\n\n    function shutdownWithAction(action: () => Promise<unknown>, originalIsError?: boolean, originalError?: any) {\n      if (shuttingDown) {\n        return;\n      }\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n        uponFulfillment(waitForWritesToFinish(), doTheRest);\n      } else {\n        doTheRest();\n      }\n\n      function doTheRest(): null {\n        uponPromise(\n          action(),\n          () => finalize(originalIsError, originalError),\n          newError => finalize(true, newError)\n        );\n        return null;\n      }\n    }\n\n    function shutdown(isError?: boolean, error?: any) {\n      if (shuttingDown) {\n        return;\n      }\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n        uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n      } else {\n        finalize(isError, error);\n      }\n    }\n\n    function finalize(isError?: boolean, error?: any): null {\n      WritableStreamDefaultWriterRelease(writer);\n      ReadableStreamReaderGenericRelease(reader);\n\n      if (signal !== undefined) {\n        signal.removeEventListener('abort', abortAlgorithm);\n      }\n      if (isError) {\n        reject(error);\n      } else {\n        resolve(undefined);\n      }\n\n      return null;\n    }\n  });\n}\n","import type { QueuingStrategySizeCallback } from '../queuing-strategy';\nimport assert from '../../stub/assert';\nimport { DequeueValue, EnqueueValueWithSize, type QueuePair, ResetQueue } from '../abstract-ops/queue-with-sizes';\nimport {\n  ReadableStreamAddReadRequest,\n  ReadableStreamFulfillReadRequest,\n  ReadableStreamGetNumReadRequests,\n  type ReadRequest\n} from './default-reader';\nimport { SimpleQueue } from '../simple-queue';\nimport { IsReadableStreamLocked, ReadableStream, ReadableStreamClose, ReadableStreamError } from '../readable-stream';\nimport type { ValidatedUnderlyingSource } from './underlying-source';\nimport { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\nimport { CancelSteps, PullSteps, ReleaseSteps } from '../abstract-ops/internal-methods';\nimport { promiseResolvedWith, uponPromise } from '../helpers/webidl';\n\n/**\n * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n *\n * @public\n */\nexport class ReadableStreamDefaultController<R> {\n  /** @internal */\n  _controlledReadableStream!: ReadableStream<R>;\n  /** @internal */\n  _queue!: SimpleQueue<QueuePair<R>>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _closeRequested!: boolean;\n  /** @internal */\n  _pullAgain!: boolean;\n  /** @internal */\n  _pulling !: boolean;\n  /** @internal */\n  _strategySizeAlgorithm!: QueuingStrategySizeCallback<R>;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _pullAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm!: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n   * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n   */\n  get desiredSize(): number | null {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  /**\n   * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   * the stream, but once those are read, the stream will become closed.\n   */\n  close(): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n      throw new TypeError('The stream is not in a state that permits close');\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  }\n\n  /**\n   * Enqueues the given chunk `chunk` in the controlled readable stream.\n   */\n  enqueue(chunk: R): void;\n  enqueue(chunk: R = undefined!): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n      throw new TypeError('The stream is not in a state that permits enqueue');\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   */\n  error(e: any = undefined): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  }\n\n  /** @internal */\n  [CancelSteps](reason: any): Promise<void> {\n    ResetQueue(this);\n    const result = this._cancelAlgorithm(reason);\n    ReadableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [PullSteps](readRequest: ReadRequest<R>): void {\n    const stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this);\n\n      if (this._closeRequested && this._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      readRequest._chunkSteps(chunk);\n    } else {\n      ReadableStreamAddReadRequest(stream, readRequest);\n      ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    }\n  }\n\n  /** @internal */\n  [ReleaseSteps](): void {\n    // Do nothing.\n  }\n}\n\nObject.defineProperties(ReadableStreamDefaultController.prototype, {\n  close: { enumerable: true },\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nsetFunctionName(ReadableStreamDefaultController.prototype.close, 'close');\nsetFunctionName(ReadableStreamDefaultController.prototype.enqueue, 'enqueue');\nsetFunctionName(ReadableStreamDefaultController.prototype.error, 'error');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Abstract operations for the ReadableStreamDefaultController.\n\nfunction IsReadableStreamDefaultController<R = any>(x: any): x is ReadableStreamDefaultController<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamDefaultController;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller: ReadableStreamDefaultController<any>): void {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (!shouldPull) {\n    return;\n  }\n\n  if (controller._pulling) {\n    controller._pullAgain = true;\n    return;\n  }\n\n  assert(!controller._pullAgain);\n\n  controller._pulling = true;\n\n  const pullPromise = controller._pullAlgorithm();\n  uponPromise(\n    pullPromise,\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain) {\n        controller._pullAgain = false;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n\n      return null;\n    },\n    e => {\n      ReadableStreamDefaultControllerError(controller, e);\n      return null;\n    }\n  );\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller: ReadableStreamDefaultController<any>): boolean {\n  const stream = controller._controlledReadableStream;\n\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return false;\n  }\n\n  if (!controller._started) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize! > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller: ReadableStreamDefaultController<any>) {\n  controller._pullAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n  controller._strategySizeAlgorithm = undefined!;\n}\n\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\nexport function ReadableStreamDefaultControllerClose(controller: ReadableStreamDefaultController<any>) {\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return;\n  }\n\n  const stream = controller._controlledReadableStream;\n\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n  }\n}\n\nexport function ReadableStreamDefaultControllerEnqueue<R>(\n  controller: ReadableStreamDefaultController<R>,\n  chunk: R\n): void {\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return;\n  }\n\n  const stream = controller._controlledReadableStream;\n\n  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize;\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n\n    try {\n      EnqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerError(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n}\n\nexport function ReadableStreamDefaultControllerError(controller: ReadableStreamDefaultController<any>, e: any) {\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ResetQueue(controller);\n\n  ReadableStreamDefaultControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nexport function ReadableStreamDefaultControllerGetDesiredSize(\n  controller: ReadableStreamDefaultController<any>\n): number | null {\n  const state = controller._controlledReadableStream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\n// This is used in the implementation of TransformStream.\nexport function ReadableStreamDefaultControllerHasBackpressure(\n  controller: ReadableStreamDefaultController<any>\n): boolean {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function ReadableStreamDefaultControllerCanCloseOrEnqueue(\n  controller: ReadableStreamDefaultController<any>\n): boolean {\n  const state = controller._controlledReadableStream._state;\n\n  if (!controller._closeRequested && state === 'readable') {\n    return true;\n  }\n\n  return false;\n}\n\nexport function SetUpReadableStreamDefaultController<R>(stream: ReadableStream<R>,\n                                                        controller: ReadableStreamDefaultController<R>,\n                                                        startAlgorithm: () => void | PromiseLike<void>,\n                                                        pullAlgorithm: () => Promise<void>,\n                                                        cancelAlgorithm: (reason: any) => Promise<void>,\n                                                        highWaterMark: number,\n                                                        sizeAlgorithm: QueuingStrategySizeCallback<R>) {\n  assert(stream._readableStreamController === undefined);\n\n  controller._controlledReadableStream = stream;\n\n  controller._queue = undefined!;\n  controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  uponPromise(\n    promiseResolvedWith(startResult),\n    () => {\n      controller._started = true;\n\n      assert(!controller._pulling);\n      assert(!controller._pullAgain);\n\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      return null;\n    },\n    r => {\n      ReadableStreamDefaultControllerError(controller, r);\n      return null;\n    }\n  );\n}\n\nexport function SetUpReadableStreamDefaultControllerFromUnderlyingSource<R>(\n  stream: ReadableStream<R>,\n  underlyingSource: ValidatedUnderlyingSource<R>,\n  highWaterMark: number,\n  sizeAlgorithm: QueuingStrategySizeCallback<R>\n) {\n  const controller: ReadableStreamDefaultController<R> = Object.create(ReadableStreamDefaultController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void>;\n  let pullAlgorithm: () => Promise<void>;\n  let cancelAlgorithm: (reason: any) => Promise<void>;\n\n  if (underlyingSource.start !== undefined) {\n    startAlgorithm = () => underlyingSource.start!(controller);\n  } else {\n    startAlgorithm = () => undefined;\n  }\n  if (underlyingSource.pull !== undefined) {\n    pullAlgorithm = () => underlyingSource.pull!(controller);\n  } else {\n    pullAlgorithm = () => promiseResolvedWith(undefined);\n  }\n  if (underlyingSource.cancel !== undefined) {\n    cancelAlgorithm = reason => underlyingSource.cancel!(reason);\n  } else {\n    cancelAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  SetUpReadableStreamDefaultController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n}\n\n// Helper functions for the ReadableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n","import {\n  CreateReadableByteStream,\n  CreateReadableStream,\n  type DefaultReadableStream,\n  IsReadableStream,\n  type ReadableByteStream,\n  ReadableStream,\n  ReadableStreamCancel,\n  type ReadableStreamReader\n} from '../readable-stream';\nimport { ReadableStreamReaderGenericRelease } from './generic-reader';\nimport {\n  AcquireReadableStreamDefaultReader,\n  IsReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderRead,\n  type ReadRequest\n} from './default-reader';\nimport {\n  AcquireReadableStreamBYOBReader,\n  IsReadableStreamBYOBReader,\n  ReadableStreamBYOBReaderRead,\n  type ReadIntoRequest\n} from './byob-reader';\nimport assert from '../../stub/assert';\nimport { newPromise, promiseResolvedWith, queueMicrotask, uponRejection } from '../helpers/webidl';\nimport {\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError\n} from './default-controller';\nimport {\n  IsReadableByteStreamController,\n  ReadableByteStreamControllerClose,\n  ReadableByteStreamControllerEnqueue,\n  ReadableByteStreamControllerError,\n  ReadableByteStreamControllerGetBYOBRequest,\n  ReadableByteStreamControllerRespond,\n  ReadableByteStreamControllerRespondWithNewView\n} from './byte-stream-controller';\nimport { CreateArrayFromList } from '../abstract-ops/ecmascript';\nimport { CloneAsUint8Array } from '../abstract-ops/miscellaneous';\nimport type { NonShared } from '../helpers/array-buffer-view';\n\nexport function ReadableStreamTee<R>(stream: ReadableStream<R>,\n                                     cloneForBranch2: boolean): [ReadableStream<R>, ReadableStream<R>] {\n  assert(IsReadableStream(stream));\n  assert(typeof cloneForBranch2 === 'boolean');\n  if (IsReadableByteStreamController(stream._readableStreamController)) {\n    return ReadableByteStreamTee(stream as unknown as ReadableByteStream) as\n      unknown as [ReadableStream<R>, ReadableStream<R>];\n  }\n  return ReadableStreamDefaultTee(stream, cloneForBranch2);\n}\n\nexport function ReadableStreamDefaultTee<R>(\n  stream: ReadableStream<R>,\n  cloneForBranch2: boolean\n): [DefaultReadableStream<R>, DefaultReadableStream<R>] {\n  assert(IsReadableStream(stream));\n  assert(typeof cloneForBranch2 === 'boolean');\n\n  const reader = AcquireReadableStreamDefaultReader<R>(stream);\n\n  let reading = false;\n  let readAgain = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1: any;\n  let reason2: any;\n  let branch1: DefaultReadableStream<R>;\n  let branch2: DefaultReadableStream<R>;\n\n  let resolveCancelPromise: (value: undefined | Promise<undefined>) => void;\n  const cancelPromise = newPromise<undefined>(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function pullAlgorithm(): Promise<void> {\n    if (reading) {\n      readAgain = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgain = false;\n          const chunk1 = chunk;\n          const chunk2 = chunk;\n\n          // There is no way to access the cloning code right now in the reference implementation.\n          // If we add one then we'll need an implementation for serializable objects.\n          // if (!canceled2 && cloneForBranch2) {\n          //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n          // }\n\n          if (!canceled1) {\n            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n          }\n          if (!canceled2) {\n            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n          }\n\n          reading = false;\n          if (readAgain) {\n            pullAlgorithm();\n          }\n        });\n      },\n      _closeSteps: () => {\n        reading = false;\n        if (!canceled1) {\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n        }\n        if (!canceled2) {\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n        }\n\n        if (!canceled1 || !canceled2) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function cancel1Algorithm(reason: any): Promise<void> {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason: any): Promise<void> {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm() {\n    // do nothing\n  }\n\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n\n  uponRejection(reader._closedPromise, (r: any) => {\n    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n    if (!canceled1 || !canceled2) {\n      resolveCancelPromise(undefined);\n    }\n    return null;\n  });\n\n  return [branch1, branch2];\n}\n\nexport function ReadableByteStreamTee(stream: ReadableByteStream): [ReadableByteStream, ReadableByteStream] {\n  assert(IsReadableStream(stream));\n  assert(IsReadableByteStreamController(stream._readableStreamController));\n\n  let reader: ReadableStreamReader<NonShared<Uint8Array>> = AcquireReadableStreamDefaultReader(stream);\n  let reading = false;\n  let readAgainForBranch1 = false;\n  let readAgainForBranch2 = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1: any;\n  let reason2: any;\n  let branch1: ReadableByteStream;\n  let branch2: ReadableByteStream;\n\n  let resolveCancelPromise: (value: undefined | Promise<undefined>) => void;\n  const cancelPromise = newPromise<void>(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function forwardReaderError(thisReader: ReadableStreamReader<NonShared<Uint8Array>>) {\n    uponRejection(thisReader._closedPromise, r => {\n      if (thisReader !== reader) {\n        return null;\n      }\n      ReadableByteStreamControllerError(branch1._readableStreamController, r);\n      ReadableByteStreamControllerError(branch2._readableStreamController, r);\n      if (!canceled1 || !canceled2) {\n        resolveCancelPromise(undefined);\n      }\n      return null;\n    });\n  }\n\n  function pullWithDefaultReader() {\n    if (IsReadableStreamBYOBReader(reader)) {\n      assert(reader._readIntoRequests.length === 0);\n      ReadableStreamReaderGenericRelease(reader);\n\n      reader = AcquireReadableStreamDefaultReader(stream);\n      forwardReaderError(reader);\n    }\n\n    const readRequest: ReadRequest<NonShared<Uint8Array>> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgainForBranch1 = false;\n          readAgainForBranch2 = false;\n\n          const chunk1 = chunk;\n          let chunk2 = chunk;\n          if (!canceled1 && !canceled2) {\n            try {\n              chunk2 = CloneAsUint8Array(chunk);\n            } catch (cloneE) {\n              ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n              ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n              return;\n            }\n          }\n\n          if (!canceled1) {\n            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n          }\n          if (!canceled2) {\n            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n          }\n\n          reading = false;\n          if (readAgainForBranch1) {\n            pull1Algorithm();\n          } else if (readAgainForBranch2) {\n            pull2Algorithm();\n          }\n        });\n      },\n      _closeSteps: () => {\n        reading = false;\n        if (!canceled1) {\n          ReadableByteStreamControllerClose(branch1._readableStreamController);\n        }\n        if (!canceled2) {\n          ReadableByteStreamControllerClose(branch2._readableStreamController);\n        }\n        if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n          ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n        }\n        if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n          ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n        }\n        if (!canceled1 || !canceled2) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n  }\n\n  function pullWithBYOBReader(view: NonShared<ArrayBufferView>, forBranch2: boolean) {\n    if (IsReadableStreamDefaultReader<NonShared<Uint8Array>>(reader)) {\n      assert(reader._readRequests.length === 0);\n      ReadableStreamReaderGenericRelease(reader);\n\n      reader = AcquireReadableStreamBYOBReader(stream);\n      forwardReaderError(reader);\n    }\n\n    const byobBranch = forBranch2 ? branch2 : branch1;\n    const otherBranch = forBranch2 ? branch1 : branch2;\n\n    const readIntoRequest: ReadIntoRequest<NonShared<ArrayBufferView>> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgainForBranch1 = false;\n          readAgainForBranch2 = false;\n\n          const byobCanceled = forBranch2 ? canceled2 : canceled1;\n          const otherCanceled = forBranch2 ? canceled1 : canceled2;\n\n          if (!otherCanceled) {\n            let clonedChunk;\n            try {\n              clonedChunk = CloneAsUint8Array(chunk);\n            } catch (cloneE) {\n              ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n              ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n              return;\n            }\n            if (!byobCanceled) {\n              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n            }\n            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n          } else if (!byobCanceled) {\n            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n          }\n\n          reading = false;\n          if (readAgainForBranch1) {\n            pull1Algorithm();\n          } else if (readAgainForBranch2) {\n            pull2Algorithm();\n          }\n        });\n      },\n      _closeSteps: chunk => {\n        reading = false;\n\n        const byobCanceled = forBranch2 ? canceled2 : canceled1;\n        const otherCanceled = forBranch2 ? canceled1 : canceled2;\n\n        if (!byobCanceled) {\n          ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n        }\n        if (!otherCanceled) {\n          ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n        }\n\n        if (chunk !== undefined) {\n          assert(chunk.byteLength === 0);\n\n          if (!byobCanceled) {\n            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n          }\n          if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n          }\n        }\n\n        if (!byobCanceled || !otherCanceled) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);\n  }\n\n  function pull1Algorithm(): Promise<void> {\n    if (reading) {\n      readAgainForBranch1 = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n    if (byobRequest === null) {\n      pullWithDefaultReader();\n    } else {\n      pullWithBYOBReader(byobRequest._view!, false);\n    }\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function pull2Algorithm(): Promise<void> {\n    if (reading) {\n      readAgainForBranch2 = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n    if (byobRequest === null) {\n      pullWithDefaultReader();\n    } else {\n      pullWithBYOBReader(byobRequest._view!, true);\n    }\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function cancel1Algorithm(reason: any): Promise<void> {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason: any): Promise<void> {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm(): void {\n    return;\n  }\n\n  branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n  branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n\n  forwardReaderError(reader);\n\n  return [branch1, branch2];\n}\n","import { typeIsObject } from '../helpers/miscellaneous';\nimport type { ReadableStreamDefaultReadResult } from './default-reader';\n\n/**\n * A common interface for a `ReadadableStream` implementation.\n *\n * @public\n */\nexport interface ReadableStreamLike<R = any> {\n  readonly locked: boolean;\n\n  getReader(): ReadableStreamDefaultReaderLike<R>;\n}\n\n/**\n * A common interface for a `ReadableStreamDefaultReader` implementation.\n *\n * @public\n */\nexport interface ReadableStreamDefaultReaderLike<R = any> {\n  readonly closed: Promise<undefined>;\n\n  cancel(reason?: any): Promise<void>;\n\n  read(): Promise<ReadableStreamDefaultReadResult<R>>;\n\n  releaseLock(): void;\n}\n\nexport function isReadableStreamLike<R>(stream: unknown): stream is ReadableStreamLike<R> {\n  return typeIsObject(stream) && typeof (stream as ReadableStreamLike<R>).getReader !== 'undefined';\n}\n","import { CreateReadableStream, type DefaultReadableStream } from '../readable-stream';\nimport {\n  isReadableStreamLike,\n  type ReadableStreamDefaultReaderLike,\n  type ReadableStreamLike\n} from './readable-stream-like';\nimport { ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue } from './default-controller';\nimport { GetIterator, GetMethod, IteratorComplete, IteratorNext, IteratorValue } from '../abstract-ops/ecmascript';\nimport { promiseRejectedWith, promiseResolvedWith, reflectCall, transformPromiseWith } from '../helpers/webidl';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport { noop } from '../../utils';\n\nexport function ReadableStreamFrom<R>(\n  source: Iterable<R> | AsyncIterable<R> | ReadableStreamLike<R>\n): DefaultReadableStream<R> {\n  if (isReadableStreamLike(source)) {\n    return ReadableStreamFromDefaultReader(source.getReader());\n  }\n  return ReadableStreamFromIterable(source);\n}\n\nexport function ReadableStreamFromIterable<R>(asyncIterable: Iterable<R> | AsyncIterable<R>): DefaultReadableStream<R> {\n  let stream: DefaultReadableStream<R>;\n  const iteratorRecord = GetIterator(asyncIterable, 'async');\n\n  const startAlgorithm = noop;\n\n  function pullAlgorithm(): Promise<void> {\n    let nextResult;\n    try {\n      nextResult = IteratorNext(iteratorRecord);\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    const nextPromise = promiseResolvedWith(nextResult);\n    return transformPromiseWith(nextPromise, iterResult => {\n      if (!typeIsObject(iterResult)) {\n        throw new TypeError('The promise returned by the iterator.next() method must fulfill with an object');\n      }\n      const done = IteratorComplete(iterResult);\n      if (done) {\n        ReadableStreamDefaultControllerClose(stream._readableStreamController);\n      } else {\n        const value = IteratorValue(iterResult);\n        ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n      }\n    });\n  }\n\n  function cancelAlgorithm(reason: any): Promise<void> {\n    const iterator = iteratorRecord.iterator;\n    let returnMethod: (typeof iterator)['return'] | undefined;\n    try {\n      returnMethod = GetMethod(iterator, 'return');\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    if (returnMethod === undefined) {\n      return promiseResolvedWith(undefined);\n    }\n    let returnResult: IteratorResult<R> | Promise<IteratorResult<R>>;\n    try {\n      returnResult = reflectCall(returnMethod, iterator, [reason]);\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    const returnPromise = promiseResolvedWith(returnResult);\n    return transformPromiseWith(returnPromise, iterResult => {\n      if (!typeIsObject(iterResult)) {\n        throw new TypeError('The promise returned by the iterator.return() method must fulfill with an object');\n      }\n      return undefined;\n    });\n  }\n\n  stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);\n  return stream;\n}\n\nexport function ReadableStreamFromDefaultReader<R>(\n  reader: ReadableStreamDefaultReaderLike<R>\n): DefaultReadableStream<R> {\n  let stream: DefaultReadableStream<R>;\n\n  const startAlgorithm = noop;\n\n  function pullAlgorithm(): Promise<void> {\n    let readPromise;\n    try {\n      readPromise = reader.read();\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    return transformPromiseWith(readPromise, readResult => {\n      if (!typeIsObject(readResult)) {\n        throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n      }\n      if (readResult.done) {\n        ReadableStreamDefaultControllerClose(stream._readableStreamController);\n      } else {\n        const value = readResult.value;\n        ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n      }\n    });\n  }\n\n  function cancelAlgorithm(reason: any): Promise<void> {\n    try {\n      return promiseResolvedWith(reader.cancel(reason));\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n  }\n\n  stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);\n  return stream;\n}\n","import { assertDictionary, assertFunction, convertUnsignedLongLongWithEnforceRange } from './basic';\nimport type {\n  ReadableStreamController,\n  UnderlyingByteSource,\n  UnderlyingDefaultOrByteSource,\n  UnderlyingDefaultOrByteSourcePullCallback,\n  UnderlyingDefaultOrByteSourceStartCallback,\n  UnderlyingSource,\n  UnderlyingSourceCancelCallback,\n  ValidatedUnderlyingDefaultOrByteSource\n} from '../readable-stream/underlying-source';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\n\nexport function convertUnderlyingDefaultOrByteSource<R>(\n  source: UnderlyingSource<R> | UnderlyingByteSource | null,\n  context: string\n): ValidatedUnderlyingDefaultOrByteSource<R> {\n  assertDictionary(source, context);\n  const original = source as (UnderlyingDefaultOrByteSource<R> | null);\n  const autoAllocateChunkSize = original?.autoAllocateChunkSize;\n  const cancel = original?.cancel;\n  const pull = original?.pull;\n  const start = original?.start;\n  const type = original?.type;\n  return {\n    autoAllocateChunkSize: autoAllocateChunkSize === undefined ?\n      undefined :\n      convertUnsignedLongLongWithEnforceRange(\n        autoAllocateChunkSize,\n        `${context} has member 'autoAllocateChunkSize' that`\n      ),\n    cancel: cancel === undefined ?\n      undefined :\n      convertUnderlyingSourceCancelCallback(cancel, original!, `${context} has member 'cancel' that`),\n    pull: pull === undefined ?\n      undefined :\n      convertUnderlyingSourcePullCallback(pull, original!, `${context} has member 'pull' that`),\n    start: start === undefined ?\n      undefined :\n      convertUnderlyingSourceStartCallback(start, original!, `${context} has member 'start' that`),\n    type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n  };\n}\n\nfunction convertUnderlyingSourceCancelCallback(\n  fn: UnderlyingSourceCancelCallback,\n  original: UnderlyingDefaultOrByteSource,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n\nfunction convertUnderlyingSourcePullCallback<R>(\n  fn: UnderlyingDefaultOrByteSourcePullCallback<R>,\n  original: UnderlyingDefaultOrByteSource<R>,\n  context: string\n): (controller: ReadableStreamController<R>) => Promise<void> {\n  assertFunction(fn, context);\n  return (controller: ReadableStreamController<R>) => promiseCall(fn, original, [controller]);\n}\n\nfunction convertUnderlyingSourceStartCallback<R>(\n  fn: UnderlyingDefaultOrByteSourceStartCallback<R>,\n  original: UnderlyingDefaultOrByteSource<R>,\n  context: string\n): UnderlyingDefaultOrByteSourceStartCallback<R> {\n  assertFunction(fn, context);\n  return (controller: ReadableStreamController<R>) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertReadableStreamType(type: string, context: string): 'bytes' {\n  type = `${type}`;\n  if (type !== 'bytes') {\n    throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n  }\n  return type;\n}\n","import { assertDictionary } from './basic';\nimport type {\n  ReadableStreamIteratorOptions,\n  ValidatedReadableStreamIteratorOptions\n} from '../readable-stream/iterator-options';\n\nexport function convertIteratorOptions(options: ReadableStreamIteratorOptions | null | undefined,\n                                       context: string): ValidatedReadableStreamIteratorOptions {\n  assertDictionary(options, context);\n  const preventCancel = options?.preventCancel;\n  return { preventCancel: Boolean(preventCancel) };\n}\n","import { assertDictionary } from './basic';\nimport type { StreamPipeOptions, ValidatedStreamPipeOptions } from '../readable-stream/pipe-options';\nimport { type AbortSignal, isAbortSignal } from '../abort-signal';\n\nexport function convertPipeOptions(options: StreamPipeOptions | null | undefined,\n                                   context: string): ValidatedStreamPipeOptions {\n  assertDictionary(options, context);\n  const preventAbort = options?.preventAbort;\n  const preventCancel = options?.preventCancel;\n  const preventClose = options?.preventClose;\n  const signal = options?.signal;\n  if (signal !== undefined) {\n    assertAbortSignal(signal, `${context} has member 'signal' that`);\n  }\n  return {\n    preventAbort: Boolean(preventAbort),\n    preventCancel: Boolean(preventCancel),\n    preventClose: Boolean(preventClose),\n    signal\n  };\n}\n\nfunction assertAbortSignal(signal: unknown, context: string): asserts signal is AbortSignal {\n  if (!isAbortSignal(signal)) {\n    throw new TypeError(`${context} is not an AbortSignal.`);\n  }\n}\n","import { assertDictionary, assertRequiredField } from './basic';\nimport { ReadableStream } from '../readable-stream';\nimport { WritableStream } from '../writable-stream';\nimport { assertReadableStream } from './readable-stream';\nimport { assertWritableStream } from './writable-stream';\n\nexport function convertReadableWritablePair<RS extends ReadableStream, WS extends WritableStream>(\n  pair: { readable: RS; writable: WS } | null | undefined,\n  context: string\n): { readable: RS; writable: WS } {\n  assertDictionary(pair, context);\n\n  const readable = pair?.readable;\n  assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n  assertReadableStream(readable, `${context} has member 'readable' that`);\n\n  const writable = pair?.writable;\n  assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n  assertWritableStream(writable, `${context} has member 'writable' that`);\n\n  return { readable, writable };\n}\n","import assert from '../stub/assert';\nimport {\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  transformPromiseWith\n} from './helpers/webidl';\nimport type { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { AcquireReadableStreamAsyncIterator, type ReadableStreamAsyncIterator } from './readable-stream/async-iterator';\nimport { defaultReaderClosedPromiseReject, defaultReaderClosedPromiseResolve } from './readable-stream/generic-reader';\nimport {\n  AcquireReadableStreamDefaultReader,\n  IsReadableStreamDefaultReader,\n  ReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderErrorReadRequests,\n  type ReadableStreamDefaultReadResult\n} from './readable-stream/default-reader';\nimport {\n  AcquireReadableStreamBYOBReader,\n  IsReadableStreamBYOBReader,\n  ReadableStreamBYOBReader,\n  ReadableStreamBYOBReaderErrorReadIntoRequests,\n  type ReadableStreamBYOBReadResult\n} from './readable-stream/byob-reader';\nimport { ReadableStreamPipeTo } from './readable-stream/pipe';\nimport { ReadableStreamTee } from './readable-stream/tee';\nimport { ReadableStreamFrom } from './readable-stream/from';\nimport { IsWritableStream, IsWritableStreamLocked, WritableStream } from './writable-stream';\nimport { SimpleQueue } from './simple-queue';\nimport {\n  ReadableByteStreamController,\n  ReadableStreamBYOBRequest,\n  SetUpReadableByteStreamController,\n  SetUpReadableByteStreamControllerFromUnderlyingSource\n} from './readable-stream/byte-stream-controller';\nimport {\n  ReadableStreamDefaultController,\n  SetUpReadableStreamDefaultController,\n  SetUpReadableStreamDefaultControllerFromUnderlyingSource\n} from './readable-stream/default-controller';\nimport type {\n  UnderlyingByteSource,\n  UnderlyingByteSourcePullCallback,\n  UnderlyingByteSourceStartCallback,\n  UnderlyingSource,\n  UnderlyingSourceCancelCallback,\n  UnderlyingSourcePullCallback,\n  UnderlyingSourceStartCallback\n} from './readable-stream/underlying-source';\nimport { noop } from '../utils';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { CreateArrayFromList, SymbolAsyncIterator } from './abstract-ops/ecmascript';\nimport { CancelSteps } from './abstract-ops/internal-methods';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { assertObject, assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport { convertUnderlyingDefaultOrByteSource } from './validators/underlying-source';\nimport type {\n  ReadableStreamBYOBReaderReadOptions,\n  ReadableStreamGetReaderOptions\n} from './readable-stream/reader-options';\nimport { convertReaderOptions } from './validators/reader-options';\nimport type { StreamPipeOptions, ValidatedStreamPipeOptions } from './readable-stream/pipe-options';\nimport type { ReadableStreamIteratorOptions } from './readable-stream/iterator-options';\nimport { convertIteratorOptions } from './validators/iterator-options';\nimport { convertPipeOptions } from './validators/pipe-options';\nimport type { ReadableWritablePair } from './readable-stream/readable-writable-pair';\nimport { convertReadableWritablePair } from './validators/readable-writable-pair';\nimport type { ReadableStreamDefaultReaderLike, ReadableStreamLike } from './readable-stream/readable-stream-like';\nimport type { NonShared } from './helpers/array-buffer-view';\n\nexport type DefaultReadableStream<R = any> = ReadableStream<R> & {\n  _readableStreamController: ReadableStreamDefaultController<R>\n};\n\nexport type ReadableByteStream = ReadableStream<NonShared<Uint8Array>> & {\n  _readableStreamController: ReadableByteStreamController\n};\n\ntype ReadableStreamState = 'readable' | 'closed' | 'errored';\n\n/**\n * A readable stream represents a source of data, from which you can read.\n *\n * @public\n */\nexport class ReadableStream<R = any> implements AsyncIterable<R> {\n  /** @internal */\n  _state!: ReadableStreamState;\n  /** @internal */\n  _reader: ReadableStreamReader<R> | undefined;\n  /** @internal */\n  _storedError: any;\n  /** @internal */\n  _disturbed!: boolean;\n  /** @internal */\n  _readableStreamController!: ReadableStreamDefaultController<R> | ReadableByteStreamController;\n\n  constructor(underlyingSource: UnderlyingByteSource, strategy?: { highWaterMark?: number; size?: undefined });\n  constructor(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>);\n  constructor(rawUnderlyingSource: UnderlyingSource<R> | UnderlyingByteSource | null | undefined = {},\n              rawStrategy: QueuingStrategy<R> | null | undefined = {}) {\n    if (rawUnderlyingSource === undefined) {\n      rawUnderlyingSource = null;\n    } else {\n      assertObject(rawUnderlyingSource, 'First parameter');\n    }\n\n    const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n    const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n\n    InitializeReadableStream(this);\n\n    if (underlyingSource.type === 'bytes') {\n      if (strategy.size !== undefined) {\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\n      }\n      const highWaterMark = ExtractHighWaterMark(strategy, 0);\n      SetUpReadableByteStreamControllerFromUnderlyingSource(\n        this as unknown as ReadableByteStream,\n        underlyingSource,\n        highWaterMark\n      );\n    } else {\n      assert(underlyingSource.type === undefined);\n      const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n      const highWaterMark = ExtractHighWaterMark(strategy, 1);\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(\n        this,\n        underlyingSource,\n        highWaterMark,\n        sizeAlgorithm\n      );\n    }\n  }\n\n  /**\n   * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n   */\n  get locked(): boolean {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsReadableStreamLocked(this);\n  }\n\n  /**\n   * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n   *\n   * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n   * method, which might or might not use it.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  }\n\n  /**\n   * Creates a {@link ReadableStreamBYOBReader} and locks the stream to the new reader.\n   *\n   * This call behaves the same way as the no-argument variant, except that it only works on readable byte streams,\n   * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n   * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n   * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n   * control over allocation.\n   */\n  getReader({ mode }: { mode: 'byob' }): ReadableStreamBYOBReader;\n  /**\n   * Creates a {@link ReadableStreamDefaultReader} and locks the stream to the new reader.\n   * While the stream is locked, no other reader can be acquired until this one is released.\n   *\n   * This functionality is especially useful for creating abstractions that desire the ability to consume a stream\n   * in its entirety. By getting a reader for the stream, you can ensure nobody else can interleave reads with yours\n   * or cancel the stream, which would interfere with your abstraction.\n   */\n  getReader(): ReadableStreamDefaultReader<R>;\n  getReader(\n    rawOptions: ReadableStreamGetReaderOptions | null | undefined = undefined\n  ): ReadableStreamDefaultReader<R> | ReadableStreamBYOBReader {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('getReader');\n    }\n\n    const options = convertReaderOptions(rawOptions, 'First parameter');\n\n    if (options.mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    assert(options.mode === 'byob');\n    return AcquireReadableStreamBYOBReader(this as unknown as ReadableByteStream);\n  }\n\n  /**\n   * Provides a convenient, chainable way of piping this readable stream through a transform stream\n   * (or any other `{ writable, readable }` pair). It simply {@link ReadableStream.pipeTo | pipes} the stream\n   * into the writable side of the supplied pair, and returns the readable side for further use.\n   *\n   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   */\n  pipeThrough<RS extends ReadableStream>(\n    transform: { readable: RS; writable: WritableStream<R> },\n    options?: StreamPipeOptions\n  ): RS;\n  pipeThrough<RS extends ReadableStream>(\n    rawTransform: { readable: RS; writable: WritableStream<R> } | null | undefined,\n    rawOptions: StreamPipeOptions | null | undefined = {}\n  ): RS {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('pipeThrough');\n    }\n    assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n\n    const transform = convertReadableWritablePair(rawTransform, 'First parameter');\n    const options = convertPipeOptions(rawOptions, 'Second parameter');\n\n    if (IsReadableStreamLocked(this)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n    }\n    if (IsWritableStreamLocked(transform.writable)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n    }\n\n    const promise = ReadableStreamPipeTo(\n      this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal\n    );\n\n    setPromiseIsHandledToTrue(promise);\n\n    return transform.readable;\n  }\n\n  /**\n   * Pipes this readable stream to a given writable stream. The way in which the piping process behaves under\n   * various error conditions can be customized with a number of passed options. It returns a promise that fulfills\n   * when the piping process completes successfully, or rejects if any errors were encountered.\n   *\n   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   */\n  pipeTo(destination: WritableStream<R>, options?: StreamPipeOptions): Promise<void>;\n  pipeTo(destination: WritableStream<R> | null | undefined,\n         rawOptions: StreamPipeOptions | null | undefined = {}): Promise<void> {\n    if (!IsReadableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('pipeTo'));\n    }\n\n    if (destination === undefined) {\n      return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n    }\n    if (!IsWritableStream(destination)) {\n      return promiseRejectedWith(\n        new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`)\n      );\n    }\n\n    let options: ValidatedStreamPipeOptions;\n    try {\n      options = convertPipeOptions(rawOptions, 'Second parameter');\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n\n    if (IsReadableStreamLocked(this)) {\n      return promiseRejectedWith(\n        new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream')\n      );\n    }\n    if (IsWritableStreamLocked(destination)) {\n      return promiseRejectedWith(\n        new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream')\n      );\n    }\n\n    return ReadableStreamPipeTo<R>(\n      this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal\n    );\n  }\n\n  /**\n   * Tees this readable stream, returning a two-element array containing the two resulting branches as\n   * new {@link ReadableStream} instances.\n   *\n   * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n   * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n   * propagated to the stream's underlying source.\n   *\n   * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n   * this could allow interference between the two branches.\n   */\n  tee(): [ReadableStream<R>, ReadableStream<R>] {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('tee');\n    }\n\n    const branches = ReadableStreamTee(this, false);\n    return CreateArrayFromList(branches);\n  }\n\n  /**\n   * Asynchronously iterates over the chunks in the stream's internal queue.\n   *\n   * Asynchronously iterating over the stream will lock it, preventing any other consumer from acquiring a reader.\n   * The lock will be released if the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method\n   * is called, e.g. by breaking out of the loop.\n   *\n   * By default, calling the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method will also\n   * cancel the stream. To prevent this, use the stream's {@link ReadableStream.values | values()} method, passing\n   * `true` for the `preventCancel` option.\n   */\n  values(options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n  values(rawOptions: ReadableStreamIteratorOptions | null | undefined = undefined): ReadableStreamAsyncIterator<R> {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('values');\n    }\n\n    const options = convertIteratorOptions(rawOptions, 'First parameter');\n    return AcquireReadableStreamAsyncIterator<R>(this, options.preventCancel);\n  }\n\n  /**\n   * {@inheritDoc ReadableStream.values}\n   */\n  [Symbol.asyncIterator](options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n\n  [SymbolAsyncIterator](options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R> {\n    // Stub implementation, overridden below\n    return this.values(options);\n  }\n\n  /**\n   * Creates a new ReadableStream wrapping the provided iterable or async iterable.\n   *\n   * This can be used to adapt various kinds of objects into a readable stream,\n   * such as an array, an async generator, or a Node.js readable stream.\n   */\n  static from<R>(asyncIterable: Iterable<R> | AsyncIterable<R> | ReadableStreamLike<R>): ReadableStream<R> {\n    return ReadableStreamFrom(asyncIterable);\n  }\n}\n\nObject.defineProperties(ReadableStream, {\n  from: { enumerable: true }\n});\nObject.defineProperties(ReadableStream.prototype, {\n  cancel: { enumerable: true },\n  getReader: { enumerable: true },\n  pipeThrough: { enumerable: true },\n  pipeTo: { enumerable: true },\n  tee: { enumerable: true },\n  values: { enumerable: true },\n  locked: { enumerable: true }\n});\nsetFunctionName(ReadableStream.from, 'from');\nsetFunctionName(ReadableStream.prototype.cancel, 'cancel');\nsetFunctionName(ReadableStream.prototype.getReader, 'getReader');\nsetFunctionName(ReadableStream.prototype.pipeThrough, 'pipeThrough');\nsetFunctionName(ReadableStream.prototype.pipeTo, 'pipeTo');\nsetFunctionName(ReadableStream.prototype.tee, 'tee');\nsetFunctionName(ReadableStream.prototype.values, 'values');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, {\n    value: 'ReadableStream',\n    configurable: true\n  });\n}\nObject.defineProperty(ReadableStream.prototype, SymbolAsyncIterator, {\n  value: ReadableStream.prototype.values,\n  writable: true,\n  configurable: true\n});\n\nexport type {\n  ReadableStreamAsyncIterator,\n  ReadableStreamDefaultReadResult,\n  ReadableStreamBYOBReadResult,\n  ReadableStreamBYOBReaderReadOptions,\n  UnderlyingByteSource,\n  UnderlyingSource,\n  UnderlyingSourceStartCallback,\n  UnderlyingSourcePullCallback,\n  UnderlyingSourceCancelCallback,\n  UnderlyingByteSourceStartCallback,\n  UnderlyingByteSourcePullCallback,\n  StreamPipeOptions,\n  ReadableWritablePair,\n  ReadableStreamIteratorOptions,\n  ReadableStreamLike,\n  ReadableStreamDefaultReaderLike\n};\n\n// Abstract operations for the ReadableStream.\n\n// Throws if and only if startAlgorithm throws.\nexport function CreateReadableStream<R>(\n  startAlgorithm: () => void | PromiseLike<void>,\n  pullAlgorithm: () => Promise<void>,\n  cancelAlgorithm: (reason: any) => Promise<void>,\n  highWaterMark = 1,\n  sizeAlgorithm: QueuingStrategySizeCallback<R> = () => 1\n): DefaultReadableStream<R> {\n  assert(IsNonNegativeNumber(highWaterMark));\n\n  const stream: DefaultReadableStream<R> = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller: ReadableStreamDefaultController<R> = Object.create(ReadableStreamDefaultController.prototype);\n  SetUpReadableStreamDefaultController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n\n  return stream;\n}\n\n// Throws if and only if startAlgorithm throws.\nexport function CreateReadableByteStream(\n  startAlgorithm: () => void | PromiseLike<void>,\n  pullAlgorithm: () => Promise<void>,\n  cancelAlgorithm: (reason: any) => Promise<void>\n): ReadableByteStream {\n  const stream: ReadableByteStream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller: ReadableByteStreamController = Object.create(ReadableByteStreamController.prototype);\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n\n  return stream;\n}\n\nfunction InitializeReadableStream(stream: ReadableStream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\n\nexport function IsReadableStream(x: unknown): x is ReadableStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return x instanceof ReadableStream;\n}\n\nexport function IsReadableStreamDisturbed(stream: ReadableStream): boolean {\n  assert(IsReadableStream(stream));\n\n  return stream._disturbed;\n}\n\nexport function IsReadableStreamLocked(stream: ReadableStream): boolean {\n  assert(IsReadableStream(stream));\n\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamCancel<R>(stream: ReadableStream<R>, reason: any): Promise<undefined> {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return promiseResolvedWith(undefined);\n  }\n  if (stream._state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  const reader = stream._reader;\n  if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n    const readIntoRequests = reader._readIntoRequests;\n    reader._readIntoRequests = new SimpleQueue();\n    readIntoRequests.forEach(readIntoRequest => {\n      readIntoRequest._closeSteps(undefined);\n    });\n  }\n\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n  return transformPromiseWith(sourceCancelPromise, noop);\n}\n\nexport function ReadableStreamClose<R>(stream: ReadableStream<R>): void {\n  assert(stream._state === 'readable');\n\n  stream._state = 'closed';\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return;\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n\n  if (IsReadableStreamDefaultReader<R>(reader)) {\n    const readRequests = reader._readRequests;\n    reader._readRequests = new SimpleQueue();\n    readRequests.forEach(readRequest => {\n      readRequest._closeSteps();\n    });\n  }\n}\n\nexport function ReadableStreamError<R>(stream: ReadableStream<R>, e: any): void {\n  assert(IsReadableStream(stream));\n  assert(stream._state === 'readable');\n\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return;\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n\n  if (IsReadableStreamDefaultReader<R>(reader)) {\n    ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n  } else {\n    assert(IsReadableStreamBYOBReader(reader));\n    ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n  }\n}\n\n// Readers\n\nexport type ReadableStreamReader<R> = ReadableStreamDefaultReader<R> | ReadableStreamBYOBReader;\n\nexport {\n  ReadableStreamDefaultReader,\n  ReadableStreamBYOBReader\n};\n\n// Controllers\n\nexport {\n  ReadableStreamDefaultController,\n  ReadableStreamBYOBRequest,\n  ReadableByteStreamController\n};\n\n// Helper functions for the ReadableStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n","import type { QueuingStrategyInit } from '../queuing-strategy';\nimport { assertDictionary, assertRequiredField, convertUnrestrictedDouble } from './basic';\n\nexport function convertQueuingStrategyInit(init: QueuingStrategyInit | null | undefined,\n                                           context: string): QueuingStrategyInit {\n  assertDictionary(init, context);\n  const highWaterMark = init?.highWaterMark;\n  assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n  return {\n    highWaterMark: convertUnrestrictedDouble(highWaterMark)\n  };\n}\n","import type { QueuingStrategy, QueuingStrategyInit } from './queuing-strategy';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategyInit } from './validators/queuing-strategy-init';\n\n// The size function must not have a prototype property nor be a constructor\nconst byteLengthSizeFunction = (chunk: ArrayBufferView): number => {\n  return chunk.byteLength;\n};\nsetFunctionName(byteLengthSizeFunction, 'size');\n\n/**\n * A queuing strategy that counts the number of bytes in each chunk.\n *\n * @public\n */\nexport default class ByteLengthQueuingStrategy implements QueuingStrategy<ArrayBufferView> {\n  /** @internal */\n  readonly _byteLengthQueuingStrategyHighWaterMark: number;\n\n  constructor(options: QueuingStrategyInit) {\n    assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n    options = convertQueuingStrategyInit(options, 'First parameter');\n    this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n  }\n\n  /**\n   * Returns the high water mark provided to the constructor.\n   */\n  get highWaterMark(): number {\n    if (!IsByteLengthQueuingStrategy(this)) {\n      throw byteLengthBrandCheckException('highWaterMark');\n    }\n    return this._byteLengthQueuingStrategyHighWaterMark;\n  }\n\n  /**\n   * Measures the size of `chunk` by returning the value of its `byteLength` property.\n   */\n  get size(): (chunk: ArrayBufferView) => number {\n    if (!IsByteLengthQueuingStrategy(this)) {\n      throw byteLengthBrandCheckException('size');\n    }\n    return byteLengthSizeFunction;\n  }\n}\n\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, {\n  highWaterMark: { enumerable: true },\n  size: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {\n    value: 'ByteLengthQueuingStrategy',\n    configurable: true\n  });\n}\n\n// Helper functions for the ByteLengthQueuingStrategy.\n\nfunction byteLengthBrandCheckException(name: string): TypeError {\n  return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n}\n\nexport function IsByteLengthQueuingStrategy(x: any): x is ByteLengthQueuingStrategy {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n    return false;\n  }\n\n  return x instanceof ByteLengthQueuingStrategy;\n}\n","import type { QueuingStrategy, QueuingStrategyInit } from './queuing-strategy';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategyInit } from './validators/queuing-strategy-init';\n\n// The size function must not have a prototype property nor be a constructor\nconst countSizeFunction = (): 1 => {\n  return 1;\n};\nsetFunctionName(countSizeFunction, 'size');\n\n/**\n * A queuing strategy that counts the number of chunks.\n *\n * @public\n */\nexport default class CountQueuingStrategy implements QueuingStrategy<any> {\n  /** @internal */\n  readonly _countQueuingStrategyHighWaterMark!: number;\n\n  constructor(options: QueuingStrategyInit) {\n    assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n    options = convertQueuingStrategyInit(options, 'First parameter');\n    this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n  }\n\n  /**\n   * Returns the high water mark provided to the constructor.\n   */\n  get highWaterMark(): number {\n    if (!IsCountQueuingStrategy(this)) {\n      throw countBrandCheckException('highWaterMark');\n    }\n    return this._countQueuingStrategyHighWaterMark;\n  }\n\n  /**\n   * Measures the size of `chunk` by always returning 1.\n   * This ensures that the total queue size is a count of the number of chunks in the queue.\n   */\n  get size(): (chunk: any) => 1 {\n    if (!IsCountQueuingStrategy(this)) {\n      throw countBrandCheckException('size');\n    }\n    return countSizeFunction;\n  }\n}\n\nObject.defineProperties(CountQueuingStrategy.prototype, {\n  highWaterMark: { enumerable: true },\n  size: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {\n    value: 'CountQueuingStrategy',\n    configurable: true\n  });\n}\n\n// Helper functions for the CountQueuingStrategy.\n\nfunction countBrandCheckException(name: string): TypeError {\n  return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n}\n\nexport function IsCountQueuingStrategy(x: any): x is CountQueuingStrategy {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n    return false;\n  }\n\n  return x instanceof CountQueuingStrategy;\n}\n","import { assertDictionary, assertFunction } from './basic';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\nimport type {\n  Transformer,\n  TransformerCancelCallback,\n  TransformerFlushCallback,\n  TransformerStartCallback,\n  TransformerTransformCallback,\n  ValidatedTransformer\n} from '../transform-stream/transformer';\nimport { TransformStreamDefaultController } from '../transform-stream';\n\nexport function convertTransformer<I, O>(original: Transformer<I, O> | null,\n                                         context: string): ValidatedTransformer<I, O> {\n  assertDictionary(original, context);\n  const cancel = original?.cancel;\n  const flush = original?.flush;\n  const readableType = original?.readableType;\n  const start = original?.start;\n  const transform = original?.transform;\n  const writableType = original?.writableType;\n  return {\n    cancel: cancel === undefined ?\n      undefined :\n      convertTransformerCancelCallback(cancel, original!, `${context} has member 'cancel' that`),\n    flush: flush === undefined ?\n      undefined :\n      convertTransformerFlushCallback(flush, original!, `${context} has member 'flush' that`),\n    readableType,\n    start: start === undefined ?\n      undefined :\n      convertTransformerStartCallback(start, original!, `${context} has member 'start' that`),\n    transform: transform === undefined ?\n      undefined :\n      convertTransformerTransformCallback(transform, original!, `${context} has member 'transform' that`),\n    writableType\n  };\n}\n\nfunction convertTransformerFlushCallback<I, O>(\n  fn: TransformerFlushCallback<O>,\n  original: Transformer<I, O>,\n  context: string\n): (controller: TransformStreamDefaultController<O>) => Promise<void> {\n  assertFunction(fn, context);\n  return (controller: TransformStreamDefaultController<O>) => promiseCall(fn, original, [controller]);\n}\n\nfunction convertTransformerStartCallback<I, O>(\n  fn: TransformerStartCallback<O>,\n  original: Transformer<I, O>,\n  context: string\n): TransformerStartCallback<O> {\n  assertFunction(fn, context);\n  return (controller: TransformStreamDefaultController<O>) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertTransformerTransformCallback<I, O>(\n  fn: TransformerTransformCallback<I, O>,\n  original: Transformer<I, O>,\n  context: string\n): (chunk: I, controller: TransformStreamDefaultController<O>) => Promise<void> {\n  assertFunction(fn, context);\n  return (chunk: I, controller: TransformStreamDefaultController<O>) => promiseCall(fn, original, [chunk, controller]);\n}\n\nfunction convertTransformerCancelCallback<I, O>(\n  fn: TransformerCancelCallback,\n  original: Transformer<I, O>,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n","import assert from '../stub/assert';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  transformPromiseWith,\n  uponPromise\n} from './helpers/webidl';\nimport { CreateReadableStream, type DefaultReadableStream, ReadableStream } from './readable-stream';\nimport {\n  ReadableStreamDefaultControllerCanCloseOrEnqueue,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize,\n  ReadableStreamDefaultControllerHasBackpressure\n} from './readable-stream/default-controller';\nimport type { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { CreateWritableStream, WritableStream, WritableStreamDefaultControllerErrorIfNeeded } from './writable-stream';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport type {\n  Transformer,\n  TransformerCancelCallback,\n  TransformerFlushCallback,\n  TransformerStartCallback,\n  TransformerTransformCallback,\n  ValidatedTransformer\n} from './transform-stream/transformer';\nimport { convertTransformer } from './validators/transformer';\n\n// Class TransformStream\n\n/**\n * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n * made available for reading from the readable side.\n *\n * @public\n */\nexport class TransformStream<I = any, O = any> {\n  /** @internal */\n  _writable!: WritableStream<I>;\n  /** @internal */\n  _readable!: DefaultReadableStream<O>;\n  /** @internal */\n  _backpressure!: boolean;\n  /** @internal */\n  _backpressureChangePromise!: Promise<void>;\n  /** @internal */\n  _backpressureChangePromise_resolve!: () => void;\n  /** @internal */\n  _transformStreamController!: TransformStreamDefaultController<O>;\n\n  constructor(\n    transformer?: Transformer<I, O>,\n    writableStrategy?: QueuingStrategy<I>,\n    readableStrategy?: QueuingStrategy<O>\n  );\n  constructor(rawTransformer: Transformer<I, O> | null | undefined = {},\n              rawWritableStrategy: QueuingStrategy<I> | null | undefined = {},\n              rawReadableStrategy: QueuingStrategy<O> | null | undefined = {}) {\n    if (rawTransformer === undefined) {\n      rawTransformer = null;\n    }\n\n    const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n    const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n\n    const transformer = convertTransformer(rawTransformer, 'First parameter');\n    if (transformer.readableType !== undefined) {\n      throw new RangeError('Invalid readableType specified');\n    }\n    if (transformer.writableType !== undefined) {\n      throw new RangeError('Invalid writableType specified');\n    }\n\n    const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n    const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n    const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n    const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n\n    let startPromise_resolve!: (value: void | PromiseLike<void>) => void;\n    const startPromise = newPromise<void>(resolve => {\n      startPromise_resolve = resolve;\n    });\n\n    InitializeTransformStream(\n      this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm\n    );\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n\n    if (transformer.start !== undefined) {\n      startPromise_resolve(transformer.start(this._transformStreamController));\n    } else {\n      startPromise_resolve(undefined);\n    }\n  }\n\n  /**\n   * The readable side of the transform stream.\n   */\n  get readable(): ReadableStream<O> {\n    if (!IsTransformStream(this)) {\n      throw streamBrandCheckException('readable');\n    }\n\n    return this._readable;\n  }\n\n  /**\n   * The writable side of the transform stream.\n   */\n  get writable(): WritableStream<I> {\n    if (!IsTransformStream(this)) {\n      throw streamBrandCheckException('writable');\n    }\n\n    return this._writable;\n  }\n}\n\nObject.defineProperties(TransformStream.prototype, {\n  readable: { enumerable: true },\n  writable: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {\n    value: 'TransformStream',\n    configurable: true\n  });\n}\n\nexport type {\n  Transformer,\n  TransformerCancelCallback,\n  TransformerStartCallback,\n  TransformerFlushCallback,\n  TransformerTransformCallback\n};\n\n// Transform Stream Abstract Operations\n\nexport function CreateTransformStream<I, O>(startAlgorithm: () => void | PromiseLike<void>,\n                                            transformAlgorithm: (chunk: I) => Promise<void>,\n                                            flushAlgorithm: () => Promise<void>,\n                                            cancelAlgorithm: (reason: any) => Promise<void>,\n                                            writableHighWaterMark = 1,\n                                            writableSizeAlgorithm: QueuingStrategySizeCallback<I> = () => 1,\n                                            readableHighWaterMark = 0,\n                                            readableSizeAlgorithm: QueuingStrategySizeCallback<O> = () => 1) {\n  assert(IsNonNegativeNumber(writableHighWaterMark));\n  assert(IsNonNegativeNumber(readableHighWaterMark));\n\n  const stream: TransformStream<I, O> = Object.create(TransformStream.prototype);\n\n  let startPromise_resolve!: (value: void | PromiseLike<void>) => void;\n  const startPromise = newPromise<void>(resolve => {\n    startPromise_resolve = resolve;\n  });\n\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                            readableSizeAlgorithm);\n\n  const controller: TransformStreamDefaultController<O> = Object.create(TransformStreamDefaultController.prototype);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);\n\n  const startResult = startAlgorithm();\n  startPromise_resolve(startResult);\n  return stream;\n}\n\nfunction InitializeTransformStream<I, O>(stream: TransformStream<I, O>,\n                                         startPromise: Promise<void>,\n                                         writableHighWaterMark: number,\n                                         writableSizeAlgorithm: QueuingStrategySizeCallback<I>,\n                                         readableHighWaterMark: number,\n                                         readableSizeAlgorithm: QueuingStrategySizeCallback<O>) {\n  function startAlgorithm(): Promise<void> {\n    return startPromise;\n  }\n\n  function writeAlgorithm(chunk: I): Promise<void> {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n\n  function abortAlgorithm(reason: any): Promise<void> {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n\n  function closeAlgorithm(): Promise<void> {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\n                                          writableHighWaterMark, writableSizeAlgorithm);\n\n  function pullAlgorithm(): Promise<void> {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n\n  function cancelAlgorithm(reason: any): Promise<void> {\n    return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);\n  }\n\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\n                                          readableSizeAlgorithm);\n\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  stream._backpressure = undefined!;\n  stream._backpressureChangePromise = undefined!;\n  stream._backpressureChangePromise_resolve = undefined!;\n  TransformStreamSetBackpressure(stream, true);\n\n  stream._transformStreamController = undefined!;\n}\n\nfunction IsTransformStream(x: unknown): x is TransformStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return x instanceof TransformStream;\n}\n\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream: TransformStream, e: any) {\n  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\n\nfunction TransformStreamErrorWritableAndUnblockWrite(stream: TransformStream, e: any) {\n  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n  TransformStreamUnblockWrite(stream);\n}\n\nfunction TransformStreamUnblockWrite(stream: TransformStream) {\n  if (stream._backpressure) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\n\nfunction TransformStreamSetBackpressure(stream: TransformStream, backpressure: boolean) {\n  // Passes also when called during construction.\n  assert(stream._backpressure !== backpressure);\n\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n\n  stream._backpressureChangePromise = newPromise(resolve => {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n\n  stream._backpressure = backpressure;\n}\n\n// Class TransformStreamDefaultController\n\n/**\n * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n *\n * @public\n */\nexport class TransformStreamDefaultController<O> {\n  /** @internal */\n  _controlledTransformStream: TransformStream<any, O>;\n  /** @internal */\n  _finishPromise: Promise<undefined> | undefined;\n  /** @internal */\n  _finishPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _finishPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _transformAlgorithm: (chunk: any) => Promise<void>;\n  /** @internal */\n  _flushAlgorithm: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.\n   */\n  get desiredSize(): number | null {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n  }\n\n  /**\n   * Enqueues the given chunk `chunk` in the readable side of the controlled transform stream.\n   */\n  enqueue(chunk: O): void;\n  enqueue(chunk: O = undefined!): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors both the readable side and the writable side of the controlled transform stream, making all future\n   * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n   */\n  error(reason: any = undefined): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    TransformStreamDefaultControllerError(this, reason);\n  }\n\n  /**\n   * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n   * transformer only needs to consume a portion of the chunks written to the writable side.\n   */\n  terminate(): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('terminate');\n    }\n\n    TransformStreamDefaultControllerTerminate(this);\n  }\n}\n\nObject.defineProperties(TransformStreamDefaultController.prototype, {\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  terminate: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nsetFunctionName(TransformStreamDefaultController.prototype.enqueue, 'enqueue');\nsetFunctionName(TransformStreamDefaultController.prototype.error, 'error');\nsetFunctionName(TransformStreamDefaultController.prototype.terminate, 'terminate');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'TransformStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Transform Stream Default Controller Abstract Operations\n\nfunction IsTransformStreamDefaultController<O = any>(x: any): x is TransformStreamDefaultController<O> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return x instanceof TransformStreamDefaultController;\n}\n\nfunction SetUpTransformStreamDefaultController<I, O>(stream: TransformStream<I, O>,\n                                                     controller: TransformStreamDefaultController<O>,\n                                                     transformAlgorithm: (chunk: I) => Promise<void>,\n                                                     flushAlgorithm: () => Promise<void>,\n                                                     cancelAlgorithm: (reason: any) => Promise<void>) {\n  assert(IsTransformStream(stream));\n  assert(stream._transformStreamController === undefined);\n\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._finishPromise = undefined;\n  controller._finishPromise_resolve = undefined;\n  controller._finishPromise_reject = undefined;\n}\n\nfunction SetUpTransformStreamDefaultControllerFromTransformer<I, O>(stream: TransformStream<I, O>,\n                                                                    transformer: ValidatedTransformer<I, O>) {\n  const controller: TransformStreamDefaultController<O> = Object.create(TransformStreamDefaultController.prototype);\n\n  let transformAlgorithm: (chunk: I) => Promise<void>;\n  let flushAlgorithm: () => Promise<void>;\n  let cancelAlgorithm: (reason: any) => Promise<void>;\n\n  if (transformer.transform !== undefined) {\n    transformAlgorithm = chunk => transformer.transform!(chunk, controller);\n  } else {\n    transformAlgorithm = chunk => {\n      try {\n        TransformStreamDefaultControllerEnqueue(controller, chunk as unknown as O);\n        return promiseResolvedWith(undefined);\n      } catch (transformResultE) {\n        return promiseRejectedWith(transformResultE);\n      }\n    };\n  }\n\n  if (transformer.flush !== undefined) {\n    flushAlgorithm = () => transformer.flush!(controller);\n  } else {\n    flushAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  if (transformer.cancel !== undefined) {\n    cancelAlgorithm = reason => transformer.cancel!(reason);\n  } else {\n    cancelAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);\n}\n\nfunction TransformStreamDefaultControllerClearAlgorithms(controller: TransformStreamDefaultController<any>) {\n  controller._transformAlgorithm = undefined!;\n  controller._flushAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n}\n\nfunction TransformStreamDefaultControllerEnqueue<O>(controller: TransformStreamDefaultController<O>, chunk: O) {\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n    throw new TypeError('Readable side is not in a state that permits enqueue');\n  }\n\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n\n  try {\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n\n    throw stream._readable._storedError;\n  }\n\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream._backpressure) {\n    assert(backpressure);\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\n\nfunction TransformStreamDefaultControllerError(controller: TransformStreamDefaultController<any>, e: any) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\n\nfunction TransformStreamDefaultControllerPerformTransform<I, O>(controller: TransformStreamDefaultController<O>,\n                                                                chunk: I) {\n  const transformPromise = controller._transformAlgorithm(chunk);\n  return transformPromiseWith(transformPromise, undefined, r => {\n    TransformStreamError(controller._controlledTransformStream, r);\n    throw r;\n  });\n}\n\nfunction TransformStreamDefaultControllerTerminate<O>(controller: TransformStreamDefaultController<O>) {\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n\n  ReadableStreamDefaultControllerClose(readableController);\n\n  const error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n\n// TransformStreamDefaultSink Algorithms\n\nfunction TransformStreamDefaultSinkWriteAlgorithm<I, O>(stream: TransformStream<I, O>, chunk: I): Promise<void> {\n  assert(stream._writable._state === 'writable');\n\n  const controller = stream._transformStreamController;\n\n  if (stream._backpressure) {\n    const backpressureChangePromise = stream._backpressureChangePromise;\n    assert(backpressureChangePromise !== undefined);\n    return transformPromiseWith(backpressureChangePromise, () => {\n      const writable = stream._writable;\n      const state = writable._state;\n      if (state === 'erroring') {\n        throw writable._storedError;\n      }\n      assert(state === 'writable');\n      return TransformStreamDefaultControllerPerformTransform<I, O>(controller, chunk);\n    });\n  }\n\n  return TransformStreamDefaultControllerPerformTransform<I, O>(controller, chunk);\n}\n\nfunction TransformStreamDefaultSinkAbortAlgorithm<I, O>(stream: TransformStream<I, O>, reason: any): Promise<void> {\n  const controller = stream._transformStreamController;\n  if (controller._finishPromise !== undefined) {\n    return controller._finishPromise;\n  }\n\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  // Assign the _finishPromise now so that if _cancelAlgorithm calls readable.cancel() internally,\n  // we don't run the _cancelAlgorithm again.\n  controller._finishPromise = newPromise((resolve, reject) => {\n    controller._finishPromise_resolve = resolve;\n    controller._finishPromise_reject = reject;\n  });\n\n  const cancelPromise = controller._cancelAlgorithm(reason);\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  uponPromise(cancelPromise, () => {\n    if (readable._state === 'errored') {\n      defaultControllerFinishPromiseReject(controller, readable._storedError);\n    } else {\n      ReadableStreamDefaultControllerError(readable._readableStreamController, reason);\n      defaultControllerFinishPromiseResolve(controller);\n    }\n    return null;\n  }, r => {\n    ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n    defaultControllerFinishPromiseReject(controller, r);\n    return null;\n  });\n\n  return controller._finishPromise;\n}\n\nfunction TransformStreamDefaultSinkCloseAlgorithm<I, O>(stream: TransformStream<I, O>): Promise<void> {\n  const controller = stream._transformStreamController;\n  if (controller._finishPromise !== undefined) {\n    return controller._finishPromise;\n  }\n\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  // Assign the _finishPromise now so that if _flushAlgorithm calls readable.cancel() internally,\n  // we don't also run the _cancelAlgorithm.\n  controller._finishPromise = newPromise((resolve, reject) => {\n    controller._finishPromise_resolve = resolve;\n    controller._finishPromise_reject = reject;\n  });\n\n  const flushPromise = controller._flushAlgorithm();\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  uponPromise(flushPromise, () => {\n    if (readable._state === 'errored') {\n      defaultControllerFinishPromiseReject(controller, readable._storedError);\n    } else {\n      ReadableStreamDefaultControllerClose(readable._readableStreamController);\n      defaultControllerFinishPromiseResolve(controller);\n    }\n    return null;\n  }, r => {\n    ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n    defaultControllerFinishPromiseReject(controller, r);\n    return null;\n  });\n\n  return controller._finishPromise;\n}\n\n// TransformStreamDefaultSource Algorithms\n\nfunction TransformStreamDefaultSourcePullAlgorithm(stream: TransformStream): Promise<void> {\n  // Invariant. Enforced by the promises returned by start() and pull().\n  assert(stream._backpressure);\n\n  assert(stream._backpressureChangePromise !== undefined);\n\n  TransformStreamSetBackpressure(stream, false);\n\n  // Prevent the next pull() call until there is backpressure.\n  return stream._backpressureChangePromise;\n}\n\nfunction TransformStreamDefaultSourceCancelAlgorithm<I, O>(stream: TransformStream<I, O>, reason: any): Promise<void> {\n  const controller = stream._transformStreamController;\n  if (controller._finishPromise !== undefined) {\n    return controller._finishPromise;\n  }\n\n  // stream._writable cannot change after construction, so caching it across a call to user code is safe.\n  const writable = stream._writable;\n\n  // Assign the _finishPromise now so that if _flushAlgorithm calls writable.abort() or\n  // writable.cancel() internally, we don't run the _cancelAlgorithm again, or also run the\n  // _flushAlgorithm.\n  controller._finishPromise = newPromise((resolve, reject) => {\n    controller._finishPromise_resolve = resolve;\n    controller._finishPromise_reject = reject;\n  });\n\n  const cancelPromise = controller._cancelAlgorithm(reason);\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  uponPromise(cancelPromise, () => {\n    if (writable._state === 'errored') {\n      defaultControllerFinishPromiseReject(controller, writable._storedError);\n    } else {\n      WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);\n      TransformStreamUnblockWrite(stream);\n      defaultControllerFinishPromiseResolve(controller);\n    }\n    return null;\n  }, r => {\n    WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r);\n    TransformStreamUnblockWrite(stream);\n    defaultControllerFinishPromiseReject(controller, r);\n    return null;\n  });\n\n  return controller._finishPromise;\n}\n\n// Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n\nexport function defaultControllerFinishPromiseResolve(controller: TransformStreamDefaultController<any>) {\n  if (controller._finishPromise_resolve === undefined) {\n    return;\n  }\n\n  controller._finishPromise_resolve();\n  controller._finishPromise_resolve = undefined;\n  controller._finishPromise_reject = undefined;\n}\n\nexport function defaultControllerFinishPromiseReject(controller: TransformStreamDefaultController<any>, reason: any) {\n  if (controller._finishPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(controller._finishPromise!);\n  controller._finishPromise_reject(reason);\n  controller._finishPromise_resolve = undefined;\n  controller._finishPromise_reject = undefined;\n}\n\n// Helper functions for the TransformStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n","/* c8 ignore start */\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\nif (!globalThis.ReadableStream) {\n  // `node:stream/web` got introduced in v16.5.0 as experimental\n  // and it's preferred over the polyfilled version. So we also\n  // suppress the warning that gets emitted by NodeJS for using it.\n  try {\n    const process = require('node:process')\n    const { emitWarning } = process\n    try {\n      process.emitWarning = () => {}\n      Object.assign(globalThis, require('node:stream/web'))\n      process.emitWarning = emitWarning\n    } catch (error) {\n      process.emitWarning = emitWarning\n      throw error\n    }\n  } catch (error) {\n    // fallback to polyfill implementation\n    Object.assign(globalThis, require('web-streams-polyfill/dist/ponyfill.es2018.js'))\n  }\n}\n\ntry {\n  // Don't use node: prefix for this, require+node: is not supported until node v14.14\n  // Only `import()` can use prefix in 12.20 and later\n  const { Blob } = require('buffer')\n  if (Blob && !Blob.prototype.stream) {\n    Blob.prototype.stream = function name (params) {\n      let position = 0\n      const blob = this\n\n      return new ReadableStream({\n        type: 'bytes',\n        async pull (ctrl) {\n          const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE))\n          const buffer = await chunk.arrayBuffer()\n          position += buffer.byteLength\n          ctrl.enqueue(new Uint8Array(buffer))\n\n          if (position === blob.size) {\n            ctrl.close()\n          }\n        }\n      })\n    }\n  }\n} catch (error) {}\n/* c8 ignore end */\n","/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs'\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\n/** @param {(Blob | Uint8Array)[]} parts */\nasync function * toIterator (parts, clone = true) {\n  for (const part of parts) {\n    if ('stream' in part) {\n      yield * (/** @type {AsyncIterableIterator<Uint8Array>} */ (part.stream()))\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        let position = part.byteOffset\n        const end = part.byteOffset + part.byteLength\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE)\n          const chunk = part.buffer.slice(position, position + size)\n          position += chunk.byteLength\n          yield new Uint8Array(chunk)\n        }\n      } else {\n        yield part\n      }\n    /* c8 ignore next 10 */\n    } else {\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n      let position = 0, b = (/** @type {Blob} */ (part))\n      while (position !== b.size) {\n        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE))\n        const buffer = await chunk.arrayBuffer()\n        position += buffer.byteLength\n        yield new Uint8Array(buffer)\n      }\n    }\n  }\n}\n\nconst _Blob = class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n  #parts = []\n  #type = ''\n  #size = 0\n  #endings = 'transparent'\n\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */\n  constructor (blobParts = [], options = {}) {\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.')\n    }\n\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.')\n    }\n\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.')\n    }\n\n    if (options === null) options = {}\n\n    const encoder = new TextEncoder()\n    for (const element of blobParts) {\n      let part\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength))\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0))\n      } else if (element instanceof Blob) {\n        part = element\n      } else {\n        part = encoder.encode(`${element}`)\n      }\n\n      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size\n      this.#parts.push(part)\n    }\n\n    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`\n    const type = options.type === undefined ? '' : String(options.type)\n    this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : ''\n  }\n\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n  get size () {\n    return this.#size\n  }\n\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n  get type () {\n    return this.#type\n  }\n\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n  async text () {\n    // More optimized than using this.arrayBuffer()\n    // that requires twice as much ram\n    const decoder = new TextDecoder()\n    let str = ''\n    for await (const part of toIterator(this.#parts, false)) {\n      str += decoder.decode(part, { stream: true })\n    }\n    // Remaining\n    str += decoder.decode()\n    return str\n  }\n\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n  async arrayBuffer () {\n    // Easier way... Just a unnecessary overhead\n    // const view = new Uint8Array(this.size);\n    // await this.stream().getReader({mode: 'byob'}).read(view);\n    // return view.buffer;\n\n    const data = new Uint8Array(this.size)\n    let offset = 0\n    for await (const chunk of toIterator(this.#parts, false)) {\n      data.set(chunk, offset)\n      offset += chunk.length\n    }\n\n    return data.buffer\n  }\n\n  stream () {\n    const it = toIterator(this.#parts, true)\n\n    return new globalThis.ReadableStream({\n      // @ts-ignore\n      type: 'bytes',\n      async pull (ctrl) {\n        const chunk = await it.next()\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value)\n      },\n\n      async cancel () {\n        await it.return()\n      }\n    })\n  }\n\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n  slice (start = 0, end = this.size, type = '') {\n    const { size } = this\n\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size)\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size)\n\n    const span = Math.max(relativeEnd - relativeStart, 0)\n    const parts = this.#parts\n    const blobParts = []\n    let added = 0\n\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break\n      }\n\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size\n        relativeEnd -= size\n      } else {\n        let chunk\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.byteLength\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.size\n        }\n        relativeEnd -= size\n        blobParts.push(chunk)\n        relativeStart = 0 // All next sequential parts should start at 0\n      }\n    }\n\n    const blob = new Blob([], { type: String(type).toLowerCase() })\n    blob.#size = span\n    blob.#parts = blobParts\n\n    return blob\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return (\n      object &&\n      typeof object === 'object' &&\n      typeof object.constructor === 'function' &&\n      (\n        typeof object.stream === 'function' ||\n        typeof object.arrayBuffer === 'function'\n      ) &&\n      /^(Blob|File)$/.test(object[Symbol.toStringTag])\n    )\n  }\n}\n\nObject.defineProperties(_Blob.prototype, {\n  size: { enumerable: true },\n  type: { enumerable: true },\n  slice: { enumerable: true }\n})\n\n/** @type {typeof globalThis.Blob} */\nexport const Blob = _Blob\nexport default Blob\n","import Blob from './index.js'\n\nconst _File = class File extends Blob {\n  #lastModified = 0\n  #name = ''\n\n  /**\n   * @param {*[]} fileBits\n   * @param {string} fileName\n   * @param {{lastModified?: number, type?: string}} options\n   */// @ts-ignore\n  constructor (fileBits, fileName, options = {}) {\n    if (arguments.length < 2) {\n      throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`)\n    }\n    super(fileBits, options)\n\n    if (options === null) options = {}\n\n    // Simulate WebIDL type casting for NaN value in lastModified option.\n    const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified)\n    if (!Number.isNaN(lastModified)) {\n      this.#lastModified = lastModified\n    }\n\n    this.#name = String(fileName)\n  }\n\n  get name () {\n    return this.#name\n  }\n\n  get lastModified () {\n    return this.#lastModified\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'File'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return !!object && object instanceof Blob &&\n      /^(File)$/.test(object[Symbol.toStringTag])\n  }\n}\n\n/** @type {typeof globalThis.File} */// @ts-ignore\nexport const File = _File\nexport default File\n","/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\nimport C from 'fetch-blob'\nimport F from 'fetch-blob/file.js'\n\nvar {toStringTag:t,iterator:i,hasInstance:h}=Symbol,\nr=Math.random,\nm='append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(','),\nf=(a,b,c)=>(a+='',/^(Blob|File)$/.test(b && b[t])?[(c=c!==void 0?c+'':b[t]=='File'?b.name:'blob',a),b.name!==c||b[t]=='blob'?new F([b],c,b):b]:[a,b+'']),\ne=(c,f)=>(f?c:c.replace(/\\r?\\n|\\r/g,'\\r\\n')).replace(/\\n/g,'%0A').replace(/\\r/g,'%0D').replace(/\"/g,'%22'),\nx=(n, a, e)=>{if(a.length<e){throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`)}}\n\nexport const File = F\n\n/** @type {typeof globalThis.FormData} */\nexport const FormData = class FormData {\n#d=[];\nconstructor(...a){if(a.length)throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`)}\nget [t]() {return 'FormData'}\n[i](){return this.entries()}\nstatic [h](o) {return o&&typeof o==='object'&&o[t]==='FormData'&&!m.some(m=>typeof o[m]!='function')}\nappend(...a){x('append',arguments,2);this.#d.push(f(...a))}\ndelete(a){x('delete',arguments,1);a+='';this.#d=this.#d.filter(([b])=>b!==a)}\nget(a){x('get',arguments,1);a+='';for(var b=this.#d,l=b.length,c=0;c<l;c++)if(b[c][0]===a)return b[c][1];return null}\ngetAll(a,b){x('getAll',arguments,1);b=[];a+='';this.#d.forEach(c=>c[0]===a&&b.push(c[1]));return b}\nhas(a){x('has',arguments,1);a+='';return this.#d.some(b=>b[0]===a)}\nforEach(a,b){x('forEach',arguments,1);for(var [c,d]of this)a.call(b,d,c,this)}\nset(...a){x('set',arguments,2);var b=[],c=!0;a=f(...a);this.#d.forEach(d=>{d[0]===a[0]?c&&(c=!b.push(a)):b.push(d)});c&&b.push(a);this.#d=b}\n*entries(){yield*this.#d}\n*keys(){for(var[a]of this)yield a}\n*values(){for(var[,a]of this)yield a}}\n\n/** @param {FormData} F */\nexport function formDataToBlob (F,B=C){\nvar b=`${r()}${r()}`.replace(/\\./g, '').slice(-28).padStart(32, '-'),c=[],p=`--${b}\\r\\nContent-Disposition: form-data; name=\"`\nF.forEach((v,n)=>typeof v=='string'\n?c.push(p+e(n)+`\"\\r\\n\\r\\n${v.replace(/\\r(?!\\n)|(?<!\\r)\\n/g, '\\r\\n')}\\r\\n`)\n:c.push(p+e(n)+`\"; filename=\"${e(v.name, 1)}\"\\r\\nContent-Type: ${v.type||\"application/octet-stream\"}\\r\\n\\r\\n`, v, '\\r\\n'))\nc.push(`--${b}--`)\nreturn new B(c,{type:\"multipart/form-data; boundary=\"+b})}\n","/*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\nif (!globalThis.DOMException) {\n  try {\n    const { MessageChannel } = require('worker_threads'),\n    port = new MessageChannel().port1,\n    ab = new ArrayBuffer()\n    port.postMessage(ab, [ab, ab])\n  } catch (err) {\n    err.constructor.name === 'DOMException' && (\n      globalThis.DOMException = err.constructor\n    )\n  }\n}\n\nmodule.exports = globalThis.DOMException\n","import { statSync, createReadStream, promises as fs } from 'node:fs'\nimport { basename } from 'node:path'\nimport DOMException from 'node-domexception'\n\nimport File from './file.js'\nimport Blob from './index.js'\n\nconst { stat } = fs\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst blobFromSync = (path, type) => fromBlob(statSync(path), path, type)\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */\nconst blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */\nconst fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst fileFromSync = (path, type) => fromFile(statSync(path), path, type)\n\n// @ts-ignore\nconst fromBlob = (stat, path, type = '') => new Blob([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], { type })\n\n// @ts-ignore\nconst fromFile = (stat, path, type = '') => new File([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], basename(path), { type, lastModified: stat.mtimeMs })\n\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */\nclass BlobDataItem {\n  #path\n  #start\n\n  constructor (options) {\n    this.#path = options.path\n    this.#start = options.start\n    this.size = options.size\n    this.lastModified = options.lastModified\n  }\n\n  /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */\n  slice (start, end) {\n    return new BlobDataItem({\n      path: this.#path,\n      lastModified: this.lastModified,\n      size: end - start,\n      start: this.#start + start\n    })\n  }\n\n  async * stream () {\n    const { mtimeMs } = await stat(this.#path)\n    if (mtimeMs > this.lastModified) {\n      throw new DOMException('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError')\n    }\n    yield * createReadStream(this.#path, {\n      start: this.#start,\n      end: this.#start + this.size - 1\n    })\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n}\n\nexport default blobFromSync\nexport { File, Blob, blobFrom, blobFromSync, fileFrom, fileFromSync }\n","import {File} from 'fetch-blob/from.js';\nimport {FormData} from 'formdata-polyfill/esm.min.js';\n\nlet s = 0;\nconst S = {\n\tSTART_BOUNDARY: s++,\n\tHEADER_FIELD_START: s++,\n\tHEADER_FIELD: s++,\n\tHEADER_VALUE_START: s++,\n\tHEADER_VALUE: s++,\n\tHEADER_VALUE_ALMOST_DONE: s++,\n\tHEADERS_ALMOST_DONE: s++,\n\tPART_DATA_START: s++,\n\tPART_DATA: s++,\n\tEND: s++\n};\n\nlet f = 1;\nconst F = {\n\tPART_BOUNDARY: f,\n\tLAST_BOUNDARY: f *= 2\n};\n\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nconst lower = c => c | 0x20;\n\nconst noop = () => {};\n\nclass MultipartParser {\n\t/**\n\t * @param {string} boundary\n\t */\n\tconstructor(boundary) {\n\t\tthis.index = 0;\n\t\tthis.flags = 0;\n\n\t\tthis.onHeaderEnd = noop;\n\t\tthis.onHeaderField = noop;\n\t\tthis.onHeadersEnd = noop;\n\t\tthis.onHeaderValue = noop;\n\t\tthis.onPartBegin = noop;\n\t\tthis.onPartData = noop;\n\t\tthis.onPartEnd = noop;\n\n\t\tthis.boundaryChars = {};\n\n\t\tboundary = '\\r\\n--' + boundary;\n\t\tconst ui8a = new Uint8Array(boundary.length);\n\t\tfor (let i = 0; i < boundary.length; i++) {\n\t\t\tui8a[i] = boundary.charCodeAt(i);\n\t\t\tthis.boundaryChars[ui8a[i]] = true;\n\t\t}\n\n\t\tthis.boundary = ui8a;\n\t\tthis.lookbehind = new Uint8Array(this.boundary.length + 8);\n\t\tthis.state = S.START_BOUNDARY;\n\t}\n\n\t/**\n\t * @param {Uint8Array} data\n\t */\n\twrite(data) {\n\t\tlet i = 0;\n\t\tconst length_ = data.length;\n\t\tlet previousIndex = this.index;\n\t\tlet {lookbehind, boundary, boundaryChars, index, state, flags} = this;\n\t\tconst boundaryLength = this.boundary.length;\n\t\tconst boundaryEnd = boundaryLength - 1;\n\t\tconst bufferLength = data.length;\n\t\tlet c;\n\t\tlet cl;\n\n\t\tconst mark = name => {\n\t\t\tthis[name + 'Mark'] = i;\n\t\t};\n\n\t\tconst clear = name => {\n\t\t\tdelete this[name + 'Mark'];\n\t\t};\n\n\t\tconst callback = (callbackSymbol, start, end, ui8a) => {\n\t\t\tif (start === undefined || start !== end) {\n\t\t\t\tthis[callbackSymbol](ui8a && ui8a.subarray(start, end));\n\t\t\t}\n\t\t};\n\n\t\tconst dataCallback = (name, clear) => {\n\t\t\tconst markSymbol = name + 'Mark';\n\t\t\tif (!(markSymbol in this)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (clear) {\n\t\t\t\tcallback(name, this[markSymbol], i, data);\n\t\t\t\tdelete this[markSymbol];\n\t\t\t} else {\n\t\t\t\tcallback(name, this[markSymbol], data.length, data);\n\t\t\t\tthis[markSymbol] = 0;\n\t\t\t}\n\t\t};\n\n\t\tfor (i = 0; i < length_; i++) {\n\t\t\tc = data[i];\n\n\t\t\tswitch (state) {\n\t\t\t\tcase S.START_BOUNDARY:\n\t\t\t\t\tif (index === boundary.length - 2) {\n\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else if (c !== CR) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (index - 1 === boundary.length - 2) {\n\t\t\t\t\t\tif (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t} else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c !== boundary[index + 2]) {\n\t\t\t\t\t\tindex = -2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === boundary[index + 2]) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_FIELD_START:\n\t\t\t\t\tstate = S.HEADER_FIELD;\n\t\t\t\t\tmark('onHeaderField');\n\t\t\t\t\tindex = 0;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_FIELD:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tclear('onHeaderField');\n\t\t\t\t\t\tstate = S.HEADERS_ALMOST_DONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === COLON) {\n\t\t\t\t\t\tif (index === 1) {\n\t\t\t\t\t\t\t// empty header field\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdataCallback('onHeaderField', true);\n\t\t\t\t\t\tstate = S.HEADER_VALUE_START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcl = lower(c);\n\t\t\t\t\tif (cl < A || cl > Z) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_START:\n\t\t\t\t\tif (c === SPACE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tmark('onHeaderValue');\n\t\t\t\t\tstate = S.HEADER_VALUE;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_VALUE:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tdataCallback('onHeaderValue', true);\n\t\t\t\t\t\tcallback('onHeaderEnd');\n\t\t\t\t\t\tstate = S.HEADER_VALUE_ALMOST_DONE;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADERS_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback('onHeadersEnd');\n\t\t\t\t\tstate = S.PART_DATA_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.PART_DATA_START:\n\t\t\t\t\tstate = S.PART_DATA;\n\t\t\t\t\tmark('onPartData');\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.PART_DATA:\n\t\t\t\t\tpreviousIndex = index;\n\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t// boyer-moore derrived algorithm to safely skip non-boundary data\n\t\t\t\t\t\ti += boundaryEnd;\n\t\t\t\t\t\twhile (i < bufferLength && !(data[i] in boundaryChars)) {\n\t\t\t\t\t\t\ti += boundaryLength;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti -= boundaryEnd;\n\t\t\t\t\t\tc = data[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index < boundary.length) {\n\t\t\t\t\t\tif (boundary[index] === c) {\n\t\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\t\tdataCallback('onPartData', true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index === boundary.length) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\t\t// CR = part boundary\n\t\t\t\t\t\t\tflags |= F.PART_BOUNDARY;\n\t\t\t\t\t\t} else if (c === HYPHEN) {\n\t\t\t\t\t\t\t// HYPHEN = end boundary\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index - 1 === boundary.length) {\n\t\t\t\t\t\tif (flags & F.PART_BOUNDARY) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tif (c === LF) {\n\t\t\t\t\t\t\t\t// unset the PART_BOUNDARY flag\n\t\t\t\t\t\t\t\tflags &= ~F.PART_BOUNDARY;\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (flags & F.LAST_BOUNDARY) {\n\t\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\t// when matching a possible boundary, keep a lookbehind reference\n\t\t\t\t\t\t// in case it turns out to be a false lead\n\t\t\t\t\t\tlookbehind[index - 1] = c;\n\t\t\t\t\t} else if (previousIndex > 0) {\n\t\t\t\t\t\t// if our boundary turned out to be rubbish, the captured lookbehind\n\t\t\t\t\t\t// belongs to partData\n\t\t\t\t\t\tconst _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n\t\t\t\t\t\tcallback('onPartData', 0, previousIndex, _lookbehind);\n\t\t\t\t\t\tpreviousIndex = 0;\n\t\t\t\t\t\tmark('onPartData');\n\n\t\t\t\t\t\t// reconsider the current character even so it interrupted the sequence\n\t\t\t\t\t\t// it could be the beginning of a new sequence\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.END:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected state entered: ${state}`);\n\t\t\t}\n\t\t}\n\n\t\tdataCallback('onHeaderField');\n\t\tdataCallback('onHeaderValue');\n\t\tdataCallback('onPartData');\n\n\t\t// Update properties for the next call\n\t\tthis.index = index;\n\t\tthis.state = state;\n\t\tthis.flags = flags;\n\t}\n\n\tend() {\n\t\tif ((this.state === S.HEADER_FIELD_START && this.index === 0) ||\n\t\t\t(this.state === S.PART_DATA && this.index === this.boundary.length)) {\n\t\t\tthis.onPartEnd();\n\t\t} else if (this.state !== S.END) {\n\t\t\tthrow new Error('MultipartParser.end(): stream ended unexpectedly');\n\t\t}\n\t}\n}\n\nfunction _fileName(headerValue) {\n\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\tconst m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n\tif (!m) {\n\t\treturn;\n\t}\n\n\tconst match = m[2] || m[3] || '';\n\tlet filename = match.slice(match.lastIndexOf('\\\\') + 1);\n\tfilename = filename.replace(/%22/g, '\"');\n\tfilename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n\t\treturn String.fromCharCode(code);\n\t});\n\treturn filename;\n}\n\nexport async function toFormData(Body, ct) {\n\tif (!/multipart/i.test(ct)) {\n\t\tthrow new TypeError('Failed to fetch');\n\t}\n\n\tconst m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n\tif (!m) {\n\t\tthrow new TypeError('no or bad content-type header, no multipart boundary');\n\t}\n\n\tconst parser = new MultipartParser(m[1] || m[2]);\n\n\tlet headerField;\n\tlet headerValue;\n\tlet entryValue;\n\tlet entryName;\n\tlet contentType;\n\tlet filename;\n\tconst entryChunks = [];\n\tconst formData = new FormData();\n\n\tconst onPartData = ui8a => {\n\t\tentryValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tconst appendToFile = ui8a => {\n\t\tentryChunks.push(ui8a);\n\t};\n\n\tconst appendFileToFormData = () => {\n\t\tconst file = new File(entryChunks, filename, {type: contentType});\n\t\tformData.append(entryName, file);\n\t};\n\n\tconst appendEntryToFormData = () => {\n\t\tformData.append(entryName, entryValue);\n\t};\n\n\tconst decoder = new TextDecoder('utf-8');\n\tdecoder.decode();\n\n\tparser.onPartBegin = function () {\n\t\tparser.onPartData = onPartData;\n\t\tparser.onPartEnd = appendEntryToFormData;\n\n\t\theaderField = '';\n\t\theaderValue = '';\n\t\tentryValue = '';\n\t\tentryName = '';\n\t\tcontentType = '';\n\t\tfilename = null;\n\t\tentryChunks.length = 0;\n\t};\n\n\tparser.onHeaderField = function (ui8a) {\n\t\theaderField += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderValue = function (ui8a) {\n\t\theaderValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderEnd = function () {\n\t\theaderValue += decoder.decode();\n\t\theaderField = headerField.toLowerCase();\n\n\t\tif (headerField === 'content-disposition') {\n\t\t\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\t\t\tconst m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n\n\t\t\tif (m) {\n\t\t\t\tentryName = m[2] || m[3] || '';\n\t\t\t}\n\n\t\t\tfilename = _fileName(headerValue);\n\n\t\t\tif (filename) {\n\t\t\t\tparser.onPartData = appendToFile;\n\t\t\t\tparser.onPartEnd = appendFileToFormData;\n\t\t\t}\n\t\t} else if (headerField === 'content-type') {\n\t\t\tcontentType = headerValue;\n\t\t}\n\n\t\theaderValue = '';\n\t\theaderField = '';\n\t};\n\n\tfor await (const chunk of Body) {\n\t\tparser.write(chunk);\n\t}\n\n\tparser.end();\n\n\treturn formData;\n}\n","/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nmodule.exports = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n","/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = require('is-extglob');\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  var pipeIndex = -2;\n  var closeSquareIndex = -2;\n  var closeCurlyIndex = -2;\n  var closeParenIndex = -2;\n  var backSlashIndex = -2;\n  while (index < str.length) {\n    if (str[index] === '*') {\n      return true;\n    }\n\n    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n      return true;\n    }\n\n    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n      if (closeSquareIndex < index) {\n        closeSquareIndex = str.indexOf(']', index);\n      }\n      if (closeSquareIndex > index) {\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n      closeCurlyIndex = str.indexOf('}', index);\n      if (closeCurlyIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n      closeParenIndex = str.indexOf(')', index);\n      if (closeParenIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n      if (pipeIndex < index) {\n        pipeIndex = str.indexOf('|', index);\n      }\n      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n        closeParenIndex = str.indexOf(')', pipeIndex);\n        if (closeParenIndex > pipeIndex) {\n          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nvar relaxedCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  while (index < str.length) {\n    if (/[*?{}()[\\]]/.test(str[index])) {\n      return true;\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nmodule.exports = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var check = strictCheck;\n\n  // optionally relax check\n  if (options && options.strict === false) {\n    check = relaxedCheck;\n  }\n\n  return check(str);\n};\n","'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n","var balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m) return [str];\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  if (/\\$$/.test(m.pre)) {    \n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre+ '{' + m.body + '}' + post[k];\n      expansions.push(expansion);\n    }\n  } else {\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,.*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n      return [str];\n    }\n\n    var n;\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n        if (n.length === 1) {\n          return post.map(function(p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    var N;\n\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length)\n      var incr = n.length == 3\n        ? Math.abs(numeric(n[2]))\n        : 1;\n      var test = lte;\n      var reverse = y < x;\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n      var pad = n.some(isPadded);\n\n      N = [];\n\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\')\n            c = '';\n        } else {\n          c = String(i);\n          if (pad) {\n            var need = width - c.length;\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0)\n                c = '-' + z + c.slice(1);\n              else\n                c = z + c;\n            }\n          }\n        }\n        N.push(c);\n      }\n    } else {\n      N = [];\n\n      for (var j = 0; j < n.length; j++) {\n        N.push.apply(N, expand(n[j], false));\n      }\n    }\n\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion)\n          expansions.push(expansion);\n      }\n    }\n  }\n\n  return expansions;\n}\n\n","'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n","'use strict';\n\nconst util = require('./util');\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n  unpairedTags: []\n};\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function (xmlData, options) {\n  options = Object.assign({}, defaultOptions, options);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n  \n  for (let i = 0; i < xmlData.length; i++) {\n\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\n      i+=2;\n      i = readPI(xmlData,i);\n      if (i.err) return i;\n    }else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      \n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r'; i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\"+tagName+\"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\"+tagName+\"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag',\n                \"Expected closing tag '\"+otg.tagName+\"' (opened in line \"+openPos.line+\", col \"+openPos.col+\") instead of closing tag '\"+tagName+\"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else if(options.unpairedTags.indexOf(tagName) !== -1){\n            //don't push into stack\n          } else {\n            tags.push({tagName, tagStartPos});\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i+1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else{\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }else{\n            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n              return getErrorObject('InvalidXml', \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n            }\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if ( isWhiteSpace(xmlData[i])) {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\"+xmlData[i]+\"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  }else if (tags.length == 1) {\n      return getErrorObject('InvalidTag', \"Unclosed tag '\"+tags[0].tagName+\"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  }else if (tags.length > 0) {\n      return getErrorObject('InvalidXml', \"Invalid '\"+\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '')+\n          \"' found.\", {line: 1, col: 1});\n  }\n\n  return true;\n};\n\nfunction isWhiteSpace(char){\n  return char === ' ' || char === '\\t' || char === '\\n'  || char === '\\r';\n}\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' has no space in starting.\", getPositionFromMatch(matches[i]))\n    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' is without value.\", getPositionFromMatch(matches[i]));\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\"+matches[i][2]+\"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n\n  return true;\n}\n\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';')\n      return i;\n    if (!xmlData[i].match(re))\n      break;\n  }\n  return -1;\n}\n\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';')\n    return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20)\n      continue;\n    if (xmlData[i] === ';')\n      break;\n    return -1;\n  }\n  return i;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col,\n    },\n  };\n}\n\nfunction validateAttrName(attrName) {\n  return util.isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\n","\nconst defaultOptions = {\n    preserveOrder: false,\n    attributeNamePrefix: '@_',\n    attributesGroupName: false,\n    textNodeName: '#text',\n    ignoreAttributes: true,\n    removeNSPrefix: false, // remove NS from tag name or attribute name if true\n    allowBooleanAttributes: false, //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseTagValue: true,\n    parseAttributeValue: false,\n    trimValues: true, //Trim string values of tag and attributes\n    cdataPropName: false,\n    numberParseOptions: {\n      hex: true,\n      leadingZeros: true,\n      eNotation: true\n    },\n    tagValueProcessor: function(tagName, val) {\n      return val;\n    },\n    attributeValueProcessor: function(attrName, val) {\n      return val;\n    },\n    stopNodes: [], //nested tags will not be parsed even for errors\n    alwaysCreateTextNode: false,\n    isArray: () => false,\n    commentPropName: false,\n    unpairedTags: [],\n    processEntities: true,\n    htmlEntities: false,\n    ignoreDeclaration: false,\n    ignorePiTags: false,\n    transformTagName: false,\n    transformAttributeName: false,\n    updateTag: function(tagName, jPath, attrs){\n      return tagName\n    },\n    // skipEmptyListItem: false\n};\n   \nconst buildOptions = function(options) {\n    return Object.assign({}, defaultOptions, options);\n};\n\nexports.buildOptions = buildOptions;\nexports.defaultOptions = defaultOptions;","'use strict';\n\nclass XmlNode{\n  constructor(tagname) {\n    this.tagname = tagname;\n    this.child = []; //nested tags, text, cdata, comments in order\n    this[\":@\"] = {}; //attributes map\n  }\n  add(key,val){\n    // this.child.push( {name : key, val: val, isCdata: isCdata });\n    if(key === \"__proto__\") key = \"#__proto__\";\n    this.child.push( {[key]: val });\n  }\n  addChild(node) {\n    if(node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n    if(node[\":@\"] && Object.keys(node[\":@\"]).length > 0){\n      this.child.push( { [node.tagname]: node.child, [\":@\"]: node[\":@\"] });\n    }else{\n      this.child.push( { [node.tagname]: node.child });\n    }\n  };\n};\n\n\nmodule.exports = XmlNode;","const util = require('../util');\n\n//TODO: handle comments\nfunction readDocType(xmlData, i){\n    \n    const entities = {};\n    if( xmlData[i + 3] === 'O' &&\n         xmlData[i + 4] === 'C' &&\n         xmlData[i + 5] === 'T' &&\n         xmlData[i + 6] === 'Y' &&\n         xmlData[i + 7] === 'P' &&\n         xmlData[i + 8] === 'E')\n    {    \n        i = i+9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(;i<xmlData.length;i++){\n            if (xmlData[i] === '<' && !comment) { //Determine the tag type\n                if( hasBody && isEntity(xmlData, i)){\n                    i += 7; \n                    [entityName, val,i] = readEntityExp(xmlData,i+1);\n                    if(val.indexOf(\"&\") === -1) //Parameter entities are not supported\n                        entities[ validateEntityName(entityName) ] = {\n                            regx : RegExp( `&${entityName};`,\"g\"),\n                            val: val\n                        };\n                }\n                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported\n                else if( isComment)                         comment = true;\n                else                                        throw new Error(\"Invalid DOCTYPE\");\n\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === '>') { //Read tag content\n                if(comment){\n                    if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                }else{\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                  break;\n                }\n            }else if( xmlData[i] === '['){\n                hasBody = true;\n            }else{\n                exp += xmlData[i];\n            }\n        }\n        if(angleBracketsCount !== 0){\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    }else{\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {entities, i};\n}\n\nfunction readEntityExp(xmlData,i){\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n    \n    //read EntityName\n    let entityName = \"\";\n    for (; i < xmlData.length && (xmlData[i] !== \"'\" && xmlData[i] !== '\"' ); i++) {\n        // if(xmlData[i] === \" \") continue;\n        // else \n        entityName += xmlData[i];\n    }\n    entityName = entityName.trim();\n    if(entityName.indexOf(\" \") !== -1) throw new Error(\"External entites are not supported\");\n\n    //read Entity Value\n    const startChar = xmlData[i++];\n    let val = \"\"\n    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {\n        val += xmlData[i];\n    }\n    return [entityName, val, i];\n}\n\nfunction isComment(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === '-' &&\n    xmlData[i+3] === '-') return true\n    return false\n}\nfunction isEntity(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'N' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'I' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'Y') return true\n    return false\n}\nfunction isElement(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'L' &&\n    xmlData[i+4] === 'E' &&\n    xmlData[i+5] === 'M' &&\n    xmlData[i+6] === 'E' &&\n    xmlData[i+7] === 'N' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\n\nfunction isAttlist(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'A' &&\n    xmlData[i+3] === 'T' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'L' &&\n    xmlData[i+6] === 'I' &&\n    xmlData[i+7] === 'S' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\nfunction isNotation(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'N' &&\n    xmlData[i+3] === 'O' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'A' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'I' &&\n    xmlData[i+8] === 'O' &&\n    xmlData[i+9] === 'N') return true\n    return false\n}\n\nfunction validateEntityName(name){\n    if (util.isName(name))\n\treturn name;\n    else\n        throw new Error(`Invalid entity name ${name}`);\n}\n\nmodule.exports = readDocType;\n","const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/;\n// const octRegex = /0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n    Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n    Number.parseFloat = window.parseFloat;\n}\n\n  \nconst consider = {\n    hex :  true,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true\n    //skipLike: /regex/\n};\n\nfunction toNumber(str, options = {}){\n    // const options = Object.assign({}, consider);\n    // if(opt.leadingZeros === false){\n    //     options.leadingZeros = false;\n    // }else if(opt.hex === false){\n    //     options.hex = false;\n    // }\n\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    // if(trimmedStr === \"0.0\") return 0;\n    // else if(trimmedStr === \"+0.0\") return 0;\n    // else if(trimmedStr === \"-0.0\") return -0;\n\n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return Number.parseInt(trimmedStr, 16);\n    // } else if (options.parseOct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        if(match){\n            const sign = match[1];\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            //trim ending zeros for floating number\n            \n            const eNotation = match[4] || match[6];\n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const numStr = \"\" + num;\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(eNotation){ //given number has enotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    // const decimalPart = match[5].substr(1);\n                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf(\".\"));\n\n                    \n                    // const p = numStr.indexOf(\".\");\n                    // const givenIntPart = numStr.substr(0,p);\n                    // const givenDecPart = numStr.substr(p+1);\n                    if(numStr === \"0\" && (numTrimmedByZeros === \"\") ) return num; //0.0\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( sign && numStr === \"-\"+numTrimmedByZeros) return num;\n                    else return str;\n                }\n                \n                if(leadingZeros){\n                    // if(numTrimmedByZeros === numStr){\n                    //     if(options.leadingZeros) return num;\n                    //     else return str;\n                    // }else return str;\n                    if(numTrimmedByZeros === numStr) return num;\n                    else if(sign+numTrimmedByZeros === numStr) return num;\n                    else return str;\n                }\n\n                if(trimmedStr === numStr) return num;\n                else if(trimmedStr === sign+numStr) return num;\n                // else{\n                //     //number with +/- sign\n                //     trimmedStr.test(/[-+][0-9]);\n\n                // }\n                return str;\n            }\n            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;\n            \n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substr(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\nmodule.exports = toNumber\n","'use strict';\n///@ts-check\n\nconst util = require('../util');\nconst xmlNode = require('./xmlNode');\nconst readDocType = require(\"./DocTypeReader\");\nconst toNumber = require(\"strnum\");\n\n// const regx =\n//   '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n//   .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nclass OrderedObjParser{\n  constructor(options){\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n      \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n      \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n      \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n    };\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\n    this.htmlEntities = {\n      \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\" : { regex: /&(cent|#162);/g, val: \"¢\" },\n      \"pound\" : { regex: /&(pound|#163);/g, val: \"£\" },\n      \"yen\" : { regex: /&(yen|#165);/g, val: \"¥\" },\n      \"euro\" : { regex: /&(euro|#8364);/g, val: \"€\" },\n      \"copyright\" : { regex: /&(copy|#169);/g, val: \"©\" },\n      \"reg\" : { regex: /&(reg|#174);/g, val: \"®\" },\n      \"inr\" : { regex: /&(inr|#8377);/g, val: \"₹\" },\n      \"num_dec\": { regex: /&#([0-9]{1,7});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },\n      \"num_hex\": { regex: /&#x([0-9a-fA-F]{1,6});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 16)) },\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n    this.addChild = addChild;\n  }\n\n}\n\nfunction addExternalEntities(externalEntities){\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n       regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n       val : externalEntities[ent]\n    }\n  }\n}\n\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if(val.length > 0){\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\n      \n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if(newval === null || newval === undefined){\n        //don't parse\n        return val;\n      }else if(typeof newval !== typeof val || newval !== val){\n        //overwrite\n        return newval;\n      }else if(this.options.trimValues){\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      }else{\n        const trimmedVal = val.trim();\n        if(trimmedVal === val){\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        }else{\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n        if(aName === \"__proto__\") aName  = \"#__proto__\";\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if(newVal === null || newVal === undefined){\n            //don't parse\n            attrs[aName] = oldVal;\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\n            //overwrite\n            attrs[aName] = newVal;\n          }else{\n            //parse\n            attrs[aName] = parseValue(\n              oldVal,\n              this.options.parseAttributeValue,\n              this.options.numberParseOptions\n            );\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs\n  }\n}\n\nconst parseXml = function(xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\n    const ch = xmlData[i];\n    if(ch === '<'){\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(this.options.removeNSPrefix){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        if(this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        if(currentNode){\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        //check if last tag of nested tag was unpaired tag\n        const lastTagName = jPath.substring(jPath.lastIndexOf(\".\")+1);\n        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){\n          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n        }\n        let propIndex = 0\n        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){\n          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)\n          this.tagsNodeStack.pop();\n        }else{\n          propIndex = jPath.lastIndexOf(\".\");\n        }\n        jPath = jPath.substring(0, propIndex);\n\n        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n\n        let tagData = readTagExp(xmlData,i, false, \"?>\");\n        if(!tagData) throw new Error(\"Pi Tag is not closed.\");\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if( (this.options.ignoreDeclaration && tagData.tagName === \"?xml\") || this.options.ignorePiTags){\n\n        }else{\n  \n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          \n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n          }\n          this.addChild(currentNode, childNode, jPath)\n\n        }\n\n\n        i = tagData.closeIndex + 1;\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i+4, \"Comment is not closed.\")\n        if(this.options.commentPropName){\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\n        }\n        i = endIndex;\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const result = readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);\n        if(val == undefined) val = \"\";\n\n        //cdata should be set even if it is 0 length string\n        if(this.options.cdataPropName){\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\n        }else{\n          currentNode.add(this.options.textNodeName, val);\n        }\n        \n        i = closeIndex + 2;\n      }else {//Opening tag\n        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);\n        let tagName= result.tagName;\n        const rawTagName = result.rawTagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n        \n        //save text as child node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\n          currentNode = this.tagsNodeStack.pop();\n          jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n        }\n        if(tagName !== xmlObj.tagname){\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n          let tagContent = \"\";\n          //self-closing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            i = result.closeIndex;\n          }\n          //unpaired tag\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\n            i = result.closeIndex;\n          }\n          //normal tag\n          else{\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n\n          const childNode = new xmlNode(tagName);\n          if(tagName !== tagExp && attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n          }\n          if(tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          \n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          \n          this.addChild(currentNode, childNode, jPath)\n        }else{\n  //selfClosing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            \n            if(this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n\n            const childNode = new xmlNode(tagName);\n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          }\n    //opening tag\n          else{\n            const childNode = new xmlNode( tagName);\n            this.tagsNodeStack.push(currentNode);\n            \n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n}\n\nfunction addChild(currentNode, childNode, jPath){\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"])\n  if(result === false){\n  }else if(typeof result === \"string\"){\n    childNode.tagname = result\n    currentNode.addChild(childNode);\n  }else{\n    currentNode.addChild(childNode);\n  }\n}\n\nconst replaceEntitiesValue = function(val){\n\n  if(this.options.processEntities){\n    for(let entityName in this.docTypeEntities){\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace( entity.regx, entity.val);\n    }\n    for(let entityName in this.lastEntities){\n      const entity = this.lastEntities[entityName];\n      val = val.replace( entity.regex, entity.val);\n    }\n    if(this.options.htmlEntities){\n      for(let entityName in this.htmlEntities){\n        const entity = this.htmlEntities[entityName];\n        val = val.replace( entity.regex, entity.val);\n      }\n    }\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\n  }\n  return val;\n}\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) { //store previously collected data as textNode\n    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0\n    \n    textData = this.parseTextData(textData,\n      currentNode.tagname,\n      jPath,\n      false,\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n      isLeafNode);\n\n    if (textData !== undefined && textData !== \"\")\n      currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */\nfunction isItStopNode(stopNodes, jPath, currentTagName){\n  const allNodesExp = \"*.\" + currentTagName;\n  for (const stopNodePath in stopNodes) {\n    const stopNodeExp = stopNodes[stopNodePath];\n    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;\n  }\n  return false;\n}\n\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\"){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if(closingChar[1]){\n        if(xmlData[index + 1] === closingChar[1]){\n          return {\n            data: tagExp,\n            index: index\n          }\n        }\n      }else{\n        return {\n          data: tagExp,\n          index: index\n        }\n      }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \">\"){\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\n  if(!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if(separatorIndex !== -1){//separate tag name and attributes expression\n    tagName = tagExp.substring(0, separatorIndex);\n    tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n  }\n\n  const rawTagName = tagName;\n  if(removeNSPrefix){\n    const colonIndex = tagName.indexOf(\":\");\n    if(colonIndex !== -1){\n      tagName = tagName.substr(colonIndex+1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent,\n    rawTagName: rawTagName,\n  }\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\nfunction readStopNodeData(xmlData, tagName, i){\n  const startIndex = i;\n  // Starting at 1 since we already have an open tag\n  let openTagCount = 1;\n\n  for (; i < xmlData.length; i++) {\n    if( xmlData[i] === \"<\"){ \n      if (xmlData[i+1] === \"/\") {//close tag\n          const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\n          if(closeTagName === tagName){\n            openTagCount--;\n            if (openTagCount === 0) {\n              return {\n                tagContent: xmlData.substring(startIndex, i),\n                i : closeIndex\n              }\n            }\n          }\n          i=closeIndex;\n        } else if(xmlData[i+1] === '?') { \n          const closeIndex = findClosingIndex(xmlData, \"?>\", i+1, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \n          const closeIndex = findClosingIndex(xmlData, \"-->\", i+3, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 2) === '![') { \n          const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n          i=closeIndex;\n        } else {\n          const tagData = readTagExp(xmlData, i, '>')\n\n          if (tagData) {\n            const openTagName = tagData && tagData.tagName;\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \"/\") {\n              openTagCount++;\n            }\n            i=tagData.closeIndex;\n          }\n        }\n      }\n  }//end for loop\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n\nmodule.exports = OrderedObjParser;\n","'use strict';\n\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */\nfunction prettify(node, options){\n  return compress( node, options);\n}\n\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */\nfunction compress(arr, options, jPath){\n  let text;\n  const compressedObj = {};\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const property = propName(tagObj);\n    let newJpath = \"\";\n    if(jPath === undefined) newJpath = property;\n    else newJpath = jPath + \".\" + property;\n\n    if(property === options.textNodeName){\n      if(text === undefined) text = tagObj[property];\n      else text += \"\" + tagObj[property];\n    }else if(property === undefined){\n      continue;\n    }else if(tagObj[property]){\n      \n      let val = compress(tagObj[property], options, newJpath);\n      const isLeaf = isLeafTag(val, options);\n\n      if(tagObj[\":@\"]){\n        assignAttributes( val, tagObj[\":@\"], newJpath, options);\n      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){\n        val = val[options.textNodeName];\n      }else if(Object.keys(val).length === 0){\n        if(options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n        else val = \"\";\n      }\n\n      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n        if(!Array.isArray(compressedObj[property])) {\n            compressedObj[property] = [ compressedObj[property] ];\n        }\n        compressedObj[property].push(val);\n      }else{\n        //TODO: if a node is not an array, then check if it should be an array\n        //also determine if it is a leaf node\n        if (options.isArray(property, newJpath, isLeaf )) {\n          compressedObj[property] = [val];\n        }else{\n          compressedObj[property] = val;\n        }\n      }\n    }\n    \n  }\n  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n  if(typeof text === \"string\"){\n    if(text.length > 0) compressedObj[options.textNodeName] = text;\n  }else if(text !== undefined) compressedObj[options.textNodeName] = text;\n  return compressedObj;\n}\n\nfunction propName(obj){\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if(key !== \":@\") return key;\n  }\n}\n\nfunction assignAttributes(obj, attrMap, jpath, options){\n  if (attrMap) {\n    const keys = Object.keys(attrMap);\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      const atrrName = keys[i];\n      if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n        obj[atrrName] = [ attrMap[atrrName] ];\n      } else {\n        obj[atrrName] = attrMap[atrrName];\n      }\n    }\n  }\n}\n\nfunction isLeafTag(obj, options){\n  const { textNodeName } = options;\n  const propCount = Object.keys(obj).length;\n  \n  if (propCount === 0) {\n    return true;\n  }\n\n  if (\n    propCount === 1 &&\n    (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)\n  ) {\n    return true;\n  }\n\n  return false;\n}\nexports.prettify = prettify;\n","const { buildOptions} = require(\"./OptionsBuilder\");\nconst OrderedObjParser = require(\"./OrderedObjParser\");\nconst { prettify} = require(\"./node2json\");\nconst validator = require('../validator');\n\nclass XMLParser{\n    \n    constructor(options){\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n        \n    }\n    /**\n     * Parse XML dats to JS object \n     * @param {string|Buffer} xmlData \n     * @param {boolean|Object} validationOption \n     */\n    parse(xmlData,validationOption){\n        if(typeof xmlData === \"string\"){\n        }else if( xmlData.toString){\n            xmlData = xmlData.toString();\n        }else{\n            throw new Error(\"XML data is accepted in String or Bytes[] form.\")\n        }\n        if( validationOption){\n            if(validationOption === true) validationOption = {}; //validate with default options\n            \n            const result = validator.validate(xmlData, validationOption);\n            if (result !== true) {\n              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )\n            }\n          }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;\n        else return prettify(orderedResult, this.options);\n    }\n\n    /**\n     * Add Entity which is not by default supported by this library\n     * @param {string} key \n     * @param {string} value \n     */\n    addEntity(key, value){\n        if(value.indexOf(\"&\") !== -1){\n            throw new Error(\"Entity value can't have '&'\")\n        }else if(key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1){\n            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\")\n        }else if(value === \"&\"){\n            throw new Error(\"An entity with value '&' is not permitted\");\n        }else{\n            this.externalEntities[key] = value;\n        }\n    }\n}\n\nmodule.exports = XMLParser;","const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\n\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        if(tagName === undefined) continue;\n\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n\n    return xmlStr;\n}\n\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if(!obj.hasOwnProperty(key)) continue;\n        if (key !== \":@\") return key;\n    }\n}\n\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n            if(!attrMap.hasOwnProperty(attr)) continue;\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\nmodule.exports = toXml;\n","'use strict';\n//parse Empty Node as self closing node\nconst buildFromOrderedJs = require('./orderedJs2Xml');\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attributesGroupName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataPropName: false,\n  format: false,\n  indentBy: '  ',\n  suppressEmptyNode: false,\n  suppressUnpairedNode: true,\n  suppressBooleanAttributes: true,\n  tagValueProcessor: function(key, a) {\n    return a;\n  },\n  attributeValueProcessor: function(attrName, a) {\n    return a;\n  },\n  preserveOrder: false,\n  commentPropName: false,\n  unpairedTags: [],\n  entities: [\n    { regex: new RegExp(\"&\", \"g\"), val: \"&amp;\" },//it must be on top\n    { regex: new RegExp(\">\", \"g\"), val: \"&gt;\" },\n    { regex: new RegExp(\"<\", \"g\"), val: \"&lt;\" },\n    { regex: new RegExp(\"\\'\", \"g\"), val: \"&apos;\" },\n    { regex: new RegExp(\"\\\"\", \"g\"), val: \"&quot;\" }\n  ],\n  processEntities: true,\n  stopNodes: [],\n  // transformTagName: false,\n  // transformAttributeName: false,\n  oneListGroup: false\n};\n\nfunction Builder(options) {\n  this.options = Object.assign({}, defaultOptions, options);\n  if (this.options.ignoreAttributes || this.options.attributesGroupName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n\n  this.processTextOrObjNode = processTextOrObjNode\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n}\n\nBuilder.prototype.build = function(jObj) {\n  if(this.options.preserveOrder){\n    return buildFromOrderedJs(jObj, this.options);\n  }else {\n    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){\n      jObj = {\n        [this.options.arrayNodeName] : jObj\n      }\n    }\n    return this.j2x(jObj, 0).val;\n  }\n};\n\nBuilder.prototype.j2x = function(jObj, level) {\n  let attrStr = '';\n  let val = '';\n  for (let key in jObj) {\n    if(!Object.prototype.hasOwnProperty.call(jObj, key)) continue;\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node only if it is not an attribute\n      if (this.isAttribute(key)) {\n        val += '';\n      }\n    } else if (jObj[key] === null) {\n      // null attribute should be ignored by the attribute list, but should not cause the tag closing\n      if (this.isAttribute(key)) {\n        val += '';\n      } else if (key[0] === '?') {\n        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n      } else {\n        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n      }\n      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextValNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr) {\n        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);\n      }else {\n        //tag value\n        if (key === this.options.textNodeName) {\n          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);\n          val += this.replaceEntitiesValue(newval);\n        } else {\n          val += this.buildTextValNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      const arrLen = jObj[key].length;\n      let listTagVal = \"\";\n      for (let j = 0; j < arrLen; j++) {\n        const item = jObj[key][j];\n        if (typeof item === 'undefined') {\n          // supress undefined node\n        } else if (item === null) {\n          if(key[0] === \"?\") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n        } else if (typeof item === 'object') {\n          if(this.options.oneListGroup ){\n            listTagVal += this.j2x(item, level + 1).val;\n          }else{\n            listTagVal += this.processTextOrObjNode(item, key, level)\n          }\n        } else {\n          listTagVal += this.buildTextValNode(item, key, '', level);\n        }\n      }\n      if(this.options.oneListGroup){\n        listTagVal = this.buildObjectNode(listTagVal, key, '', level);\n      }\n      val += listTagVal;\n    } else {\n      //nested node\n      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);\n        }\n      } else {\n        val += this.processTextOrObjNode(jObj[key], key, level)\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nBuilder.prototype.buildAttrPairStr = function(attrName, val){\n  val = this.options.attributeValueProcessor(attrName, '' + val);\n  val = this.replaceEntitiesValue(val);\n  if (this.options.suppressBooleanAttributes && val === \"true\") {\n    return ' ' + attrName;\n  } else return ' ' + attrName + '=\"' + val + '\"';\n}\n\nfunction processTextOrObjNode (object, key, level) {\n  const result = this.j2x(object, level + 1);\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);\n  } else {\n    return this.buildObjectNode(result.val, key, result.attrStr, level);\n  }\n}\n\nBuilder.prototype.buildObjectNode = function(val, key, attrStr, level) {\n  if(val === \"\"){\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }\n  }else{\n\n    let tagEndExp = '</' + key + this.tagEndChar;\n    let piClosingChar = \"\";\n    \n    if(key[0] === \"?\") {\n      piClosingChar = \"?\";\n      tagEndExp = \"\";\n    }\n  \n    // attrStr is an empty string in case the attribute came as undefined or null\n    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {\n      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );\n    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\n      return this.indentate(level) + `<!--${val}-->` + this.newLine;\n    }else {\n      return (\n        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +\n        val +\n        this.indentate(level) + tagEndExp    );\n    }\n  }\n}\n\nBuilder.prototype.closeTag = function(key){\n  let closeTag = \"\";\n  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired\n    if(!this.options.suppressUnpairedNode) closeTag = \"/\"\n  }else if(this.options.suppressEmptyNode){ //empty\n    closeTag = \"/\";\n  }else{\n    closeTag = `></${key}`\n  }\n  return closeTag;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n      // return this.buildTagStr(level,key, attrStr);\n    }\n  }\n}\n\nBuilder.prototype.buildTextValNode = function(val, key, attrStr, level) {\n  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\n    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;\n  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\n    return this.indentate(level) + `<!--${val}-->` +  this.newLine;\n  }else if(key[0] === \"?\") {//PI tag\n    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; \n  }else{\n    let textValue = this.options.tagValueProcessor(key, val);\n    textValue = this.replaceEntitiesValue(textValue);\n  \n    if( textValue === ''){\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }else{\n      return this.indentate(level) + '<' + key + attrStr + '>' +\n         textValue +\n        '</' + key + this.tagEndChar;\n    }\n  }\n}\n\nBuilder.prototype.replaceEntitiesValue = function(textValue){\n  if(textValue && textValue.length > 0 && this.options.processEntities){\n    for (let i=0; i<this.options.entities.length; i++) {\n      const entity = this.options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n  return textValue;\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = Builder;\n","'use strict';\n\nconst validator = require('./validator');\nconst XMLParser = require('./xmlparser/XMLParser');\nconst XMLBuilder = require('./xmlbuilder/json2xml');\n\nmodule.exports = {\n  XMLParser: XMLParser,\n  XMLValidator: validator,\n  XMLBuilder: XMLBuilder\n}","import { exec } from 'child_process';\nimport dedent from 'ts-dedent';\n\ntype CommandOptions = {\n    /**\n     * Path to the PHP binary used to execute the command.\n     */\n    php?: string;\n\n    /**\n     * Path to the Symfony Console entrypoint.\n     */\n    script?: string;\n};\n\nconst defaultOptions: CommandOptions = {\n    php: 'php',\n    script: 'bin/console',\n};\n\nconst prepareSymfonyCommand = (command: string, inputs: string[] = [], options: CommandOptions = {}) => {\n    const finalOptions = {\n        ...defaultOptions,\n        ...options,\n    };\n\n    return [finalOptions.php, finalOptions.script, command]\n        .concat([...inputs, '-v'])\n        .map((part) => `'${part}'`)\n        .join(' ');\n};\n\nconst execSymfonyCommand = async (finalCommand: string) => {\n    return new Promise<string>((resolve, reject) => {\n        exec(finalCommand, (error, stdout, stderr) => {\n            if (error) {\n                reject(\n                    new Error(dedent`\n                    Symfony console failed with exit status ${error.code}:\n                    CMD: ${error.cmd}\n                    Output: ${stdout}\n                    Error output: ${stderr}\n                `)\n                );\n            }\n\n            resolve(stdout);\n        });\n    });\n};\n\n/**\n * Run a Symfony command.\n */\nexport const runSymfonyCommand = async (command: string, inputs: string[] = [], options: CommandOptions = {}) => {\n    const finalCommand = prepareSymfonyCommand(command, inputs, options);\n\n    return execSymfonyCommand(finalCommand);\n};\n\n/**\n * Run a Symfony command with JSON formatted output and get the result as a JS object.\n */\nexport const runSymfonyCommandJson = async <T = any>(\n    command: string,\n    inputs: string[] = [],\n    options: CommandOptions = {}\n): Promise<T> => {\n    const finalCommand = prepareSymfonyCommand(command, [...inputs, '--format=json'], options);\n    const result = await execSymfonyCommand(finalCommand);\n\n    try {\n        return JSON.parse(result);\n    } catch (err) {\n        throw new Error(dedent`\n        Failed to process JSON output for Symfony command.\n        CMD: ${finalCommand}\n        Raw output: ${result}\n        `);\n    }\n};\n\nexport const getKernelProjectDir = async () => {\n    return (\n        await runSymfonyCommandJson<{ [p: string]: string }>('debug:container', ['--parameter=kernel.project_dir'])\n    )['kernel.project_dir'];\n};\n\ntype StorybookBundleConfig = {\n    storybook: {\n        runtime_dir: string;\n    };\n};\n\nexport const getBundleConfig = async () => {\n    return (await runSymfonyCommandJson<StorybookBundleConfig>('debug:config', ['storybook']))['storybook'];\n};\n\ntype SymfonyTwigComponentConfiguration = {\n    twig_component: {\n        anonymous_template_directory: string;\n        defaults: {\n            [p: string]: {\n                name_prefix: string;\n                template_directory: string;\n            };\n        };\n    };\n};\n\nexport const getTwigComponentConfiguration = async () => {\n    return (\n        await runSymfonyCommandJson<SymfonyTwigComponentConfiguration>('debug:config', [\n            'twig_component',\n            '--resolve-env',\n        ])\n    )['twig_component'];\n};\n\nexport type TwigComponentConfiguration = {\n    anonymousTemplateDirectory: string;\n    namespaces: {\n        [p: string]: string;\n    };\n};\n\nexport const getPreviewHtml = async () => {\n    return await runSymfonyCommand('storybook:generate-preview');\n}\n","export function dedent(\n  templ: TemplateStringsArray | string,\n  ...values: unknown[]\n): string {\n  let strings = Array.from(typeof templ === 'string' ? [templ] : templ);\n\n  // 1. Remove trailing whitespace.\n  strings[strings.length - 1] = strings[strings.length - 1].replace(\n    /\\r?\\n([\\t ]*)$/,\n    '',\n  );\n\n  // 2. Find all line breaks to determine the highest common indentation level.\n  const indentLengths = strings.reduce((arr, str) => {\n    const matches = str.match(/\\n([\\t ]+|(?!\\s).)/g);\n    if (matches) {\n      return arr.concat(\n        matches.map((match) => match.match(/[\\t ]/g)?.length ?? 0),\n      );\n    }\n    return arr;\n  }, <number[]>[]);\n\n  // 3. Remove the common indentation from all strings.\n  if (indentLengths.length) {\n    const pattern = new RegExp(`\\n[\\t ]{${Math.min(...indentLengths)}}`, 'g');\n\n    strings = strings.map((str) => str.replace(pattern, '\\n'));\n  }\n\n  // 4. Remove leading whitespace.\n  strings[0] = strings[0].replace(/^\\r?\\n/, '');\n\n  // 5. Perform interpolation.\n  let string = strings[0];\n\n  values.forEach((value, i) => {\n    // 5.1 Read current indentation level\n    const endentations = string.match(/(?:^|\\n)( *)$/)\n    const endentation = endentations ? endentations[1] : ''\n    let indentedValue = value\n    // 5.2 Add indentation to values with multiline strings\n    if (typeof value === 'string' && value.includes('\\n')) {\n      indentedValue = String(value)\n        .split('\\n')\n        .map((str, i) => {\n          return i === 0 ? str : `${endentation}${str}`\n        })\n        .join('\\n');\n    }\n\n    string += indentedValue + strings[i + 1];\n  });\n\n  return string;\n}\n\nexport default dedent;\n","import {\n    getBundleConfig,\n    getKernelProjectDir,\n    getTwigComponentConfiguration,\n    TwigComponentConfiguration,\n} from './lib/symfony';\nimport { StorybookConfig, SymfonyOptions } from '../types';\nimport { join } from 'path';\nimport { PreviewCompilerPlugin } from './lib/preview-compiler-plugin';\nimport { DevPreviewCompilerPlugin } from './lib/dev-preview-compiler-plugin';\nimport { TwigLoaderPlugin } from './lib/twig-loader-plugin';\nimport { PresetProperty } from '@storybook/types';\nimport dedent from 'ts-dedent';\n\ntype BuildOptions = {\n    twigComponent: TwigComponentConfiguration;\n    runtimeDir: string;\n    projectDir: string;\n    additionalWatchPaths: string[];\n};\n\nconst getBuildOptions = async (symfonyOptions: SymfonyOptions) => {\n    const projectDir = await getKernelProjectDir();\n    const twigComponentsConfig = await getTwigComponentConfiguration();\n\n    const componentNamespaces: { [p: string]: string } = {};\n\n    for (const { name_prefix: namePrefix, template_directory: templateDirectory } of Object.values(\n        twigComponentsConfig.defaults\n    )) {\n        componentNamespaces[namePrefix] = join(projectDir, 'templates', templateDirectory);\n    }\n\n    const anonymousNamespace = join(projectDir, 'templates', twigComponentsConfig['anonymous_template_directory']);\n\n    const runtimeDir = (await getBundleConfig()).runtime_dir;\n\n    return {\n        twigComponent: {\n            anonymousTemplateDirectory: anonymousNamespace,\n            namespaces: componentNamespaces,\n        },\n        runtimeDir,\n        projectDir,\n        additionalWatchPaths: symfonyOptions.additionalWatchPaths || [],\n    } as BuildOptions;\n};\n\nexport const webpack: StorybookConfig['webpack'] = async (config, options) => {\n    const framework = await options.presets.apply('framework');\n\n    const frameworkOptions = typeof framework === 'string' ? {} : framework.options;\n\n    // This options resolution should be done right before creating the build configuration (i.e. not in options presets).\n    const symfonyOptions = await getBuildOptions(frameworkOptions.symfony);\n\n    return {\n        ...config,\n        plugins: [\n            ...(config.plugins || []),\n            ...[\n                options.configType === 'PRODUCTION'\n                    ? PreviewCompilerPlugin.webpack()\n                    : DevPreviewCompilerPlugin.webpack({\n                          projectDir: symfonyOptions.projectDir,\n                          additionalWatchPaths: symfonyOptions.additionalWatchPaths,\n                      }),\n                TwigLoaderPlugin.webpack({ twigComponentConfiguration: symfonyOptions.twigComponent }),\n            ],\n        ],\n        module: {\n            ...config.module,\n            rules: [...(config.module?.rules || [])],\n        },\n    };\n};\n\nexport const previewHead: PresetProperty<'previewHead'> = async (base: any) => dedent`\n    ${base}\n    <!--PREVIEW_HEAD_PLACEHOLDER-->\n    `;\n\nexport const previewBody: PresetProperty<'previewBody'> = async (base: any) => dedent`\n    ${base}\n    <!--PREVIEW_BODY_PLACEHOLDER-->\n    `;\n","import { createUnplugin } from 'unplugin';\nimport { getPreviewHtml } from './symfony';\nimport HtmlWebpackPlugin from 'html-webpack-plugin';\nimport { logger } from '@storybook/node-logger';\nimport dedent from 'ts-dedent';\nimport { injectPreviewHtml } from './injectPreviewHtml';\n\nconst PLUGIN_NAME = 'preview-plugin';\n\n/**\n * Compile preview HTML.\n */\nexport const PreviewCompilerPlugin = createUnplugin(() => {\n    return {\n        name: PLUGIN_NAME,\n        webpack(compiler) {\n            compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation) => {\n                // Inject previewHead and previewBody in the compiled iframe.html before it is output\n                HtmlWebpackPlugin.getHooks(compilation).afterTemplateExecution.tapPromise(\n                    PLUGIN_NAME,\n                    async (params) => {\n                        try {\n\n                            const previewHtml = await getPreviewHtml();\n                            params.html = injectPreviewHtml(previewHtml, params.html);\n\n                            return params;\n                        } catch (err) {\n                            logger.error(dedent`\n                            Failed to inject Symfony preview template in main iframe.html.\n                            ERR: ${err}\n                            `);\n                            return params;\n                        }\n                    }\n                );\n            });\n        },\n    };\n});\n","import { JSDOM } from 'jsdom';\n\nexport const injectPreviewHtml = (previewHtml: string, targetHtml: string) => {\n    const previewDom = new JSDOM(previewHtml);\n\n    const previewHead = previewDom.window.document.head;\n    const previewBody = previewDom.window.document.body;\n\n    return targetHtml\n        .replace('<!--PREVIEW_HEAD_PLACEHOLDER-->', previewHead.innerHTML)\n        .replace('<!--PREVIEW_BODY_PLACEHOLDER-->', previewBody.innerHTML);\n};\n","import { createUnplugin } from 'unplugin';\nimport dedent from 'ts-dedent';\nimport VirtualModulesPlugin from 'webpack-virtual-modules';\nimport { getPreviewHtml } from './symfony-api-http';\nimport { computeAdditionalWatchPaths } from './computeAdditionalWatchPaths';\nimport HtmlWebpackPlugin from 'html-webpack-plugin';\nimport { logger } from '@storybook/node-logger';\nimport { injectPreviewHtml } from './injectPreviewHtml';\n\nconst PLUGIN_NAME = 'dev-preview-plugin';\n\nexport type Options = {\n    projectDir: string;\n    additionalWatchPaths: string[];\n};\n\n/**\n * Compile preview HTML for dev with HMR .\n */\nexport const DevPreviewCompilerPlugin = createUnplugin<Options>((options) => {\n    const { projectDir, additionalWatchPaths } = options;\n\n    return {\n        name: PLUGIN_NAME,\n        enforce: 'post',\n        transformInclude(id) {\n            return /storybook-config-entry\\.js$/.test(id);\n        },\n        async transform(code) {\n            return dedent`\n        import { symfonyPreview } from './symfony-preview.js';\n        \n        ${code}\n\n        window.__SYMFONY_PREVIEW__ = symfonyPreview;\n        if (import.meta.webpackHot) {\n            import.meta.webpackHot.accept('./symfony-preview.js', () => {\n                const iframe = window.top.document.getElementById('storybook-preview-iframe');\n                if (iframe) {\n                    iframe.src = iframe.src;\n                }\n            });\n        }\n        `;\n        },\n        webpack(compiler) {\n            // Virtual plugin for preview module\n            const v = new VirtualModulesPlugin();\n            v.apply(compiler);\n\n            let previewHtml = '';\n\n            // Compile preview before each compilation in watch mode\n            compiler.hooks.watchRun.tapPromise(PLUGIN_NAME, async () => {\n                previewHtml = (await getPreviewHtml()).content;\n\n                // Write preview module\n                v.writeModule(\n                    './symfony-preview.js',\n                    dedent`\n                    export const symfonyPreview = {\n                        html: \\`${previewHtml}\\`,\n                    };`\n                );\n            });\n\n            compiler.hooks.afterCompile.tap(PLUGIN_NAME, (compilation) => {\n                if ('HtmlWebpackCompiler' == compilation.name) {\n                    // Register additional watch paths for HMR\n                    const resolvedWatchPaths = computeAdditionalWatchPaths(additionalWatchPaths, projectDir);\n                    compilation.contextDependencies.addAll(resolvedWatchPaths.dirs);\n                    compilation.fileDependencies.addAll(resolvedWatchPaths.files);\n                }\n            });\n\n            compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation) => {\n                // Inject previewHead and previewBody in the compiled iframe.html before it is output\n                HtmlWebpackPlugin.getHooks(compilation).afterTemplateExecution.tapPromise(\n                    PLUGIN_NAME,\n                    async (params) => {\n                        try {\n                            params.html = injectPreviewHtml(previewHtml, params.html);\n                            return params;\n                        } catch (err) {\n                            logger.error(dedent`\n                            Failed to inject Symfony preview template in main iframe.html.\n                            ERR: ${err}\n                            `);\n                            return params;\n                        }\n                    }\n                );\n            });\n        },\n    };\n});\n","/**\n * Index.js\n *\n * a request API compatible with window.fetch\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */\n\nimport http from 'node:http';\nimport https from 'node:https';\nimport zlib from 'node:zlib';\nimport Stream, {PassThrough, pipeline as pump} from 'node:stream';\nimport {Buffer} from 'node:buffer';\n\nimport dataUriToBuffer from 'data-uri-to-buffer';\n\nimport {writeToStream, clone} from './body.js';\nimport Response from './response.js';\nimport Headers, {fromRawHeaders} from './headers.js';\nimport Request, {getNodeRequestOptions} from './request.js';\nimport {FetchError} from './errors/fetch-error.js';\nimport {AbortError} from './errors/abort-error.js';\nimport {isRedirect} from './utils/is-redirect.js';\nimport {FormData} from 'formdata-polyfill/esm.min.js';\nimport {isDomainOrSubdomain, isSameProtocol} from './utils/is.js';\nimport {parseReferrerPolicyFromHeader} from './utils/referrer.js';\nimport {\n\tBlob,\n\tFile,\n\tfileFromSync,\n\tfileFrom,\n\tblobFromSync,\n\tblobFrom\n} from 'fetch-blob/from.js';\n\nexport {FormData, Headers, Request, Response, FetchError, AbortError, isRedirect};\nexport {Blob, File, fileFromSync, fileFrom, blobFromSync, blobFrom};\n\nconst supportedSchemas = new Set(['data:', 'http:', 'https:']);\n\n/**\n * Fetch function\n *\n * @param   {string | URL | import('./request').default} url - Absolute url or Request instance\n * @param   {*} [options_] - Fetch options\n * @return  {Promise<import('./response').default>}\n */\nexport default async function fetch(url, options_) {\n\treturn new Promise((resolve, reject) => {\n\t\t// Build request object\n\t\tconst request = new Request(url, options_);\n\t\tconst {parsedURL, options} = getNodeRequestOptions(request);\n\t\tif (!supportedSchemas.has(parsedURL.protocol)) {\n\t\t\tthrow new TypeError(`node-fetch cannot load ${url}. URL scheme \"${parsedURL.protocol.replace(/:$/, '')}\" is not supported.`);\n\t\t}\n\n\t\tif (parsedURL.protocol === 'data:') {\n\t\t\tconst data = dataUriToBuffer(request.url);\n\t\t\tconst response = new Response(data, {headers: {'Content-Type': data.typeFull}});\n\t\t\tresolve(response);\n\t\t\treturn;\n\t\t}\n\n\t\t// Wrap http.request into fetch\n\t\tconst send = (parsedURL.protocol === 'https:' ? https : http).request;\n\t\tconst {signal} = request;\n\t\tlet response = null;\n\n\t\tconst abort = () => {\n\t\t\tconst error = new AbortError('The operation was aborted.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\trequest.body.destroy(error);\n\t\t\t}\n\n\t\t\tif (!response || !response.body) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = () => {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// Send request\n\t\tconst request_ = send(parsedURL.toString(), options);\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tconst finalize = () => {\n\t\t\trequest_.abort();\n\t\t\tif (signal) {\n\t\t\t\tsignal.removeEventListener('abort', abortAndFinalize);\n\t\t\t}\n\t\t};\n\n\t\trequest_.on('error', error => {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, 'system', error));\n\t\t\tfinalize();\n\t\t});\n\n\t\tfixResponseChunkedTransferBadEnding(request_, error => {\n\t\t\tif (response && response.body) {\n\t\t\t\tresponse.body.destroy(error);\n\t\t\t}\n\t\t});\n\n\t\t/* c8 ignore next 18 */\n\t\tif (process.version < 'v14') {\n\t\t\t// Before Node.js 14, pipeline() does not fully support async iterators and does not always\n\t\t\t// properly handle when the socket close/end events are out of order.\n\t\t\trequest_.on('socket', s => {\n\t\t\t\tlet endedWithEventsCount;\n\t\t\t\ts.prependListener('end', () => {\n\t\t\t\t\tendedWithEventsCount = s._eventsCount;\n\t\t\t\t});\n\t\t\t\ts.prependListener('close', hadError => {\n\t\t\t\t\t// if end happened before close but the socket didn't emit an error, do it now\n\t\t\t\t\tif (response && endedWithEventsCount < s._eventsCount && !hadError) {\n\t\t\t\t\t\tconst error = new Error('Premature close');\n\t\t\t\t\t\terror.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\t\tresponse.body.emit('error', error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\trequest_.on('response', response_ => {\n\t\t\trequest_.setTimeout(0);\n\t\t\tconst headers = fromRawHeaders(response_.rawHeaders);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (isRedirect(response_.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tlet locationURL = null;\n\t\t\t\ttry {\n\t\t\t\t\tlocationURL = location === null ? null : new URL(location, request.url);\n\t\t\t\t} catch {\n\t\t\t\t\t// error here can only be invalid URL in Location: header\n\t\t\t\t\t// do not throw when options.redirect == manual\n\t\t\t\t\t// let the user extract the errorneous redirect URL\n\t\t\t\t\tif (request.redirect !== 'manual') {\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// Nothing to do\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow': {\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOptions = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: clone(request),\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\tsize: request.size,\n\t\t\t\t\t\t\treferrer: request.referrer,\n\t\t\t\t\t\t\treferrerPolicy: request.referrerPolicy\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// when forwarding sensitive headers like \"Authorization\",\n\t\t\t\t\t\t// \"WWW-Authenticate\", and \"Cookie\" to untrusted targets,\n\t\t\t\t\t\t// headers will be ignored when following a redirect to a domain\n\t\t\t\t\t\t// that is not a subdomain match or exact match of the initial domain.\n\t\t\t\t\t\t// For example, a redirect from \"foo.com\" to either \"foo.com\" or \"sub.foo.com\"\n\t\t\t\t\t\t// will forward the sensitive headers, but a redirect to \"bar.com\" will not.\n\t\t\t\t\t\t// headers will also be ignored when following a redirect to a domain using\n\t\t\t\t\t\t// a different protocol. For example, a redirect from \"https://foo.com\" to \"http://foo.com\"\n\t\t\t\t\t\t// will not forward the sensitive headers\n\t\t\t\t\t\tif (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n\t\t\t\t\t\t\tfor (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {\n\t\t\t\t\t\t\t\trequestOptions.headers.delete(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (response_.statusCode !== 303 && request.body && options_.body instanceof Stream.Readable) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (response_.statusCode === 303 || ((response_.statusCode === 301 || response_.statusCode === 302) && request.method === 'POST')) {\n\t\t\t\t\t\t\trequestOptions.method = 'GET';\n\t\t\t\t\t\t\trequestOptions.body = undefined;\n\t\t\t\t\t\t\trequestOptions.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 14\n\t\t\t\t\t\tconst responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);\n\t\t\t\t\t\tif (responseReferrerPolicy) {\n\t\t\t\t\t\t\trequestOptions.referrerPolicy = responseReferrerPolicy;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOptions)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Prepare response\n\t\t\tif (signal) {\n\t\t\t\tresponse_.once('end', () => {\n\t\t\t\t\tsignal.removeEventListener('abort', abortAndFinalize);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet body = pump(response_, new PassThrough(), error => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t});\n\t\t\t// see https://github.com/nodejs/node/pull/29376\n\t\t\t/* c8 ignore next 3 */\n\t\t\tif (process.version < 'v12.10') {\n\t\t\t\tresponse_.on('aborted', abortAndFinalize);\n\t\t\t}\n\n\t\t\tconst responseOptions = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: response_.statusCode,\n\t\t\t\tstatusText: response_.statusMessage,\n\t\t\t\theaders,\n\t\t\t\tsize: request.size,\n\t\t\t\tcounter: request.counter,\n\t\t\t\thighWaterMark: request.highWaterMark\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// For gzip\n\t\t\tif (codings === 'gzip' || codings === 'x-gzip') {\n\t\t\t\tbody = pump(body, zlib.createGunzip(zlibOptions), error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For deflate\n\t\t\tif (codings === 'deflate' || codings === 'x-deflate') {\n\t\t\t\t// Handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = pump(response_, new PassThrough(), error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\traw.once('data', chunk => {\n\t\t\t\t\t// See http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = pump(body, zlib.createInflate(), error => {\n\t\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = pump(body, zlib.createInflateRaw(), error => {\n\t\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\traw.once('end', () => {\n\t\t\t\t\t// Some old IIS servers return zero-length OK deflate responses, so\n\t\t\t\t\t// 'data' is never emitted. See https://github.com/node-fetch/node-fetch/pull/903\n\t\t\t\t\tif (!response) {\n\t\t\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For br\n\t\t\tif (codings === 'br') {\n\t\t\t\tbody = pump(body, zlib.createBrotliDecompress(), error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise, use response as-is\n\t\t\tresponse = new Response(body, responseOptions);\n\t\t\tresolve(response);\n\t\t});\n\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\twriteToStream(request_, request).catch(reject);\n\t});\n}\n\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n\tconst LAST_CHUNK = Buffer.from('0\\r\\n\\r\\n');\n\n\tlet isChunkedTransfer = false;\n\tlet properLastChunkReceived = false;\n\tlet previousChunk;\n\n\trequest.on('response', response => {\n\t\tconst {headers} = response;\n\t\tisChunkedTransfer = headers['transfer-encoding'] === 'chunked' && !headers['content-length'];\n\t});\n\n\trequest.on('socket', socket => {\n\t\tconst onSocketClose = () => {\n\t\t\tif (isChunkedTransfer && !properLastChunkReceived) {\n\t\t\t\tconst error = new Error('Premature close');\n\t\t\t\terror.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\terrorCallback(error);\n\t\t\t}\n\t\t};\n\n\t\tconst onData = buf => {\n\t\t\tproperLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;\n\n\t\t\t// Sometimes final 0-length chunk and end of message code are in separate packets\n\t\t\tif (!properLastChunkReceived && previousChunk) {\n\t\t\t\tproperLastChunkReceived = (\n\t\t\t\t\tBuffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 &&\n\t\t\t\t\tBuffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpreviousChunk = buf;\n\t\t};\n\n\t\tsocket.prependListener('close', onSocketClose);\n\t\tsocket.on('data', onData);\n\n\t\trequest.on('close', () => {\n\t\t\tsocket.removeListener('close', onSocketClose);\n\t\t\tsocket.removeListener('data', onData);\n\t\t});\n\t});\n}\n","export interface MimeBuffer extends Buffer {\n\ttype: string;\n\ttypeFull: string;\n\tcharset: string;\n}\n\n/**\n * Returns a `Buffer` instance from the given data URI `uri`.\n *\n * @param {String} uri Data URI to turn into a Buffer instance\n * @returns {Buffer} Buffer instance from Data URI\n * @api public\n */\nexport function dataUriToBuffer(uri: string): MimeBuffer {\n\tif (!/^data:/i.test(uri)) {\n\t\tthrow new TypeError(\n\t\t\t'`uri` does not appear to be a Data URI (must begin with \"data:\")'\n\t\t);\n\t}\n\n\t// strip newlines\n\turi = uri.replace(/\\r?\\n/g, '');\n\n\t// split the URI up into the \"metadata\" and the \"data\" portions\n\tconst firstComma = uri.indexOf(',');\n\tif (firstComma === -1 || firstComma <= 4) {\n\t\tthrow new TypeError('malformed data: URI');\n\t}\n\n\t// remove the \"data:\" scheme and parse the metadata\n\tconst meta = uri.substring(5, firstComma).split(';');\n\n\tlet charset = '';\n\tlet base64 = false;\n\tconst type = meta[0] || 'text/plain';\n\tlet typeFull = type;\n\tfor (let i = 1; i < meta.length; i++) {\n\t\tif (meta[i] === 'base64') {\n\t\t\tbase64 = true;\n\t\t} else if(meta[i]) {\n\t\t\ttypeFull += `;${  meta[i]}`;\n\t\t\tif (meta[i].indexOf('charset=') === 0) {\n\t\t\t\tcharset = meta[i].substring(8);\n\t\t\t}\n\t\t}\n\t}\n\t// defaults to US-ASCII only if type is not provided\n\tif (!meta[0] && !charset.length) {\n\t\ttypeFull += ';charset=US-ASCII';\n\t\tcharset = 'US-ASCII';\n\t}\n\n\t// get the encoded data portion and decode URI-encoded chars\n\tconst encoding = base64 ? 'base64' : 'ascii';\n\tconst data = unescape(uri.substring(firstComma + 1));\n\tconst buffer = Buffer.from(data, encoding) as MimeBuffer;\n\n\t// set `.type` and `.typeFull` properties to MIME type\n\tbuffer.type = type;\n\tbuffer.typeFull = typeFull;\n\n\t// set the `.charset` property\n\tbuffer.charset = charset;\n\n\treturn buffer;\n}\n\nexport default dataUriToBuffer;\n","\n/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\n\nimport Stream, {PassThrough} from 'node:stream';\nimport {types, deprecate, promisify} from 'node:util';\nimport {Buffer} from 'node:buffer';\n\nimport Blob from 'fetch-blob';\nimport {FormData, formDataToBlob} from 'formdata-polyfill/esm.min.js';\n\nimport {FetchError} from './errors/fetch-error.js';\nimport {FetchBaseError} from './errors/base.js';\nimport {isBlob, isURLSearchParameters} from './utils/is.js';\n\nconst pipeline = promisify(Stream.pipeline);\nconst INTERNALS = Symbol('Body internals');\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Body {\n\tconstructor(body, {\n\t\tsize = 0\n\t} = {}) {\n\t\tlet boundary = null;\n\n\t\tif (body === null) {\n\t\t\t// Body is undefined or null\n\t\t\tbody = null;\n\t\t} else if (isURLSearchParameters(body)) {\n\t\t\t// Body is a URLSearchParams\n\t\t\tbody = Buffer.from(body.toString());\n\t\t} else if (isBlob(body)) {\n\t\t\t// Body is blob\n\t\t} else if (Buffer.isBuffer(body)) {\n\t\t\t// Body is Buffer\n\t\t} else if (types.isAnyArrayBuffer(body)) {\n\t\t\t// Body is ArrayBuffer\n\t\t\tbody = Buffer.from(body);\n\t\t} else if (ArrayBuffer.isView(body)) {\n\t\t\t// Body is ArrayBufferView\n\t\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t\t} else if (body instanceof Stream) {\n\t\t\t// Body is stream\n\t\t} else if (body instanceof FormData) {\n\t\t\t// Body is FormData\n\t\t\tbody = formDataToBlob(body);\n\t\t\tboundary = body.type.split('=')[1];\n\t\t} else {\n\t\t\t// None of the above\n\t\t\t// coerce to string then buffer\n\t\t\tbody = Buffer.from(String(body));\n\t\t}\n\n\t\tlet stream = body;\n\n\t\tif (Buffer.isBuffer(body)) {\n\t\t\tstream = Stream.Readable.from(body);\n\t\t} else if (isBlob(body)) {\n\t\t\tstream = Stream.Readable.from(body.stream());\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\tbody,\n\t\t\tstream,\n\t\t\tboundary,\n\t\t\tdisturbed: false,\n\t\t\terror: null\n\t\t};\n\t\tthis.size = size;\n\n\t\tif (body instanceof Stream) {\n\t\t\tbody.on('error', error_ => {\n\t\t\t\tconst error = error_ instanceof FetchBaseError ?\n\t\t\t\t\terror_ :\n\t\t\t\t\tnew FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n\t\t\t\tthis[INTERNALS].error = error;\n\t\t\t});\n\t\t}\n\t}\n\n\tget body() {\n\t\treturn this[INTERNALS].stream;\n\t}\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t}\n\n\t/**\n\t * Decode response as ArrayBuffer\n\t *\n\t * @return  Promise\n\t */\n\tasync arrayBuffer() {\n\t\tconst {buffer, byteOffset, byteLength} = await consumeBody(this);\n\t\treturn buffer.slice(byteOffset, byteOffset + byteLength);\n\t}\n\n\tasync formData() {\n\t\tconst ct = this.headers.get('content-type');\n\n\t\tif (ct.startsWith('application/x-www-form-urlencoded')) {\n\t\t\tconst formData = new FormData();\n\t\t\tconst parameters = new URLSearchParams(await this.text());\n\n\t\t\tfor (const [name, value] of parameters) {\n\t\t\t\tformData.append(name, value);\n\t\t\t}\n\n\t\t\treturn formData;\n\t\t}\n\n\t\tconst {toFormData} = await import('./utils/multipart-parser.js');\n\t\treturn toFormData(this.body, ct);\n\t}\n\n\t/**\n\t * Return raw response as Blob\n\t *\n\t * @return Promise\n\t */\n\tasync blob() {\n\t\tconst ct = (this.headers && this.headers.get('content-type')) || (this[INTERNALS].body && this[INTERNALS].body.type) || '';\n\t\tconst buf = await this.arrayBuffer();\n\n\t\treturn new Blob([buf], {\n\t\t\ttype: ct\n\t\t});\n\t}\n\n\t/**\n\t * Decode response as json\n\t *\n\t * @return  Promise\n\t */\n\tasync json() {\n\t\tconst text = await this.text();\n\t\treturn JSON.parse(text);\n\t}\n\n\t/**\n\t * Decode response as text\n\t *\n\t * @return  Promise\n\t */\n\tasync text() {\n\t\tconst buffer = await consumeBody(this);\n\t\treturn new TextDecoder().decode(buffer);\n\t}\n\n\t/**\n\t * Decode response as buffer (non-spec api)\n\t *\n\t * @return  Promise\n\t */\n\tbuffer() {\n\t\treturn consumeBody(this);\n\t}\n}\n\nBody.prototype.buffer = deprecate(Body.prototype.buffer, 'Please use \\'response.arrayBuffer()\\' instead of \\'response.buffer()\\'', 'node-fetch#buffer');\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: {enumerable: true},\n\tbodyUsed: {enumerable: true},\n\tarrayBuffer: {enumerable: true},\n\tblob: {enumerable: true},\n\tjson: {enumerable: true},\n\ttext: {enumerable: true},\n\tdata: {get: deprecate(() => {},\n\t\t'data doesn\\'t exist, use json(), text(), arrayBuffer(), or body instead',\n\t\t'https://github.com/node-fetch/node-fetch/issues/1000 (response)')}\n});\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\nasync function consumeBody(data) {\n\tif (data[INTERNALS].disturbed) {\n\t\tthrow new TypeError(`body used already for: ${data.url}`);\n\t}\n\n\tdata[INTERNALS].disturbed = true;\n\n\tif (data[INTERNALS].error) {\n\t\tthrow data[INTERNALS].error;\n\t}\n\n\tconst {body} = data;\n\n\t// Body is null\n\tif (body === null) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t/* c8 ignore next 3 */\n\tif (!(body instanceof Stream)) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t// Body is stream\n\t// get ready to actually consume the body\n\tconst accum = [];\n\tlet accumBytes = 0;\n\n\ttry {\n\t\tfor await (const chunk of body) {\n\t\t\tif (data.size > 0 && accumBytes + chunk.length > data.size) {\n\t\t\t\tconst error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n\t\t\t\tbody.destroy(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t}\n\t} catch (error) {\n\t\tconst error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n\t\tthrow error_;\n\t}\n\n\tif (body.readableEnded === true || body._readableState.ended === true) {\n\t\ttry {\n\t\t\tif (accum.every(c => typeof c === 'string')) {\n\t\t\t\treturn Buffer.from(accum.join(''));\n\t\t\t}\n\n\t\t\treturn Buffer.concat(accum, accumBytes);\n\t\t} catch (error) {\n\t\t\tthrow new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n\t\t}\n\t} else {\n\t\tthrow new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n\t}\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\nexport const clone = (instance, highWaterMark) => {\n\tlet p1;\n\tlet p2;\n\tlet {body} = instance[INTERNALS];\n\n\t// Don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// Check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif ((body instanceof Stream) && (typeof body.getBoundary !== 'function')) {\n\t\t// Tee instance body\n\t\tp1 = new PassThrough({highWaterMark});\n\t\tp2 = new PassThrough({highWaterMark});\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// Set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].stream = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n};\n\nconst getNonSpecFormDataBoundary = deprecate(\n\tbody => body.getBoundary(),\n\t'form-data doesn\\'t follow the spec and requires special treatment. Use alternative package',\n\t'https://github.com/node-fetch/node-fetch/issues/1167'\n);\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\nexport const extractContentType = (body, request) => {\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn null;\n\t}\n\n\t// Body is string\n\tif (typeof body === 'string') {\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n\n\t// Body is a URLSearchParams\n\tif (isURLSearchParameters(body)) {\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t}\n\n\t// Body is blob\n\tif (isBlob(body)) {\n\t\treturn body.type || null;\n\t}\n\n\t// Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\tif (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n\t\treturn null;\n\t}\n\n\tif (body instanceof FormData) {\n\t\treturn `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getBoundary === 'function') {\n\t\treturn `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n\t}\n\n\t// Body is stream - can't really do much about this\n\tif (body instanceof Stream) {\n\t\treturn null;\n\t}\n\n\t// Body constructor defaults other things to string\n\treturn 'text/plain;charset=UTF-8';\n};\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\nexport const getTotalBytes = request => {\n\tconst {body} = request[INTERNALS];\n\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn 0;\n\t}\n\n\t// Body is Blob\n\tif (isBlob(body)) {\n\t\treturn body.size;\n\t}\n\n\t// Body is Buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn body.length;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getLengthSync === 'function') {\n\t\treturn body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n\t}\n\n\t// Body is stream\n\treturn null;\n};\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {Promise<void>}\n */\nexport const writeToStream = async (dest, {body}) => {\n\tif (body === null) {\n\t\t// Body is null\n\t\tdest.end();\n\t} else {\n\t\t// Body is stream\n\t\tawait pipeline(body, dest);\n\t}\n};\n","export class FetchBaseError extends Error {\n\tconstructor(message, type) {\n\t\tsuper(message);\n\t\t// Hide custom error implementation details from end-users\n\t\tError.captureStackTrace(this, this.constructor);\n\n\t\tthis.type = type;\n\t}\n\n\tget name() {\n\t\treturn this.constructor.name;\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn this.constructor.name;\n\t}\n}\n","\nimport {FetchBaseError} from './base.js';\n\n/**\n * @typedef {{ address?: string, code: string, dest?: string, errno: number, info?: object, message: string, path?: string, port?: number, syscall: string}} SystemError\n*/\n\n/**\n * FetchError interface for operational errors\n */\nexport class FetchError extends FetchBaseError {\n\t/**\n\t * @param  {string} message -      Error message for human\n\t * @param  {string} [type] -        Error type for machine\n\t * @param  {SystemError} [systemError] - For Node.js system error\n\t */\n\tconstructor(message, type, systemError) {\n\t\tsuper(message, type);\n\t\t// When err.type is `system`, err.erroredSysCall contains system error and err.code contains system error code\n\t\tif (systemError) {\n\t\t\t// eslint-disable-next-line no-multi-assign\n\t\t\tthis.code = this.errno = systemError.code;\n\t\t\tthis.erroredSysCall = systemError.syscall;\n\t\t}\n\t}\n}\n","/**\n * Is.js\n *\n * Object type checks.\n */\n\nconst NAME = Symbol.toStringTag;\n\n/**\n * Check if `obj` is a URLSearchParams object\n * ref: https://github.com/node-fetch/node-fetch/issues/296#issuecomment-307598143\n * @param {*} object - Object to check for\n * @return {boolean}\n */\nexport const isURLSearchParameters = object => {\n\treturn (\n\t\ttypeof object === 'object' &&\n\t\ttypeof object.append === 'function' &&\n\t\ttypeof object.delete === 'function' &&\n\t\ttypeof object.get === 'function' &&\n\t\ttypeof object.getAll === 'function' &&\n\t\ttypeof object.has === 'function' &&\n\t\ttypeof object.set === 'function' &&\n\t\ttypeof object.sort === 'function' &&\n\t\tobject[NAME] === 'URLSearchParams'\n\t);\n};\n\n/**\n * Check if `object` is a W3C `Blob` object (which `File` inherits from)\n * @param {*} object - Object to check for\n * @return {boolean}\n */\nexport const isBlob = object => {\n\treturn (\n\t\tobject &&\n\t\ttypeof object === 'object' &&\n\t\ttypeof object.arrayBuffer === 'function' &&\n\t\ttypeof object.type === 'string' &&\n\t\ttypeof object.stream === 'function' &&\n\t\ttypeof object.constructor === 'function' &&\n\t\t/^(Blob|File)$/.test(object[NAME])\n\t);\n};\n\n/**\n * Check if `obj` is an instance of AbortSignal.\n * @param {*} object - Object to check for\n * @return {boolean}\n */\nexport const isAbortSignal = object => {\n\treturn (\n\t\ttypeof object === 'object' && (\n\t\t\tobject[NAME] === 'AbortSignal' ||\n\t\t\tobject[NAME] === 'EventTarget'\n\t\t)\n\t);\n};\n\n/**\n * isDomainOrSubdomain reports whether sub is a subdomain (or exact match) of\n * the parent domain.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */\nexport const isDomainOrSubdomain = (destination, original) => {\n\tconst orig = new URL(original).hostname;\n\tconst dest = new URL(destination).hostname;\n\n\treturn orig === dest || orig.endsWith(`.${dest}`);\n};\n\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */\nexport const isSameProtocol = (destination, original) => {\n\tconst orig = new URL(original).protocol;\n\tconst dest = new URL(destination).protocol;\n\n\treturn orig === dest;\n};\n","/**\n * Headers.js\n *\n * Headers class offers convenient helpers\n */\n\nimport {types} from 'node:util';\nimport http from 'node:http';\n\n/* c8 ignore next 9 */\nconst validateHeaderName = typeof http.validateHeaderName === 'function' ?\n\thttp.validateHeaderName :\n\tname => {\n\t\tif (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(name)) {\n\t\t\tconst error = new TypeError(`Header name must be a valid HTTP token [${name}]`);\n\t\t\tObject.defineProperty(error, 'code', {value: 'ERR_INVALID_HTTP_TOKEN'});\n\t\t\tthrow error;\n\t\t}\n\t};\n\n/* c8 ignore next 9 */\nconst validateHeaderValue = typeof http.validateHeaderValue === 'function' ?\n\thttp.validateHeaderValue :\n\t(name, value) => {\n\t\tif (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(value)) {\n\t\t\tconst error = new TypeError(`Invalid character in header content [\"${name}\"]`);\n\t\t\tObject.defineProperty(error, 'code', {value: 'ERR_INVALID_CHAR'});\n\t\t\tthrow error;\n\t\t}\n\t};\n\n/**\n * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit\n */\n\n/**\n * This Fetch API interface allows you to perform various actions on HTTP request and response headers.\n * These actions include retrieving, setting, adding to, and removing.\n * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.\n * You can add to this using methods like append() (see Examples.)\n * In all methods of this interface, header names are matched by case-insensitive byte sequence.\n *\n */\nexport default class Headers extends URLSearchParams {\n\t/**\n\t * Headers class\n\t *\n\t * @constructor\n\t * @param {HeadersInit} [init] - Response headers\n\t */\n\tconstructor(init) {\n\t\t// Validate and normalize init object in [name, value(s)][]\n\t\t/** @type {string[][]} */\n\t\tlet result = [];\n\t\tif (init instanceof Headers) {\n\t\t\tconst raw = init.raw();\n\t\t\tfor (const [name, values] of Object.entries(raw)) {\n\t\t\t\tresult.push(...values.map(value => [name, value]));\n\t\t\t}\n\t\t} else if (init == null) { // eslint-disable-line no-eq-null, eqeqeq\n\t\t\t// No op\n\t\t} else if (typeof init === 'object' && !types.isBoxedPrimitive(init)) {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\t\tif (method == null) {\n\t\t\t\t// Record<ByteString, ByteString>\n\t\t\t\tresult.push(...Object.entries(init));\n\t\t\t} else {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// Sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tresult = [...init]\n\t\t\t\t\t.map(pair => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttypeof pair !== 'object' || types.isBoxedPrimitive(pair)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new TypeError('Each header pair must be an iterable object');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [...pair];\n\t\t\t\t\t}).map(pair => {\n\t\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [...pair];\n\t\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Failed to construct \\'Headers\\': The provided value is not of type \\'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');\n\t\t}\n\n\t\t// Validate and lowercase\n\t\tresult =\n\t\t\tresult.length > 0 ?\n\t\t\t\tresult.map(([name, value]) => {\n\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\treturn [String(name).toLowerCase(), String(value)];\n\t\t\t\t}) :\n\t\t\t\tundefined;\n\n\t\tsuper(result);\n\n\t\t// Returning a Proxy that will lowercase key names, validate parameters and sort keys\n\t\t// eslint-disable-next-line no-constructor-return\n\t\treturn new Proxy(this, {\n\t\t\tget(target, p, receiver) {\n\t\t\t\tswitch (p) {\n\t\t\t\t\tcase 'append':\n\t\t\t\t\tcase 'set':\n\t\t\t\t\t\treturn (name, value) => {\n\t\t\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\t\t\treturn URLSearchParams.prototype[p].call(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tString(name).toLowerCase(),\n\t\t\t\t\t\t\t\tString(value)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\n\t\t\t\t\tcase 'delete':\n\t\t\t\t\tcase 'has':\n\t\t\t\t\tcase 'getAll':\n\t\t\t\t\t\treturn name => {\n\t\t\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\t\t\treturn URLSearchParams.prototype[p].call(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tString(name).toLowerCase()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\n\t\t\t\t\tcase 'keys':\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\ttarget.sort();\n\t\t\t\t\t\t\treturn new Set(URLSearchParams.prototype.keys.call(target)).keys();\n\t\t\t\t\t\t};\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn Reflect.get(target, p, receiver);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t/* c8 ignore next */\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn this.constructor.name;\n\t}\n\n\ttoString() {\n\t\treturn Object.prototype.toString.call(this);\n\t}\n\n\tget(name) {\n\t\tconst values = this.getAll(name);\n\t\tif (values.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet value = values.join(', ');\n\t\tif (/^content-encoding$/i.test(name)) {\n\t\t\tvalue = value.toLowerCase();\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tforEach(callback, thisArg = undefined) {\n\t\tfor (const name of this.keys()) {\n\t\t\tReflect.apply(callback, thisArg, [this.get(name), name, this]);\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const name of this.keys()) {\n\t\t\tyield this.get(name);\n\t\t}\n\t}\n\n\t/**\n\t * @type {() => IterableIterator<[string, string]>}\n\t */\n\t* entries() {\n\t\tfor (const name of this.keys()) {\n\t\t\tyield [name, this.get(name)];\n\t\t}\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this.entries();\n\t}\n\n\t/**\n\t * Node-fetch non-spec method\n\t * returning all headers and their values as array\n\t * @returns {Record<string, string[]>}\n\t */\n\traw() {\n\t\treturn [...this.keys()].reduce((result, key) => {\n\t\t\tresult[key] = this.getAll(key);\n\t\t\treturn result;\n\t\t}, {});\n\t}\n\n\t/**\n\t * For better console.log(headers) and also to convert Headers into Node.js Request compatible format\n\t */\n\t[Symbol.for('nodejs.util.inspect.custom')]() {\n\t\treturn [...this.keys()].reduce((result, key) => {\n\t\t\tconst values = this.getAll(key);\n\t\t\t// Http.request() only supports string as Host header.\n\t\t\t// This hack makes specifying custom Host header possible.\n\t\t\tif (key === 'host') {\n\t\t\t\tresult[key] = values[0];\n\t\t\t} else {\n\t\t\t\tresult[key] = values.length > 1 ? values : values[0];\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}, {});\n\t}\n}\n\n/**\n * Re-shaping object for Web IDL tests\n * Only need to do it for overridden methods\n */\nObject.defineProperties(\n\tHeaders.prototype,\n\t['get', 'entries', 'forEach', 'values'].reduce((result, property) => {\n\t\tresult[property] = {enumerable: true};\n\t\treturn result;\n\t}, {})\n);\n\n/**\n * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do\n * not conform to HTTP grammar productions.\n * @param {import('http').IncomingMessage['rawHeaders']} headers\n */\nexport function fromRawHeaders(headers = []) {\n\treturn new Headers(\n\t\theaders\n\t\t\t// Split into pairs\n\t\t\t.reduce((result, value, index, array) => {\n\t\t\t\tif (index % 2 === 0) {\n\t\t\t\t\tresult.push(array.slice(index, index + 2));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, [])\n\t\t\t.filter(([name, value]) => {\n\t\t\t\ttry {\n\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\treturn true;\n\t\t\t\t} catch {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t})\n\n\t);\n}\n","const redirectStatus = new Set([301, 302, 303, 307, 308]);\n\n/**\n * Redirect code matching\n *\n * @param {number} code - Status code\n * @return {boolean}\n */\nexport const isRedirect = code => {\n\treturn redirectStatus.has(code);\n};\n","/**\n * Response.js\n *\n * Response class provides content decoding\n */\n\nimport Headers from './headers.js';\nimport Body, {clone, extractContentType} from './body.js';\nimport {isRedirect} from './utils/is-redirect.js';\n\nconst INTERNALS = Symbol('Response internals');\n\n/**\n * Response class\n *\n * Ref: https://fetch.spec.whatwg.org/#response-class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Response extends Body {\n\tconstructor(body = null, options = {}) {\n\t\tsuper(body, options);\n\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition\n\t\tconst status = options.status != null ? options.status : 200;\n\n\t\tconst headers = new Headers(options.headers);\n\n\t\tif (body !== null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body, this);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\ttype: 'default',\n\t\t\turl: options.url,\n\t\t\tstatus,\n\t\t\tstatusText: options.statusText || '',\n\t\t\theaders,\n\t\t\tcounter: options.counter,\n\t\t\thighWaterMark: options.highWaterMark\n\t\t};\n\t}\n\n\tget type() {\n\t\treturn this[INTERNALS].type;\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS].status;\n\t}\n\n\t/**\n\t * Convenience property representing if the request ended normally\n\t */\n\tget ok() {\n\t\treturn this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS].headers;\n\t}\n\n\tget highWaterMark() {\n\t\treturn this[INTERNALS].highWaterMark;\n\t}\n\n\t/**\n\t * Clone this response\n\t *\n\t * @return  Response\n\t */\n\tclone() {\n\t\treturn new Response(clone(this, this.highWaterMark), {\n\t\t\ttype: this.type,\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected,\n\t\t\tsize: this.size,\n\t\t\thighWaterMark: this.highWaterMark\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} url    The URL that the new response is to originate from.\n\t * @param {number} status An optional status code for the response (e.g., 302.)\n\t * @returns {Response}    A Response object.\n\t */\n\tstatic redirect(url, status = 302) {\n\t\tif (!isRedirect(status)) {\n\t\t\tthrow new RangeError('Failed to execute \"redirect\" on \"response\": Invalid status code');\n\t\t}\n\n\t\treturn new Response(null, {\n\t\t\theaders: {\n\t\t\t\tlocation: new URL(url).toString()\n\t\t\t},\n\t\t\tstatus\n\t\t});\n\t}\n\n\tstatic error() {\n\t\tconst response = new Response(null, {status: 0, statusText: ''});\n\t\tresponse[INTERNALS].type = 'error';\n\t\treturn response;\n\t}\n\n\tstatic json(data = undefined, init = {}) {\n\t\tconst body = JSON.stringify(data);\n\n\t\tif (body === undefined) {\n\t\t\tthrow new TypeError('data is not JSON serializable');\n\t\t}\n\n\t\tconst headers = new Headers(init && init.headers);\n\n\t\tif (!headers.has('content-type')) {\n\t\t\theaders.set('content-type', 'application/json');\n\t\t}\n\n\t\treturn new Response(body, {\n\t\t\t...init,\n\t\t\theaders\n\t\t});\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn 'Response';\n\t}\n}\n\nObject.defineProperties(Response.prototype, {\n\ttype: {enumerable: true},\n\turl: {enumerable: true},\n\tstatus: {enumerable: true},\n\tok: {enumerable: true},\n\tredirected: {enumerable: true},\n\tstatusText: {enumerable: true},\n\theaders: {enumerable: true},\n\tclone: {enumerable: true}\n});\n","/**\n * Request.js\n *\n * Request class contains server only options\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */\n\nimport {format as formatUrl} from 'node:url';\nimport {deprecate} from 'node:util';\nimport Headers from './headers.js';\nimport Body, {clone, extractContentType, getTotalBytes} from './body.js';\nimport {isAbortSignal} from './utils/is.js';\nimport {getSearch} from './utils/get-search.js';\nimport {\n\tvalidateReferrerPolicy, determineRequestsReferrer, DEFAULT_REFERRER_POLICY\n} from './utils/referrer.js';\n\nconst INTERNALS = Symbol('Request internals');\n\n/**\n * Check if `obj` is an instance of Request.\n *\n * @param  {*} object\n * @return {boolean}\n */\nconst isRequest = object => {\n\treturn (\n\t\ttypeof object === 'object' &&\n\t\ttypeof object[INTERNALS] === 'object'\n\t);\n};\n\nconst doBadDataWarn = deprecate(() => {},\n\t'.data is not a valid RequestInit property, use .body instead',\n\t'https://github.com/node-fetch/node-fetch/issues/1000 (request)');\n\n/**\n * Request class\n *\n * Ref: https://fetch.spec.whatwg.org/#request-class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nexport default class Request extends Body {\n\tconstructor(input, init = {}) {\n\t\tlet parsedURL;\n\n\t\t// Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)\n\t\tif (isRequest(input)) {\n\t\t\tparsedURL = new URL(input.url);\n\t\t} else {\n\t\t\tparsedURL = new URL(input);\n\t\t\tinput = {};\n\t\t}\n\n\t\tif (parsedURL.username !== '' || parsedURL.password !== '') {\n\t\t\tthrow new TypeError(`${parsedURL} is an url with embedded credentials.`);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tif (/^(delete|get|head|options|post|put)$/i.test(method)) {\n\t\t\tmethod = method.toUpperCase();\n\t\t}\n\n\t\tif (!isRequest(init) && 'data' in init) {\n\t\t\tdoBadDataWarn();\n\t\t}\n\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\tif ((init.body != null || (isRequest(input) && input.body !== null)) &&\n\t\t\t(method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tconst inputBody = init.body ?\n\t\t\tinit.body :\n\t\t\t(isRequest(input) && input.body !== null ?\n\t\t\t\tclone(input) :\n\t\t\t\tnull);\n\n\t\tsuper(inputBody, {\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody !== null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody, this);\n\t\t\tif (contentType) {\n\t\t\t\theaders.set('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ?\n\t\t\tinput.signal :\n\t\t\tnull;\n\t\tif ('signal' in init) {\n\t\t\tsignal = init.signal;\n\t\t}\n\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal or EventTarget');\n\t\t}\n\n\t\t// §5.4, Request constructor steps, step 15.1\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\tlet referrer = init.referrer == null ? input.referrer : init.referrer;\n\t\tif (referrer === '') {\n\t\t\t// §5.4, Request constructor steps, step 15.2\n\t\t\treferrer = 'no-referrer';\n\t\t} else if (referrer) {\n\t\t\t// §5.4, Request constructor steps, step 15.3.1, 15.3.2\n\t\t\tconst parsedReferrer = new URL(referrer);\n\t\t\t// §5.4, Request constructor steps, step 15.3.3, 15.3.4\n\t\t\treferrer = /^about:(\\/\\/)?client$/.test(parsedReferrer) ? 'client' : parsedReferrer;\n\t\t} else {\n\t\t\treferrer = undefined;\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal,\n\t\t\treferrer\n\t\t};\n\n\t\t// Node-fetch-only options\n\t\tthis.follow = init.follow === undefined ? (input.follow === undefined ? 20 : input.follow) : init.follow;\n\t\tthis.compress = init.compress === undefined ? (input.compress === undefined ? true : input.compress) : init.compress;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t\tthis.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;\n\t\tthis.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;\n\n\t\t// §5.4, Request constructor steps, step 16.\n\t\t// Default is empty string per https://fetch.spec.whatwg.org/#concept-request-referrer-policy\n\t\tthis.referrerPolicy = init.referrerPolicy || input.referrerPolicy || '';\n\t}\n\n\t/** @returns {string} */\n\tget method() {\n\t\treturn this[INTERNALS].method;\n\t}\n\n\t/** @returns {string} */\n\tget url() {\n\t\treturn formatUrl(this[INTERNALS].parsedURL);\n\t}\n\n\t/** @returns {Headers} */\n\tget headers() {\n\t\treturn this[INTERNALS].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS].redirect;\n\t}\n\n\t/** @returns {AbortSignal} */\n\tget signal() {\n\t\treturn this[INTERNALS].signal;\n\t}\n\n\t// https://fetch.spec.whatwg.org/#dom-request-referrer\n\tget referrer() {\n\t\tif (this[INTERNALS].referrer === 'no-referrer') {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (this[INTERNALS].referrer === 'client') {\n\t\t\treturn 'about:client';\n\t\t}\n\n\t\tif (this[INTERNALS].referrer) {\n\t\t\treturn this[INTERNALS].referrer.toString();\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tget referrerPolicy() {\n\t\treturn this[INTERNALS].referrerPolicy;\n\t}\n\n\tset referrerPolicy(referrerPolicy) {\n\t\tthis[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);\n\t}\n\n\t/**\n\t * Clone this request\n\t *\n\t * @return  Request\n\t */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn 'Request';\n\t}\n}\n\nObject.defineProperties(Request.prototype, {\n\tmethod: {enumerable: true},\n\turl: {enumerable: true},\n\theaders: {enumerable: true},\n\tredirect: {enumerable: true},\n\tclone: {enumerable: true},\n\tsignal: {enumerable: true},\n\treferrer: {enumerable: true},\n\treferrerPolicy: {enumerable: true}\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param {Request} request - A Request instance\n * @return The options object to be passed to http.request\n */\nexport const getNodeRequestOptions = request => {\n\tconst {parsedURL} = request[INTERNALS];\n\tconst headers = new Headers(request[INTERNALS].headers);\n\n\t// Fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body === null && /^(post|put)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\n\tif (request.body !== null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\t// Set Content-Length if totalBytes is a number (that is not NaN)\n\t\tif (typeof totalBytes === 'number' && !Number.isNaN(totalBytes)) {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// 4.1. Main fetch, step 2.6\n\t// > If request's referrer policy is the empty string, then set request's referrer policy to the\n\t// > default referrer policy.\n\tif (request.referrerPolicy === '') {\n\t\trequest.referrerPolicy = DEFAULT_REFERRER_POLICY;\n\t}\n\n\t// 4.1. Main fetch, step 2.7\n\t// > If request's referrer is not \"no-referrer\", set request's referrer to the result of invoking\n\t// > determine request's referrer.\n\tif (request.referrer && request.referrer !== 'no-referrer') {\n\t\trequest[INTERNALS].referrer = determineRequestsReferrer(request);\n\t} else {\n\t\trequest[INTERNALS].referrer = 'no-referrer';\n\t}\n\n\t// 4.5. HTTP-network-or-cache fetch, step 6.9\n\t// > If httpRequest's referrer is a URL, then append `Referer`/httpRequest's referrer, serialized\n\t// >  and isomorphic encoded, to httpRequest's header list.\n\tif (request[INTERNALS].referrer instanceof URL) {\n\t\theaders.set('Referer', request.referrer);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip, deflate, br');\n\t}\n\n\tlet {agent} = request;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\tconst search = getSearch(parsedURL);\n\n\t// Pass the full URL directly to request(), but overwrite the following\n\t// options:\n\tconst options = {\n\t\t// Overwrite search to retain trailing ? (issue #776)\n\t\tpath: parsedURL.pathname + search,\n\t\t// The following options are not expressed in the URL\n\t\tmethod: request.method,\n\t\theaders: headers[Symbol.for('nodejs.util.inspect.custom')](),\n\t\tinsecureHTTPParser: request.insecureHTTPParser,\n\t\tagent\n\t};\n\n\treturn {\n\t\t/** @type {URL} */\n\t\tparsedURL,\n\t\toptions\n\t};\n};\n","export const getSearch = parsedURL => {\n\tif (parsedURL.search) {\n\t\treturn parsedURL.search;\n\t}\n\n\tconst lastOffset = parsedURL.href.length - 1;\n\tconst hash = parsedURL.hash || (parsedURL.href[lastOffset] === '#' ? '#' : '');\n\treturn parsedURL.href[lastOffset - hash.length] === '?' ? '?' : '';\n};\n","import {isIP} from 'node:net';\n\n/**\n * @external URL\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}\n */\n\n/**\n * @module utils/referrer\n * @private\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy §8.4. Strip url for use as a referrer}\n * @param {string} URL\n * @param {boolean} [originOnly=false]\n */\nexport function stripURLForUseAsAReferrer(url, originOnly = false) {\n\t// 1. If url is null, return no referrer.\n\tif (url == null) { // eslint-disable-line no-eq-null, eqeqeq\n\t\treturn 'no-referrer';\n\t}\n\n\turl = new URL(url);\n\n\t// 2. If url's scheme is a local scheme, then return no referrer.\n\tif (/^(about|blob|data):$/.test(url.protocol)) {\n\t\treturn 'no-referrer';\n\t}\n\n\t// 3. Set url's username to the empty string.\n\turl.username = '';\n\n\t// 4. Set url's password to null.\n\t// Note: `null` appears to be a mistake as this actually results in the password being `\"null\"`.\n\turl.password = '';\n\n\t// 5. Set url's fragment to null.\n\t// Note: `null` appears to be a mistake as this actually results in the fragment being `\"#null\"`.\n\turl.hash = '';\n\n\t// 6. If the origin-only flag is true, then:\n\tif (originOnly) {\n\t\t// 6.1. Set url's path to null.\n\t\t// Note: `null` appears to be a mistake as this actually results in the path being `\"/null\"`.\n\t\turl.pathname = '';\n\n\t\t// 6.2. Set url's query to null.\n\t\t// Note: `null` appears to be a mistake as this actually results in the query being `\"?null\"`.\n\t\turl.search = '';\n\t}\n\n\t// 7. Return url.\n\treturn url;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}\n */\nexport const ReferrerPolicy = new Set([\n\t'',\n\t'no-referrer',\n\t'no-referrer-when-downgrade',\n\t'same-origin',\n\t'origin',\n\t'strict-origin',\n\t'origin-when-cross-origin',\n\t'strict-origin-when-cross-origin',\n\t'unsafe-url'\n]);\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}\n */\nexport const DEFAULT_REFERRER_POLICY = 'strict-origin-when-cross-origin';\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy §3. Referrer Policies}\n * @param {string} referrerPolicy\n * @returns {string} referrerPolicy\n */\nexport function validateReferrerPolicy(referrerPolicy) {\n\tif (!ReferrerPolicy.has(referrerPolicy)) {\n\t\tthrow new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);\n\t}\n\n\treturn referrerPolicy;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy §3.2. Is origin potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\nexport function isOriginPotentiallyTrustworthy(url) {\n\t// 1. If origin is an opaque origin, return \"Not Trustworthy\".\n\t// Not applicable\n\n\t// 2. Assert: origin is a tuple origin.\n\t// Not for implementations\n\n\t// 3. If origin's scheme is either \"https\" or \"wss\", return \"Potentially Trustworthy\".\n\tif (/^(http|ws)s:$/.test(url.protocol)) {\n\t\treturn true;\n\t}\n\n\t// 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return \"Potentially Trustworthy\".\n\tconst hostIp = url.host.replace(/(^\\[)|(]$)/g, '');\n\tconst hostIPVersion = isIP(hostIp);\n\n\tif (hostIPVersion === 4 && /^127\\./.test(hostIp)) {\n\t\treturn true;\n\t}\n\n\tif (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {\n\t\treturn true;\n\t}\n\n\t// 5. If origin's host component is \"localhost\" or falls within \".localhost\", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return \"Potentially Trustworthy\".\n\t// We are returning FALSE here because we cannot ensure conformance to\n\t// let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)\n\tif (url.host === 'localhost' || url.host.endsWith('.localhost')) {\n\t\treturn false;\n\t}\n\n\t// 6. If origin's scheme component is file, return \"Potentially Trustworthy\".\n\tif (url.protocol === 'file:') {\n\t\treturn true;\n\t}\n\n\t// 7. If origin's scheme component is one which the user agent considers to be authenticated, return \"Potentially Trustworthy\".\n\t// Not supported\n\n\t// 8. If origin has been configured as a trustworthy origin, return \"Potentially Trustworthy\".\n\t// Not supported\n\n\t// 9. Return \"Not Trustworthy\".\n\treturn false;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy §3.3. Is url potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\nexport function isUrlPotentiallyTrustworthy(url) {\n\t// 1. If url is \"about:blank\" or \"about:srcdoc\", return \"Potentially Trustworthy\".\n\tif (/^about:(blank|srcdoc)$/.test(url)) {\n\t\treturn true;\n\t}\n\n\t// 2. If url's scheme is \"data\", return \"Potentially Trustworthy\".\n\tif (url.protocol === 'data:') {\n\t\treturn true;\n\t}\n\n\t// Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were\n\t// created. Therefore, blobs created in a trustworthy origin will themselves be potentially\n\t// trustworthy.\n\tif (/^(blob|filesystem):$/.test(url.protocol)) {\n\t\treturn true;\n\t}\n\n\t// 3. Return the result of executing §3.2 Is origin potentially trustworthy? on url's origin.\n\treturn isOriginPotentiallyTrustworthy(url);\n}\n\n/**\n * Modifies the referrerURL to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerURLCallback\n * @param {external:URL} referrerURL\n * @returns {external:URL} modified referrerURL\n */\n\n/**\n * Modifies the referrerOrigin to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerOriginCallback\n * @param {external:URL} referrerOrigin\n * @returns {external:URL} modified referrerOrigin\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}\n * @param {Request} request\n * @param {object} o\n * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback\n * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback\n * @returns {external:URL} Request's referrer\n */\nexport function determineRequestsReferrer(request, {referrerURLCallback, referrerOriginCallback} = {}) {\n\t// There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for\n\t// these cases:\n\t// > Note: If request's referrer is \"no-referrer\", Fetch will not call into this algorithm.\n\t// > Note: If request's referrer policy is the empty string, Fetch will not call into this\n\t// > algorithm.\n\tif (request.referrer === 'no-referrer' || request.referrerPolicy === '') {\n\t\treturn null;\n\t}\n\n\t// 1. Let policy be request's associated referrer policy.\n\tconst policy = request.referrerPolicy;\n\n\t// 2. Let environment be request's client.\n\t// not applicable to node.js\n\n\t// 3. Switch on request's referrer:\n\tif (request.referrer === 'about:client') {\n\t\treturn 'no-referrer';\n\t}\n\n\t// \"a URL\": Let referrerSource be request's referrer.\n\tconst referrerSource = request.referrer;\n\n\t// 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.\n\tlet referrerURL = stripURLForUseAsAReferrer(referrerSource);\n\n\t// 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the\n\t//    origin-only flag set to true.\n\tlet referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);\n\n\t// 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set\n\t//    referrerURL to referrerOrigin.\n\tif (referrerURL.toString().length > 4096) {\n\t\treferrerURL = referrerOrigin;\n\t}\n\n\t// 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary\n\t//    policy considerations in the interests of minimizing data leakage. For example, the user\n\t//    agent could strip the URL down to an origin, modify its host, replace it with an empty\n\t//    string, etc.\n\tif (referrerURLCallback) {\n\t\treferrerURL = referrerURLCallback(referrerURL);\n\t}\n\n\tif (referrerOriginCallback) {\n\t\treferrerOrigin = referrerOriginCallback(referrerOrigin);\n\t}\n\n\t// 8.Execute the statements corresponding to the value of policy:\n\tconst currentURL = new URL(request.url);\n\n\tswitch (policy) {\n\t\tcase 'no-referrer':\n\t\t\treturn 'no-referrer';\n\n\t\tcase 'origin':\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'unsafe-url':\n\t\t\treturn referrerURL;\n\n\t\tcase 'strict-origin':\n\t\t\t// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 2. Return referrerOrigin.\n\t\t\treturn referrerOrigin.toString();\n\n\t\tcase 'strict-origin-when-cross-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 3. Return referrerOrigin.\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'same-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// 2. Return no referrer.\n\t\t\treturn 'no-referrer';\n\n\t\tcase 'origin-when-cross-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// Return referrerOrigin.\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'no-referrer-when-downgrade':\n\t\t\t// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 2. Return referrerURL.\n\t\t\treturn referrerURL;\n\n\t\tdefault:\n\t\t\tthrow new TypeError(`Invalid referrerPolicy: ${policy}`);\n\t}\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy §8.1. Parse a referrer policy from a Referrer-Policy header}\n * @param {Headers} headers Response headers\n * @returns {string} policy\n */\nexport function parseReferrerPolicyFromHeader(headers) {\n\t// 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`\n\t//    and response’s header list.\n\tconst policyTokens = (headers.get('referrer-policy') || '').split(/[,\\s]+/);\n\n\t// 2. Let policy be the empty string.\n\tlet policy = '';\n\n\t// 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty\n\t//    string, then set policy to token.\n\t// Note: This algorithm loops over multiple policy values to allow deployment of new policy\n\t// values with fallbacks for older user agents, as described in § 11.1 Unknown Policy Values.\n\tfor (const token of policyTokens) {\n\t\tif (token && ReferrerPolicy.has(token)) {\n\t\t\tpolicy = token;\n\t\t}\n\t}\n\n\t// 4. Return policy.\n\treturn policy;\n}\n","import {FetchBaseError} from './base.js';\n\n/**\n * AbortError interface for cancelled requests\n */\nexport class AbortError extends FetchBaseError {\n\tconstructor(message, type = 'aborted') {\n\t\tsuper(message, type);\n\t}\n}\n","import fetch from 'node-fetch';\n\nconst API_BASE_URI = '/_storybook/api';\n\nconst prepareRequest = (host: string, endpoint: string) => {\n    return `${host}${API_BASE_URI}${endpoint}`;\n}\n\ntype PreviewHtml = {\n    content: string\n};\n\nexport const getPreviewHtml = async () => {\n    console.log('HERE WE ARE');\n    const url = prepareRequest('http://localhost:8000', '/preview');\n    const response = await fetch(url, {\n        method: 'GET',\n        headers: {\n            Accept: 'application/json'\n        }\n    });\n\n    return await response.json() as PreviewHtml;\n}\n","import { join } from 'path';\nimport isGlob from 'is-glob';\nimport { glob } from 'glob';\nimport fs from 'node:fs';\nimport { logger } from '@storybook/node-logger';\nimport dedent from 'ts-dedent';\n\ntype AdditionalWatchPaths = {\n    dirs: string[];\n    files: string[];\n};\n\nexport const computeAdditionalWatchPaths = (paths: string[], baseDir: string) => {\n    const result: AdditionalWatchPaths = {\n        dirs: [],\n        files: [],\n    };\n\n    paths\n        .map((v) => join(baseDir, v))\n        .forEach((watchPath) => {\n            if (isGlob(watchPath)) {\n                result.files.push(\n                    ...glob.sync(watchPath, {\n                        dot: true,\n                        absolute: true,\n                    })\n                );\n            } else if (fs.existsSync(watchPath)) {\n                const stats = fs.lstatSync(watchPath);\n                (stats.isDirectory() ? result.dirs : result.files).push(watchPath);\n            } else {\n                logger.warn(dedent`\n                    Ignoring additional watch path '${watchPath}': path doesn't exists.\n                `);\n            }\n        });\n\n    return result;\n};\n","import expand from 'brace-expansion'\nimport { assertValidPattern } from './assert-valid-pattern.js'\nimport { AST, ExtglobType } from './ast.js'\nimport { escape } from './escape.js'\nimport { unescape } from './unescape.js'\n\ntype Platform =\n  | 'aix'\n  | 'android'\n  | 'darwin'\n  | 'freebsd'\n  | 'haiku'\n  | 'linux'\n  | 'openbsd'\n  | 'sunos'\n  | 'win32'\n  | 'cygwin'\n  | 'netbsd'\n\nexport interface MinimatchOptions {\n  nobrace?: boolean\n  nocomment?: boolean\n  nonegate?: boolean\n  debug?: boolean\n  noglobstar?: boolean\n  noext?: boolean\n  nonull?: boolean\n  windowsPathsNoEscape?: boolean\n  allowWindowsEscape?: boolean\n  partial?: boolean\n  dot?: boolean\n  nocase?: boolean\n  nocaseMagicOnly?: boolean\n  magicalBraces?: boolean\n  matchBase?: boolean\n  flipNegate?: boolean\n  preserveMultipleSlashes?: boolean\n  optimizationLevel?: number\n  platform?: Platform\n  windowsNoMagicRoot?: boolean\n}\n\nexport const minimatch = (\n  p: string,\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/\nconst starDotExtTest = (ext: string) => (f: string) =>\n  !f.startsWith('.') && f.endsWith(ext)\nconst starDotExtTestDot = (ext: string) => (f: string) => f.endsWith(ext)\nconst starDotExtTestNocase = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => !f.startsWith('.') && f.toLowerCase().endsWith(ext)\n}\nconst starDotExtTestNocaseDot = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => f.toLowerCase().endsWith(ext)\n}\nconst starDotStarRE = /^\\*+\\.\\*+$/\nconst starDotStarTest = (f: string) => !f.startsWith('.') && f.includes('.')\nconst starDotStarTestDot = (f: string) =>\n  f !== '.' && f !== '..' && f.includes('.')\nconst dotStarRE = /^\\.\\*+$/\nconst dotStarTest = (f: string) => f !== '.' && f !== '..' && f.startsWith('.')\nconst starRE = /^\\*+$/\nconst starTest = (f: string) => f.length !== 0 && !f.startsWith('.')\nconst starTestDot = (f: string) => f.length !== 0 && f !== '.' && f !== '..'\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/\nconst qmarksTestNocase = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestNocaseDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTest = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTestNoExt = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && !f.startsWith('.')\n}\nconst qmarksTestNoExtDot = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && f !== '.' && f !== '..'\n}\n\n/* c8 ignore start */\nconst defaultPlatform: Platform = (\n  typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n      process.platform\n    : 'posix'\n) as Platform\ntype Sep = '\\\\' | '/'\nconst path: { [k: string]: { sep: Sep } } = {\n  win32: { sep: '\\\\' },\n  posix: { sep: '/' },\n}\n/* c8 ignore stop */\n\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep\nminimatch.sep = sep\n\nexport const GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?'\n\nexport const filter =\n  (pattern: string, options: MinimatchOptions = {}) =>\n  (p: string) =>\n    minimatch(p, pattern, options)\nminimatch.filter = filter\n\nconst ext = (a: MinimatchOptions, b: MinimatchOptions = {}) =>\n  Object.assign({}, a, b)\n\nexport const defaults = (def: MinimatchOptions): typeof minimatch => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p: string, pattern: string, options: MinimatchOptions = {}) =>\n    orig(p, pattern, ext(def, options))\n\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern: string, options: MinimatchOptions = {}) {\n        super(pattern, ext(def, options))\n      }\n      static defaults(options: MinimatchOptions) {\n        return orig.defaults(ext(def, options)).Minimatch\n      }\n    },\n\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(\n        type: ExtglobType | null,\n        parent?: AST,\n        options: MinimatchOptions = {}\n      ) {\n        super(type, parent, ext(def, options))\n      }\n      /* c8 ignore stop */\n\n      static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options))\n      }\n    },\n\n    unescape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.unescape(s, ext(def, options)),\n\n    escape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.escape(s, ext(def, options)),\n\n    filter: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.filter(pattern, ext(def, options)),\n\n    defaults: (options: MinimatchOptions) => orig.defaults(ext(def, options)),\n\n    makeRe: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.makeRe(pattern, ext(def, options)),\n\n    braceExpand: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.braceExpand(pattern, ext(def, options)),\n\n    match: (list: string[], pattern: string, options: MinimatchOptions = {}) =>\n      orig.match(list, pattern, ext(def, options)),\n\n    sep: orig.sep,\n    GLOBSTAR: GLOBSTAR as typeof GLOBSTAR,\n  })\n}\nminimatch.defaults = defaults\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\nminimatch.braceExpand = braceExpand\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\nexport const makeRe = (pattern: string, options: MinimatchOptions = {}) =>\n  new Minimatch(pattern, options).makeRe()\nminimatch.makeRe = makeRe\n\nexport const match = (\n  list: string[],\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\nminimatch.match = match\n\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\nexport type MMRegExp = RegExp & {\n  _src?: string\n  _glob?: string\n}\n\nexport type ParseReturnFiltered = string | MMRegExp | typeof GLOBSTAR\nexport type ParseReturn = ParseReturnFiltered | false\n\nexport class Minimatch {\n  options: MinimatchOptions\n  set: ParseReturnFiltered[][]\n  pattern: string\n\n  windowsPathsNoEscape: boolean\n  nonegate: boolean\n  negate: boolean\n  comment: boolean\n  empty: boolean\n  preserveMultipleSlashes: boolean\n  partial: boolean\n  globSet: string[]\n  globParts: string[][]\n  nocase: boolean\n\n  isWindows: boolean\n  platform: Platform\n  windowsNoMagicRoot: boolean\n\n  regexp: false | null | MMRegExp\n  constructor(pattern: string, options: MinimatchOptions = {}) {\n    assertValidPattern(pattern)\n\n    options = options || {}\n    this.options = options\n    this.pattern = pattern\n    this.platform = options.platform || defaultPlatform\n    this.isWindows = this.platform === 'win32'\n    this.windowsPathsNoEscape =\n      !!options.windowsPathsNoEscape || options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes\n    this.regexp = null\n    this.negate = false\n    this.nonegate = !!options.nonegate\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n    this.nocase = !!this.options.nocase\n    this.windowsNoMagicRoot =\n      options.windowsNoMagicRoot !== undefined\n        ? options.windowsNoMagicRoot\n        : !!(this.isWindows && this.nocase)\n\n    this.globSet = []\n    this.globParts = []\n    this.set = []\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  hasMagic(): boolean {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true\n      }\n    }\n    return false\n  }\n\n  debug(..._: any[]) {}\n\n  make() {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())]\n\n    if (options.debug) {\n      this.debug = (...args: any[]) => console.error(...args)\n    }\n\n    this.debug(this.pattern, this.globSet)\n\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s))\n    this.globParts = this.preprocess(rawGlobParts)\n    this.debug(this.pattern, this.globParts)\n\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC =\n          s[0] === '' &&\n          s[1] === '' &&\n          (s[2] === '?' || !globMagic.test(s[2])) &&\n          !globMagic.test(s[3])\n        const isDrive = /^[a-z]:/i.test(s[0])\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))]\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))]\n        }\n      }\n      return s.map(ss => this.parse(ss))\n    })\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(\n      s => s.indexOf(false) === -1\n    ) as ParseReturnFiltered[][]\n\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i]\n        if (\n          p[0] === '' &&\n          p[1] === '' &&\n          this.globParts[i][2] === '?' &&\n          typeof p[3] === 'string' &&\n          /^[a-z]:$/i.test(p[3])\n        ) {\n          p[2] = '?'\n        }\n      }\n    }\n\n    this.debug(this.pattern, this.set)\n  }\n\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts: string[][]) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*'\n          }\n        }\n      }\n    }\n\n    const { optimizationLevel = 1 } = this.options\n\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts)\n      globParts = this.secondPhasePreProcess(globParts)\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts)\n    } else {\n      globParts = this.adjascentGlobstarOptimize(globParts)\n    }\n\n    return globParts\n  }\n\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      let gs: number = -1\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs\n        while (parts[i + 1] === '**') {\n          i++\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs)\n        }\n      }\n      return parts\n    })\n  }\n\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set: string[], part) => {\n        const prev = set[set.length - 1]\n        if (part === '**' && prev === '**') {\n          return set\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop()\n            return set\n          }\n        }\n        set.push(part)\n        return set\n      }, [])\n      return parts.length === 0 ? [''] : parts\n    })\n  }\n\n  levelTwoFileOptimize(parts: string | string[]) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts)\n    }\n    let didSomething: boolean = false\n    do {\n      didSomething = false\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i]\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue\n          if (p === '.' || p === '') {\n            didSomething = true\n            parts.splice(i, 1)\n            i--\n          }\n        }\n        if (\n          parts[0] === '.' &&\n          parts.length === 2 &&\n          (parts[1] === '.' || parts[1] === '')\n        ) {\n          didSomething = true\n          parts.pop()\n        }\n      }\n\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd: number = 0\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1]\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true\n          parts.splice(dd - 1, 2)\n          dd -= 2\n        }\n      }\n    } while (didSomething)\n    return parts.length === 0 ? [''] : parts\n  }\n\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts: string[][]) {\n    let didSomething = false\n    do {\n      didSomething = false\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs: number = -1\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss: number = gs\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs)\n          }\n\n          let next = parts[gs + 1]\n          const p = parts[gs + 2]\n          const p2 = parts[gs + 3]\n          if (next !== '..') continue\n          if (\n            !p ||\n            p === '.' ||\n            p === '..' ||\n            !p2 ||\n            p2 === '.' ||\n            p2 === '..'\n          ) {\n            continue\n          }\n          didSomething = true\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1)\n          const other = parts.slice(0)\n          other[gs] = '**'\n          globParts.push(other)\n          gs--\n        }\n\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i]\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue\n            if (p === '.' || p === '') {\n              didSomething = true\n              parts.splice(i, 1)\n              i--\n            }\n          }\n          if (\n            parts[0] === '.' &&\n            parts.length === 2 &&\n            (parts[1] === '.' || parts[1] === '')\n          ) {\n            didSomething = true\n            parts.pop()\n          }\n        }\n\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd: number = 0\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1]\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true\n            const needDot = dd === 1 && parts[dd + 1] === '**'\n            const splin = needDot ? ['.'] : []\n            parts.splice(dd - 1, 2, ...splin)\n            if (parts.length === 0) parts.push('')\n            dd -= 2\n          }\n        }\n      }\n    } while (didSomething)\n\n    return globParts\n  }\n\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts: string[][]): string[][] {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(\n          globParts[i],\n          globParts[j],\n          !this.preserveMultipleSlashes\n        )\n        if (!matched) continue\n        globParts[i] = matched\n        globParts[j] = []\n      }\n    }\n    return globParts.filter(gs => gs.length)\n  }\n\n  partsMatch(\n    a: string[],\n    b: string[],\n    emptyGSMatch: boolean = false\n  ): false | string[] {\n    let ai = 0\n    let bi = 0\n    let result: string[] = []\n    let which: string = ''\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai])\n        ai++\n        bi++\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai])\n        ai++\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi])\n        bi++\n      } else if (\n        a[ai] === '*' &&\n        b[bi] &&\n        (this.options.dot || !b[bi].startsWith('.')) &&\n        b[bi] !== '**'\n      ) {\n        if (which === 'b') return false\n        which = 'a'\n        result.push(a[ai])\n        ai++\n        bi++\n      } else if (\n        b[bi] === '*' &&\n        a[ai] &&\n        (this.options.dot || !a[ai].startsWith('.')) &&\n        a[ai] !== '**'\n      ) {\n        if (which === 'a') return false\n        which = 'b'\n        result.push(b[bi])\n        ai++\n        bi++\n      } else {\n        return false\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result\n  }\n\n  parseNegate() {\n    if (this.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file: string[], pattern: ParseReturn[], partial: boolean = false) {\n    const options = this.options\n\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0])\n      const fileUNC =\n        !fileDrive &&\n        file[0] === '' &&\n        file[1] === '' &&\n        file[2] === '?' &&\n        /^[a-z]:$/i.test(file[3])\n\n      const patternDrive =\n        typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0])\n      const patternUNC =\n        !patternDrive &&\n        pattern[0] === '' &&\n        pattern[1] === '' &&\n        pattern[2] === '?' &&\n        typeof pattern[3] === 'string' &&\n        /^[a-z]:$/i.test(pattern[3])\n\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd]: [string, string] = [file[fdi], pattern[pdi] as string]\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd\n          if (pdi > fdi) {\n            pattern = pattern.slice( pdi)\n          } else if (fdi > pdi) {\n            file = file.slice(fdi)\n          }\n        }\n      }\n    }\n\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const { optimizationLevel = 1 } = this.options\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file)\n    }\n\n    this.debug('matchOne', this, { file, pattern })\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (\n      var fi = 0, pi = 0, fl = file.length, pl = pattern.length;\n      fi < fl && pi < pl;\n      fi++, pi++\n    ) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false\n      }\n      /* c8 ignore stop */\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (\n              file[fi] === '.' ||\n              file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')\n            )\n              return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (\n              swallowee === '.' ||\n              swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')\n            ) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) {\n            return true\n          }\n        }\n        /* c8 ignore stop */\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit: boolean\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = p.test(f)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === ''\n\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?')\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse(pattern: string): ParseReturn {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') return GLOBSTAR\n    if (pattern === '') return ''\n\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m: RegExpMatchArray | null\n    let fastTest: null | ((f: string) => boolean) = null\n    if ((m = pattern.match(starRE))) {\n      fastTest = options.dot ? starTestDot : starTest\n    } else if ((m = pattern.match(starDotExtRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? starDotExtTestNocaseDot\n            : starDotExtTestNocase\n          : options.dot\n          ? starDotExtTestDot\n          : starDotExtTest\n      )(m[1])\n    } else if ((m = pattern.match(qmarksRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? qmarksTestNocaseDot\n            : qmarksTestNocase\n          : options.dot\n          ? qmarksTestDot\n          : qmarksTest\n      )(m)\n    } else if ((m = pattern.match(starDotStarRE))) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest\n    } else if ((m = pattern.match(dotStarRE))) {\n      fastTest = dotStarTest\n    }\n\n    const re = AST.fromGlob(pattern, this.options).toMMPattern()\n    return fastTest ? Object.assign(re, { test: fastTest }) : re\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar\n      ? star\n      : options.dot\n      ? twoStarDot\n      : twoStarNoDot\n    const flags = new Set(options.nocase ? ['i'] : [])\n\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set\n      .map(pattern => {\n        const pp: (string | typeof GLOBSTAR)[] = pattern.map(p => {\n          if (p instanceof RegExp) {\n            for (const f of p.flags.split('')) flags.add(f)\n          }\n          return typeof p === 'string'\n            ? regExpEscape(p)\n            : p === GLOBSTAR\n            ? GLOBSTAR\n            : p._src\n        }) as (string | typeof GLOBSTAR)[]\n        pp.forEach((p, i) => {\n          const next = pp[i + 1]\n          const prev = pp[i - 1]\n          if (p !== GLOBSTAR || prev === GLOBSTAR) {\n            return\n          }\n          if (prev === undefined) {\n            if (next !== undefined && next !== GLOBSTAR) {\n              pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next\n            } else {\n              pp[i] = twoStar\n            }\n          } else if (next === undefined) {\n            pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?'\n          } else if (next !== GLOBSTAR) {\n            pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next\n            pp[i + 1] = GLOBSTAR\n          }\n        })\n        return pp.filter(p => p !== GLOBSTAR).join('/')\n      })\n      .join('|')\n\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', '']\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$'\n\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''))\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false\n    }\n    /* c8 ignore stop */\n    return this.regexp\n  }\n\n  slashSplit(p: string) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/')\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)]\n    } else {\n      return p.split(/\\/+/)\n    }\n  }\n\n  match(f: string, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false\n    }\n    if (this.empty) {\n      return f === ''\n    }\n\n    if (f === '/' && partial) {\n      return true\n    }\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f)\n    this.debug(this.pattern, 'split', ff)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename: string = ff[ff.length - 1]\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i]\n      }\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = ff\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) {\n          return true\n        }\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false\n    }\n    return this.negate\n  }\n\n  static defaults(def: MinimatchOptions) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js'\nexport { escape } from './escape.js'\nexport { unescape } from './unescape.js'\n/* c8 ignore stop */\nminimatch.AST = AST\nminimatch.Minimatch = Minimatch\nminimatch.escape = escape\nminimatch.unescape = unescape\n","const MAX_PATTERN_LENGTH = 1024 * 64\nexport const assertValidPattern: (pattern: any) => void = (\n  pattern: any\n): asserts pattern is string => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n","// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses: { [k: string]: [e: string, u: boolean, n?: boolean] } = {\n  '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n  '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n  '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n  '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n  '[:cntrl:]': ['\\\\p{Cc}', true],\n  '[:digit:]': ['\\\\p{Nd}', true],\n  '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n  '[:lower:]': ['\\\\p{Ll}', true],\n  '[:print:]': ['\\\\p{C}', true],\n  '[:punct:]': ['\\\\p{P}', true],\n  '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n  '[:upper:]': ['\\\\p{Lu}', true],\n  '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n  '[:xdigit:]': ['A-Fa-f0-9', false],\n}\n\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s: string) => s.replace(/[[\\]\\\\-]/g, '\\\\$&')\n// escape all regexp magic characters\nconst regexpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges: string[]): string => ranges.join('')\n\nexport type ParseClassResult = [\n  src: string,\n  uFlag: boolean,\n  consumed: number,\n  hasMagic: boolean\n]\n\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (\n  glob: string,\n  position: number\n): ParseClassResult => {\n  const pos = position\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression')\n  }\n  /* c8 ignore stop */\n  const ranges: string[] = []\n  const negs: string[] = []\n\n  let i = pos + 1\n  let sawStart = false\n  let uflag = false\n  let escaping = false\n  let negate = false\n  let endPos = pos\n  let rangeStart = ''\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i)\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true\n      i++\n      continue\n    }\n\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1\n      break\n    }\n\n    sawStart = true\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true\n        i++\n        continue\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true]\n          }\n          i += cls.length\n          if (neg) negs.push(unip)\n          else ranges.push(unip)\n          uflag = uflag || u\n          continue WHILE\n        }\n      }\n    }\n\n    // now it's just a normal character, effectively\n    escaping = false\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c))\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c))\n      }\n      rangeStart = ''\n      i++\n      continue\n    }\n\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'))\n      i += 2\n      continue\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c\n      i += 2\n      continue\n    }\n\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c))\n    i++\n  }\n\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false]\n  }\n\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true]\n  }\n\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (\n    negs.length === 0 &&\n    ranges.length === 1 &&\n    /^\\\\?.$/.test(ranges[0]) &&\n    !negate\n  ) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0]\n    return [regexpEscape(r), false, endPos - pos, false]\n  }\n\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']'\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']'\n  const comb =\n    ranges.length && negs.length\n      ? '(' + sranges + '|' + snegs + ')'\n      : ranges.length\n      ? sranges\n      : snegs\n\n  return [comb, uflag, endPos - pos, true]\n}\n","import { MinimatchOptions } from './index.js'\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  return windowsPathsNoEscape\n    ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n    : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1')\n}\n","// parse a single path portion\n\nimport { parseClass } from './brace-expressions.js'\nimport { MinimatchOptions, MMRegExp } from './index.js'\nimport { unescape } from './unescape.js'\n\n// classes [] are handled by the parseClass method\n// for positive extglobs, we sub-parse the contents, and combine,\n// with the appropriate regexp close.\n// for negative extglobs, we sub-parse the contents, but then\n// have to include the rest of the pattern, then the parent, etc.,\n// as the thing that cannot be because RegExp negative lookaheads\n// are different from globs.\n//\n// So for example:\n// a@(i|w!(x|y)z|j)b => ^a(i|w((!?(x|y)zb).*)z|j)b$\n//   1   2 3   4 5 6      1   2    3   46      5 6\n//\n// Assembling the extglob requires not just the negated patterns themselves,\n// but also anything following the negative patterns up to the boundary\n// of the current pattern, plus anything following in the parent pattern.\n//\n//\n// So, first, we parse the string into an AST of extglobs, without turning\n// anything into regexps yet.\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']\n//\n// Then, for all the negative extglobs, we append whatever comes after in\n// each parent as their tail\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']\n//\n// Lastly, we turn each of these pieces into a regexp, and join\n//\n//                                 v----- .* because there's more following,\n//                                 v    v  otherwise, .+ because it must be\n//                                 v    v  *something* there.\n// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']\n//   copy what follows into here--^^^^^\n// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']\n// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']\n\nexport type ExtglobType = '!' | '?' | '+' | '*' | '@'\nconst types = new Set<ExtglobType>(['!', '?', '+', '*', '@'])\nconst isExtglobType = (c: string): c is ExtglobType =>\n  types.has(c as ExtglobType)\n\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))'\nconst startNoDot = '(?!\\\\.)'\n\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.'])\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.'])\nconst reSpecials = new Set('().*{}+?[]^$\\\\!')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// any single thing other than /\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?'\n\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\n\nexport class AST {\n  type: ExtglobType | null\n  readonly #root: AST\n\n  #hasMagic?: boolean\n  #uflag: boolean = false\n  #parts: (string | AST)[] = []\n  readonly #parent?: AST\n  readonly #parentIndex: number\n  #negs: AST[]\n  #filledNegs: boolean = false\n  #options: MinimatchOptions\n  #toString?: string\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt: boolean = false\n\n  constructor(\n    type: ExtglobType | null,\n    parent?: AST,\n    options: MinimatchOptions = {}\n  ) {\n    this.type = type\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true\n    this.#parent = parent\n    this.#root = this.#parent ? this.#parent.#root : this\n    this.#options = this.#root === this ? options : this.#root.#options\n    this.#negs = this.#root === this ? [] : this.#root.#negs\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this)\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0\n  }\n\n  get hasMagic(): boolean | undefined {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue\n      if (p.type || p.hasMagic) return (this.#hasMagic = true)\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic\n  }\n\n  // reconstructs the pattern\n  toString(): string {\n    if (this.#toString !== undefined) return this.#toString\n    if (!this.type) {\n      return (this.#toString = this.#parts.map(p => String(p)).join(''))\n    } else {\n      return (this.#toString =\n        this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')')\n    }\n  }\n\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root')\n    if (this.#filledNegs) return this\n    /* c8 ignore stop */\n\n    // call toString() once to fill this out\n    this.toString()\n    this.#filledNegs = true\n    let n: AST | undefined\n    while ((n = this.#negs.pop())) {\n      if (n.type !== '!') continue\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p: AST | undefined = n\n      let pp = p.#parent\n      while (pp) {\n        for (\n          let i = p.#parentIndex + 1;\n          !pp.type && i < pp.#parts.length;\n          i++\n        ) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??')\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i])\n          }\n        }\n        p = pp\n        pp = p.#parent\n      }\n    }\n    return this\n  }\n\n  push(...parts: (string | AST)[]) {\n    for (const p of parts) {\n      if (p === '') continue\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p)\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p)\n    }\n  }\n\n  toJSON() {\n    const ret: any[] =\n      this.type === null\n        ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n        : [this.type, ...this.#parts.map(p => (p as AST).toJSON())]\n    if (this.isStart() && !this.type) ret.unshift([])\n    if (\n      this.isEnd() &&\n      (this === this.#root ||\n        (this.#root.#filledNegs && this.#parent?.type === '!'))\n    ) {\n      ret.push({})\n    }\n    return ret\n  }\n\n  isStart(): boolean {\n    if (this.#root === this) return true\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false\n    if (this.#parentIndex === 0) return true\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i]\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isEnd(): boolean {\n    if (this.#root === this) return true\n    if (this.#parent?.type === '!') return true\n    if (!this.#parent?.isEnd()) return false\n    if (!this.type) return this.#parent?.isEnd()\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1\n  }\n\n  copyIn(part: AST | string) {\n    if (typeof part === 'string') this.push(part)\n    else this.push(part.clone(this))\n  }\n\n  clone(parent: AST) {\n    const c = new AST(this.type, parent)\n    for (const p of this.#parts) {\n      c.copyIn(p)\n    }\n    return c\n  }\n\n  static #parseAST(\n    str: string,\n    ast: AST,\n    pos: number,\n    opt: MinimatchOptions\n  ): number {\n    let escaping = false\n    let inBrace = false\n    let braceStart = -1\n    let braceNeg = false\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos\n      let acc = ''\n      while (i < str.length) {\n        const c = str.charAt(i++)\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping\n          acc += c\n          continue\n        }\n\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false\n          }\n          acc += c\n          continue\n        } else if (c === '[') {\n          inBrace = true\n          braceStart = i\n          braceNeg = false\n          acc += c\n          continue\n        }\n\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc)\n          acc = ''\n          const ext = new AST(c, ast)\n          i = AST.#parseAST(str, ext, i, opt)\n          ast.push(ext)\n          continue\n        }\n        acc += c\n      }\n      ast.push(acc)\n      return i\n    }\n\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1\n    let part = new AST(null, ast)\n    const parts: AST[] = []\n    let acc = ''\n    while (i < str.length) {\n      const c = str.charAt(i++)\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping\n        acc += c\n        continue\n      }\n\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false\n        }\n        acc += c\n        continue\n      } else if (c === '[') {\n        inBrace = true\n        braceStart = i\n        braceNeg = false\n        acc += c\n        continue\n      }\n\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc)\n        acc = ''\n        const ext = new AST(c, part)\n        part.push(ext)\n        i = AST.#parseAST(str, ext, i, opt)\n        continue\n      }\n      if (c === '|') {\n        part.push(acc)\n        acc = ''\n        parts.push(part)\n        part = new AST(null, ast)\n        continue\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true\n        }\n        part.push(acc)\n        acc = ''\n        ast.push(...parts, part)\n        return i\n      }\n      acc += c\n    }\n\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null\n    ast.#hasMagic = undefined\n    ast.#parts = [str.substring(pos - 1)]\n    return i\n  }\n\n  static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n    const ast = new AST(null, undefined, options)\n    AST.#parseAST(pattern, ast, 0, options)\n    return ast\n  }\n\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern(): MMRegExp | string {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern()\n    /* c8 ignore stop */\n    const glob = this.toString()\n    const [re, body, hasMagic, uflag] = this.toRegExpSource()\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic =\n      hasMagic ||\n      this.#hasMagic ||\n      (this.#options.nocase &&\n        !this.#options.nocaseMagicOnly &&\n        glob.toUpperCase() !== glob.toLowerCase())\n    if (!anyMagic) {\n      return body\n    }\n\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '')\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob,\n    })\n  }\n\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(\n    allowDot?: boolean\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    const dot = allowDot ?? !!this.#options.dot\n    if (this.#root === this) this.#fillNegs()\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd()\n      const src = this.#parts\n        .map(p => {\n          const [re, _, hasMagic, uflag] =\n            typeof p === 'string'\n              ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n              : p.toRegExpSource(allowDot)\n          this.#hasMagic = this.#hasMagic || hasMagic\n          this.#uflag = this.#uflag || uflag\n          return re\n        })\n        .join('')\n\n      let start = ''\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed =\n            this.#parts.length === 1 && justDots.has(this.#parts[0])\n          if (!dotTravAllowed) {\n            const aps = addPatternStart\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n              // dots are allowed, and the pattern starts with [ or .\n              (dot && aps.has(src.charAt(0))) ||\n              // the pattern starts with \\., and then [ or .\n              (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n              // the pattern starts with \\.\\., and then [ or .\n              (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)))\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0))\n\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : ''\n          }\n        }\n      }\n\n      // append the \"end of path portion\" pattern to negation tails\n      let end = ''\n      if (\n        this.isEnd() &&\n        this.#root.#filledNegs &&\n        this.#parent?.type === '!'\n      ) {\n        end = '(?:$|\\\\/)'\n      }\n      const final = start + src + end\n      return [\n        final,\n        unescape(src),\n        (this.#hasMagic = !!this.#hasMagic),\n        this.#uflag,\n      ]\n    }\n\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n\n    const repeated = this.type === '*' || this.type === '+'\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:'\n    let body = this.#partsToRegExp(dot)\n\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString()\n      this.#parts = [s]\n      this.type = null\n      this.#hasMagic = undefined\n      return [s, unescape(this.toString()), false, false]\n    }\n\n    // XXX abstract out this map method\n    let bodyDotAllowed =\n      !repeated || allowDot || dot || !startNoDot\n        ? ''\n        : this.#partsToRegExp(true)\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = ''\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`\n    }\n\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = ''\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty\n    } else {\n      const close =\n        this.type === '!'\n          ? // !() must match something,but !(x) can match ''\n            '))' +\n            (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n            star +\n            ')'\n          : this.type === '@'\n          ? ')'\n          : this.type === '?'\n          ? ')?'\n          : this.type === '+' && bodyDotAllowed\n          ? ')'\n          : this.type === '*' && bodyDotAllowed\n          ? `)?`\n          : `)${this.type}`\n      final = start + body + close\n    }\n    return [\n      final,\n      unescape(body),\n      (this.#hasMagic = !!this.#hasMagic),\n      this.#uflag,\n    ]\n  }\n\n  #partsToRegExp(dot: boolean) {\n    return this.#parts\n      .map(p => {\n        // extglob ASTs should only contain parent ASTs\n        /* c8 ignore start */\n        if (typeof p === 'string') {\n          throw new Error('string type in extglob ast??')\n        }\n        /* c8 ignore stop */\n        // can ignore hasMagic, because extglobs are already always magic\n        const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot)\n        this.#uflag = this.#uflag || uflag\n        return re\n      })\n      .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n      .join('|')\n  }\n\n  static #parseGlob(\n    glob: string,\n    hasMagic: boolean | undefined,\n    noEmpty: boolean = false\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    let escaping = false\n    let re = ''\n    let uflag = false\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i)\n      if (escaping) {\n        escaping = false\n        re += (reSpecials.has(c) ? '\\\\' : '') + c\n        continue\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\'\n        } else {\n          escaping = true\n        }\n        continue\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = parseClass(glob, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n          continue\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty\n        else re += star\n        hasMagic = true\n        continue\n      }\n      if (c === '?') {\n        re += qmark\n        hasMagic = true\n        continue\n      }\n      re += regExpEscape(c)\n    }\n    return [re, unescape(glob), !!hasMagic, uflag]\n  }\n}\n","import { MinimatchOptions } from './index.js'\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  // don't need to escape +@! because we escape the parens\n  // that make those magic, and escaping ! as [!] isn't valid,\n  // because [!]] is a valid glob class meaning not ']'.\n  return windowsPathsNoEscape\n    ? s.replace(/[?*()[\\]]/g, '[$&]')\n    : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&')\n}\n","/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   */\n  export type DisposeReason = 'evict' | 'set' | 'delete'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Status object that may be passed to {@link LRUCache#fetch},\n   * {@link LRUCache#get}, {@link LRUCache#set}, and {@link LRUCache#has}.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no fetchMethod, so {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed\n     * by default, and MAY live in the cache long after they have expired.\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * Must be an integer number of ms. If set to 0, this indicates \"no TTL\"\n     *\n     * @default 0\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     * Note that this may significantly degrade performance,\n     * especially if the cache is storing a large number of items.\n     * It is almost always best to just leave the stale items in\n     * the cache, and let them fall out as new items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * @default false\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * Update the age of items on {@link LRUCache#get}, renewing their TTL\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * @default false\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * Update the age of items on {@link LRUCache#has}, renewing their TTL\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * @default false\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the cache.\n     * This can be handy if you want to close file descriptors or do other\n     * cleanup tasks when items are no longer accessible. Called with `key,\n     * value`.  It's called before actually removing the item from the\n     * internal cache, so it is *NOT* safe to re-add them.\n     *\n     * Use {@link OptionsBase.disposeAfter} if you wish to dispose items after\n     * they have been full removed, when it is safe to add them back to the\n     * cache.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when\n     * setting a new value for an existing key (ie, when updating a value\n     * rather than inserting a new value).  Note that the TTL value is\n     * _always_ set (if provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * If you wish to track item size, you must provide a maxSize\n     * note that we still will only keep up to max *actual items*,\n     * if max is set, so size tracking may cause fewer than max items\n     * to be stored.  At the extreme, a single item of maxSize size\n     * will cause everything else in the cache to be dropped when it\n     * is added.  Use with caution!\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod}, then it will not be stored in the\n     * cache.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the\n     * {@link LRUCache#fetch} fails, not any other times.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches an `'abort'`\n     * event, whether user-triggered, or due to internal cache behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls are not\n     * immediately resolved or rejected when they are aborted, and instead\n     * take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * All properties from the options object (with the exception of\n * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as\n * normal public members. (`max` and `maxBase` are read-only getters.)\n * Changing any of these will alter the defaults for subsequent method calls,\n * but is otherwise safe.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown> implements Map<K,V> {\n  // properties coming in from the options of these, only max and maxSize\n  // really *need* to be protected. The rest can be modified, as they just\n  // set defaults for various methods.\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the remaining TTL time for a given entry key\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.delete(this.#keyList[index] as K)\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string description of an object.\n   * Called by the built-in method Object.prototype.toString.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to Array.find().  fn is called as fn(value, key, cache).\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from\n   * most recently used to least recently used.  fn is called as\n   * fn(value, key, cache).  Does not update age or recenty of use.\n   * Does not iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.delete(this.#keyList[i] as K)\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a\n   * single key. Always returns stale values, if their info is found in the\n   * cache, so be sure to check for expired TTLs if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to cache.load()\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   * Note that the shape of the resulting cache may be different if the\n   * same options are not used in both caches.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.delete(k)\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.delete(k)\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.delete(k)\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   */\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.delete(k)\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.clear()\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, 'delete')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, 'delete'])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, 'delete')\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, 'delete'])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n","import { LRUCache } from 'lru-cache'\nimport { posix, win32 } from 'path'\n\nimport { fileURLToPath } from 'url'\n\nimport * as actualFS from 'fs'\nimport {\n  lstatSync,\n  readdir as readdirCB,\n  readdirSync,\n  readlinkSync,\n  realpathSync as rps,\n} from 'fs'\nconst realpathSync = rps.native\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\nimport { lstat, readdir, readlink, realpath } from 'fs/promises'\n\nimport type { Dirent, Stats } from 'fs'\nimport { Minipass } from 'minipass'\n\n/**\n * An object that will be used to override the default `fs`\n * methods.  Any methods that are not overridden will use Node's\n * built-in implementations.\n *\n * - lstatSync\n * - readdir (callback `withFileTypes` Dirent variant, used for\n *   readdirCB and most walks)\n * - readdirSync\n * - readlinkSync\n * - realpathSync\n * - promises: Object containing the following async methods:\n *   - lstat\n *   - readdir (Dirent variant only)\n *   - readlink\n *   - realpath\n */\nexport interface FSOption {\n  lstatSync?: (path: string) => Stats\n  readdir?: (\n    path: string,\n    options: { withFileTypes: true },\n    cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any\n  ) => void\n  readdirSync?: (\n    path: string,\n    options: { withFileTypes: true }\n  ) => Dirent[]\n  readlinkSync?: (path: string) => string\n  realpathSync?: (path: string) => string\n  promises?: {\n    lstat?: (path: string) => Promise<Stats>\n    readdir?: (\n      path: string,\n      options: { withFileTypes: true }\n    ) => Promise<Dirent[]>\n    readlink?: (path: string) => Promise<string>\n    realpath?: (path: string) => Promise<string>\n    [k: string]: any\n  }\n  [k: string]: any\n}\n\ninterface FSValue {\n  lstatSync: (path: string) => Stats\n  readdir: (\n    path: string,\n    options: { withFileTypes: true },\n    cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any\n  ) => void\n  readdirSync: (path: string, options: { withFileTypes: true }) => Dirent[]\n  readlinkSync: (path: string) => string\n  realpathSync: (path: string) => string\n  promises: {\n    lstat: (path: string) => Promise<Stats>\n    readdir: (\n      path: string,\n      options: { withFileTypes: true }\n    ) => Promise<Dirent[]>\n    readlink: (path: string) => Promise<string>\n    realpath: (path: string) => Promise<string>\n    [k: string]: any\n  }\n  [k: string]: any\n}\n\nconst defaultFS: FSValue = {\n  lstatSync,\n  readdir: readdirCB,\n  readdirSync,\n  readlinkSync,\n  realpathSync,\n  promises: {\n    lstat,\n    readdir,\n    readlink,\n    realpath,\n  },\n}\n\n// if they just gave us require('fs') then use our default\nconst fsFromOption = (fsOption?: FSOption): FSValue =>\n  !fsOption || fsOption === defaultFS || fsOption === actualFS\n    ? defaultFS\n    : {\n        ...defaultFS,\n        ...fsOption,\n        promises: {\n          ...defaultFS.promises,\n          ...(fsOption.promises || {}),\n        },\n      }\n\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i\nconst uncToDrive = (rootPath: string): string =>\n  rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\')\n\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/\n\nconst UNKNOWN = 0 // may not even exist, for all we know\nconst IFIFO = 0b0001\nconst IFCHR = 0b0010\nconst IFDIR = 0b0100\nconst IFBLK = 0b0110\nconst IFREG = 0b1000\nconst IFLNK = 0b1010\nconst IFSOCK = 0b1100\nconst IFMT = 0b1111\n\nexport type Type =\n  | 'Unknown'\n  | 'FIFO'\n  | 'CharacterDevice'\n  | 'Directory'\n  | 'BlockDevice'\n  | 'File'\n  | 'SymbolicLink'\n  | 'Socket'\n\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT\n\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 0b0000_0001_0000\n// set after a successful lstat()\nconst LSTAT_CALLED = 0b0000_0010_0000\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 0b0000_0100_0000\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 0b0000_1000_0000\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 0b0001_0000_0000\n// set if we know realpath() will fail\nconst ENOREALPATH = 0b0010_0000_0000\n\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH\nconst TYPEMASK = 0b0011_1111_1111\n\nconst entToType = (s: Dirent | Stats) =>\n  s.isFile()\n    ? IFREG\n    : s.isDirectory()\n    ? IFDIR\n    : s.isSymbolicLink()\n    ? IFLNK\n    : s.isCharacterDevice()\n    ? IFCHR\n    : s.isBlockDevice()\n    ? IFBLK\n    : s.isSocket()\n    ? IFSOCK\n    : s.isFIFO()\n    ? IFIFO\n    : UNKNOWN\n\n// normalize unicode path names\nconst normalizeCache = new Map<string, string>()\nconst normalize = (s: string) => {\n  const c = normalizeCache.get(s)\n  if (c) return c\n  const n = s.normalize('NFKD')\n  normalizeCache.set(s, n)\n  return n\n}\n\nconst normalizeNocaseCache = new Map<string, string>()\nconst normalizeNocase = (s: string) => {\n  const c = normalizeNocaseCache.get(s)\n  if (c) return c\n  const n = normalize(s.toLowerCase())\n  normalizeNocaseCache.set(s, n)\n  return n\n}\n\n/**\n * Options that may be provided to the Path constructor\n */\nexport interface PathOpts {\n  fullpath?: string\n  relative?: string\n  relativePosix?: string\n  parent?: PathBase\n  /**\n   * See {@link FSOption}\n   */\n  fs?: FSOption\n}\n\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nexport class ResolveCache extends LRUCache<string, string> {\n  constructor() {\n    super({ max: 256 })\n  }\n}\n\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nexport class ChildrenCache extends LRUCache<PathBase, Children> {\n  constructor(maxSize: number = 16 * 1024) {\n    super({\n      maxSize,\n      // parent + children\n      sizeCalculation: a => a.length + 1,\n    })\n  }\n}\n\n/**\n * Array of Path objects, plus a marker indicating the first provisional entry\n *\n * @internal\n */\nexport type Children = PathBase[] & { provisional: number }\n\nconst setAsCwd = Symbol('PathScurry setAsCwd')\n\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nexport abstract class PathBase implements Dirent {\n  /**\n   * the basename of this path\n   *\n   * **Important**: *always* test the path name against any test string\n   * usingthe {@link isNamed} method, and not by directly comparing this\n   * string. Otherwise, unicode path strings that the system sees as identical\n   * will not be properly treated as the same path, leading to incorrect\n   * behavior and possible security issues.\n   */\n  name: string\n  /**\n   * the Path entry corresponding to the path root.\n   *\n   * @internal\n   */\n  root: PathBase\n  /**\n   * All roots found within the current PathScurry family\n   *\n   * @internal\n   */\n  roots: { [k: string]: PathBase }\n  /**\n   * a reference to the parent path, or undefined in the case of root entries\n   *\n   * @internal\n   */\n  parent?: PathBase\n  /**\n   * boolean indicating whether paths are compared case-insensitively\n   * @internal\n   */\n  nocase: boolean\n\n  /**\n   * the string or regexp used to split paths. On posix, it is `'/'`, and on\n   * windows it is a RegExp matching either `'/'` or `'\\\\'`\n   */\n  abstract splitSep: string | RegExp\n  /**\n   * The path separator string to use when joining paths\n   */\n  abstract sep: string\n\n  // potential default fs override\n  #fs: FSValue\n\n  // Stats fields\n  #dev?: number\n  get dev() {\n    return this.#dev\n  }\n  #mode?: number\n  get mode() {\n    return this.#mode\n  }\n  #nlink?: number\n  get nlink() {\n    return this.#nlink\n  }\n  #uid?: number\n  get uid() {\n    return this.#uid\n  }\n  #gid?: number\n  get gid() {\n    return this.#gid\n  }\n  #rdev?: number\n  get rdev() {\n    return this.#rdev\n  }\n  #blksize?: number\n  get blksize() {\n    return this.#blksize\n  }\n  #ino?: number\n  get ino() {\n    return this.#ino\n  }\n  #size?: number\n  get size() {\n    return this.#size\n  }\n  #blocks?: number\n  get blocks() {\n    return this.#blocks\n  }\n  #atimeMs?: number\n  get atimeMs() {\n    return this.#atimeMs\n  }\n  #mtimeMs?: number\n  get mtimeMs() {\n    return this.#mtimeMs\n  }\n  #ctimeMs?: number\n  get ctimeMs() {\n    return this.#ctimeMs\n  }\n  #birthtimeMs?: number\n  get birthtimeMs() {\n    return this.#birthtimeMs\n  }\n  #atime?: Date\n  get atime() {\n    return this.#atime\n  }\n  #mtime?: Date\n  get mtime() {\n    return this.#mtime\n  }\n  #ctime?: Date\n  get ctime() {\n    return this.#ctime\n  }\n  #birthtime?: Date\n  get birthtime() {\n    return this.#birthtime\n  }\n\n  #matchName: string\n  #depth?: number\n  #fullpath?: string\n  #fullpathPosix?: string\n  #relative?: string\n  #relativePosix?: string\n  #type: number\n  #children: ChildrenCache\n  #linkTarget?: PathBase\n  #realpath?: PathBase\n\n  /**\n   * This property is for compatibility with the Dirent class as of\n   * Node v20, where Dirent['path'] refers to the path of the directory\n   * that was passed to readdir.  So, somewhat counterintuitively, this\n   * property refers to the *parent* path, not the path object itself.\n   * For root entries, it's the path to the entry itself.\n   */\n  get path(): string {\n    return (this.parent || this).fullpath()\n  }\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts\n  ) {\n    this.name = name\n    this.#matchName = nocase ? normalizeNocase(name) : normalize(name)\n    this.#type = type & TYPEMASK\n    this.nocase = nocase\n    this.roots = roots\n    this.root = root || this\n    this.#children = children\n    this.#fullpath = opts.fullpath\n    this.#relative = opts.relative\n    this.#relativePosix = opts.relativePosix\n    this.parent = opts.parent\n    if (this.parent) {\n      this.#fs = this.parent.#fs\n    } else {\n      this.#fs = fsFromOption(opts.fs)\n    }\n  }\n\n  /**\n   * Returns the depth of the Path object from its root.\n   *\n   * For example, a path at `/foo/bar` would have a depth of 2.\n   */\n  depth(): number {\n    if (this.#depth !== undefined) return this.#depth\n    if (!this.parent) return (this.#depth = 0)\n    return (this.#depth = this.parent.depth() + 1)\n  }\n\n  /**\n   * @internal\n   */\n  abstract getRootString(path: string): string\n  /**\n   * @internal\n   */\n  abstract getRoot(rootPath: string): PathBase\n  /**\n   * @internal\n   */\n  abstract newChild(name: string, type?: number, opts?: PathOpts): PathBase\n\n  /**\n   * @internal\n   */\n  childrenCache() {\n    return this.#children\n  }\n\n  /**\n   * Get the Path object referenced by the string path, resolved from this Path\n   */\n  resolve(path?: string): PathBase {\n    if (!path) {\n      return this\n    }\n    const rootPath = this.getRootString(path)\n    const dir = path.substring(rootPath.length)\n    const dirParts = dir.split(this.splitSep)\n    const result: PathBase = rootPath\n      ? this.getRoot(rootPath).#resolveParts(dirParts)\n      : this.#resolveParts(dirParts)\n    return result\n  }\n\n  #resolveParts(dirParts: string[]) {\n    let p: PathBase = this\n    for (const part of dirParts) {\n      p = p.child(part)\n    }\n    return p\n  }\n\n  /**\n   * Returns the cached children Path objects, if still available.  If they\n   * have fallen out of the cache, then returns an empty array, and resets the\n   * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n   * lookup.\n   *\n   * @internal\n   */\n  children(): Children {\n    const cached = this.#children.get(this)\n    if (cached) {\n      return cached\n    }\n    const children: Children = Object.assign([], { provisional: 0 })\n    this.#children.set(this, children)\n    this.#type &= ~READDIR_CALLED\n    return children\n  }\n\n  /**\n   * Resolves a path portion and returns or creates the child Path.\n   *\n   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n   * `'..'`.\n   *\n   * This should not be called directly.  If `pathPart` contains any path\n   * separators, it will lead to unsafe undefined behavior.\n   *\n   * Use `Path.resolve()` instead.\n   *\n   * @internal\n   */\n  child(pathPart: string, opts?: PathOpts): PathBase {\n    if (pathPart === '' || pathPart === '.') {\n      return this\n    }\n    if (pathPart === '..') {\n      return this.parent || this\n    }\n\n    // find the child\n    const children = this.children()\n    const name = this.nocase\n      ? normalizeNocase(pathPart)\n      : normalize(pathPart)\n    for (const p of children) {\n      if (p.#matchName === name) {\n        return p\n      }\n    }\n\n    // didn't find it, create provisional child, since it might not\n    // actually exist.  If we know the parent isn't a dir, then\n    // in fact it CAN'T exist.\n    const s = this.parent ? this.sep : ''\n    const fullpath = this.#fullpath\n      ? this.#fullpath + s + pathPart\n      : undefined\n    const pchild = this.newChild(pathPart, UNKNOWN, {\n      ...opts,\n      parent: this,\n      fullpath,\n    })\n\n    if (!this.canReaddir()) {\n      pchild.#type |= ENOENT\n    }\n\n    // don't have to update provisional, because if we have real children,\n    // then provisional is set to children.length, otherwise a lower number\n    children.push(pchild)\n    return pchild\n  }\n\n  /**\n   * The relative path from the cwd. If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpath()\n   */\n  relative(): string {\n    if (this.#relative !== undefined) {\n      return this.#relative\n    }\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#relative = this.name)\n    }\n    const pv = p.relative()\n    return pv + (!pv || !p.parent ? '' : this.sep) + name\n  }\n\n  /**\n   * The relative path from the cwd, using / as the path separator.\n   * If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpathPosix()\n   * On posix systems, this is identical to relative().\n   */\n  relativePosix(): string {\n    if (this.sep === '/') return this.relative()\n    if (this.#relativePosix !== undefined) return this.#relativePosix\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#relativePosix = this.fullpathPosix())\n    }\n    const pv = p.relativePosix()\n    return pv + (!pv || !p.parent ? '' : '/') + name\n  }\n\n  /**\n   * The fully resolved path string for this Path entry\n   */\n  fullpath(): string {\n    if (this.#fullpath !== undefined) {\n      return this.#fullpath\n    }\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#fullpath = this.name)\n    }\n    const pv = p.fullpath()\n    const fp = pv + (!p.parent ? '' : this.sep) + name\n    return (this.#fullpath = fp)\n  }\n\n  /**\n   * On platforms other than windows, this is identical to fullpath.\n   *\n   * On windows, this is overridden to return the forward-slash form of the\n   * full UNC path.\n   */\n  fullpathPosix(): string {\n    if (this.#fullpathPosix !== undefined) return this.#fullpathPosix\n    if (this.sep === '/') return (this.#fullpathPosix = this.fullpath())\n    if (!this.parent) {\n      const p = this.fullpath().replace(/\\\\/g, '/')\n      if (/^[a-z]:\\//i.test(p)) {\n        return (this.#fullpathPosix = `//?/${p}`)\n      } else {\n        return (this.#fullpathPosix = p)\n      }\n    }\n    const p = this.parent\n    const pfpp = p.fullpathPosix()\n    const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name\n    return (this.#fullpathPosix = fpp)\n  }\n\n  /**\n   * Is the Path of an unknown type?\n   *\n   * Note that we might know *something* about it if there has been a previous\n   * filesystem operation, for example that it does not exist, or is not a\n   * link, or whether it has child entries.\n   */\n  isUnknown(): boolean {\n    return (this.#type & IFMT) === UNKNOWN\n  }\n\n  isType(type: Type): boolean {\n    return this[`is${type}`]()\n  }\n\n  getType(): Type {\n    return this.isUnknown()\n      ? 'Unknown'\n      : this.isDirectory()\n      ? 'Directory'\n      : this.isFile()\n      ? 'File'\n      : this.isSymbolicLink()\n      ? 'SymbolicLink'\n      : this.isFIFO()\n      ? 'FIFO'\n      : this.isCharacterDevice()\n      ? 'CharacterDevice'\n      : this.isBlockDevice()\n      ? 'BlockDevice'\n      : /* c8 ignore start */ this.isSocket()\n      ? 'Socket'\n      : 'Unknown'\n    /* c8 ignore stop */\n  }\n\n  /**\n   * Is the Path a regular file?\n   */\n  isFile(): boolean {\n    return (this.#type & IFMT) === IFREG\n  }\n\n  /**\n   * Is the Path a directory?\n   */\n  isDirectory(): boolean {\n    return (this.#type & IFMT) === IFDIR\n  }\n\n  /**\n   * Is the path a character device?\n   */\n  isCharacterDevice(): boolean {\n    return (this.#type & IFMT) === IFCHR\n  }\n\n  /**\n   * Is the path a block device?\n   */\n  isBlockDevice(): boolean {\n    return (this.#type & IFMT) === IFBLK\n  }\n\n  /**\n   * Is the path a FIFO pipe?\n   */\n  isFIFO(): boolean {\n    return (this.#type & IFMT) === IFIFO\n  }\n\n  /**\n   * Is the path a socket?\n   */\n  isSocket(): boolean {\n    return (this.#type & IFMT) === IFSOCK\n  }\n\n  /**\n   * Is the path a symbolic link?\n   */\n  isSymbolicLink(): boolean {\n    return (this.#type & IFLNK) === IFLNK\n  }\n\n  /**\n   * Return the entry if it has been subject of a successful lstat, or\n   * undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* simply\n   * mean that we haven't called lstat on it.\n   */\n  lstatCached(): PathBase | undefined {\n    return this.#type & LSTAT_CALLED ? this : undefined\n  }\n\n  /**\n   * Return the cached link target if the entry has been the subject of a\n   * successful readlink, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readlink() has been called at some point.\n   */\n  readlinkCached(): PathBase | undefined {\n    return this.#linkTarget\n  }\n\n  /**\n   * Returns the cached realpath target if the entry has been the subject\n   * of a successful realpath, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * realpath() has been called at some point.\n   */\n  realpathCached(): PathBase | undefined {\n    return this.#realpath\n  }\n\n  /**\n   * Returns the cached child Path entries array if the entry has been the\n   * subject of a successful readdir(), or [] otherwise.\n   *\n   * Does not read the filesystem, so an empty array *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readdir() has been called recently enough to still be valid.\n   */\n  readdirCached(): PathBase[] {\n    const children = this.children()\n    return children.slice(0, children.provisional)\n  }\n\n  /**\n   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n   * any indication that readlink will definitely fail.\n   *\n   * Returns false if the path is known to not be a symlink, if a previous\n   * readlink failed, or if the entry does not exist.\n   */\n  canReadlink(): boolean {\n    if (this.#linkTarget) return true\n    if (!this.parent) return false\n    // cases where it cannot possibly succeed\n    const ifmt = this.#type & IFMT\n    return !(\n      (ifmt !== UNKNOWN && ifmt !== IFLNK) ||\n      this.#type & ENOREADLINK ||\n      this.#type & ENOENT\n    )\n  }\n\n  /**\n   * Return true if readdir has previously been successfully called on this\n   * path, indicating that cachedReaddir() is likely valid.\n   */\n  calledReaddir(): boolean {\n    return !!(this.#type & READDIR_CALLED)\n  }\n\n  /**\n   * Returns true if the path is known to not exist. That is, a previous lstat\n   * or readdir failed to verify its existence when that would have been\n   * expected, or a parent entry was marked either enoent or enotdir.\n   */\n  isENOENT(): boolean {\n    return !!(this.#type & ENOENT)\n  }\n\n  /**\n   * Return true if the path is a match for the given path name.  This handles\n   * case sensitivity and unicode normalization.\n   *\n   * Note: even on case-sensitive systems, it is **not** safe to test the\n   * equality of the `.name` property to determine whether a given pathname\n   * matches, due to unicode normalization mismatches.\n   *\n   * Always use this method instead of testing the `path.name` property\n   * directly.\n   */\n  isNamed(n: string): boolean {\n    return !this.nocase\n      ? this.#matchName === normalize(n)\n      : this.#matchName === normalizeNocase(n)\n  }\n\n  /**\n   * Return the Path object corresponding to the target of a symbolic link.\n   *\n   * If the Path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   */\n  async readlink(): Promise<PathBase | undefined> {\n    const target = this.#linkTarget\n    if (target) {\n      return target\n    }\n    if (!this.canReadlink()) {\n      return undefined\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined\n    }\n    /* c8 ignore stop */\n    try {\n      const read = await this.#fs.promises.readlink(this.fullpath())\n      const linkTarget = this.parent.resolve(read)\n      if (linkTarget) {\n        return (this.#linkTarget = linkTarget)\n      }\n    } catch (er) {\n      this.#readlinkFail((er as NodeJS.ErrnoException).code)\n      return undefined\n    }\n  }\n\n  /**\n   * Synchronous {@link PathBase.readlink}\n   */\n  readlinkSync(): PathBase | undefined {\n    const target = this.#linkTarget\n    if (target) {\n      return target\n    }\n    if (!this.canReadlink()) {\n      return undefined\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined\n    }\n    /* c8 ignore stop */\n    try {\n      const read = this.#fs.readlinkSync(this.fullpath())\n      const linkTarget = this.parent.resolve(read)\n      if (linkTarget) {\n        return (this.#linkTarget = linkTarget)\n      }\n    } catch (er) {\n      this.#readlinkFail((er as NodeJS.ErrnoException).code)\n      return undefined\n    }\n  }\n\n  #readdirSuccess(children: Children) {\n    // succeeded, mark readdir called bit\n    this.#type |= READDIR_CALLED\n    // mark all remaining provisional children as ENOENT\n    for (let p = children.provisional; p < children.length; p++) {\n      children[p].#markENOENT()\n    }\n  }\n\n  #markENOENT() {\n    // mark as UNKNOWN and ENOENT\n    if (this.#type & ENOENT) return\n    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN\n    this.#markChildrenENOENT()\n  }\n\n  #markChildrenENOENT() {\n    // all children are provisional and do not exist\n    const children = this.children()\n    children.provisional = 0\n    for (const p of children) {\n      p.#markENOENT()\n    }\n  }\n\n  #markENOREALPATH() {\n    this.#type |= ENOREALPATH\n    this.#markENOTDIR()\n  }\n\n  // save the information when we know the entry is not a dir\n  #markENOTDIR() {\n    // entry is not a directory, so any children can't exist.\n    // this *should* be impossible, since any children created\n    // after it's been marked ENOTDIR should be marked ENOENT,\n    // so it won't even get to this point.\n    /* c8 ignore start */\n    if (this.#type & ENOTDIR) return\n    /* c8 ignore stop */\n    let t = this.#type\n    // this could happen if we stat a dir, then delete it,\n    // then try to read it or one of its children.\n    if ((t & IFMT) === IFDIR) t &= IFMT_UNKNOWN\n    this.#type = t | ENOTDIR\n    this.#markChildrenENOENT()\n  }\n\n  #readdirFail(code: string = '') {\n    // markENOTDIR and markENOENT also set provisional=0\n    if (code === 'ENOTDIR' || code === 'EPERM') {\n      this.#markENOTDIR()\n    } else if (code === 'ENOENT') {\n      this.#markENOENT()\n    } else {\n      this.children().provisional = 0\n    }\n  }\n\n  #lstatFail(code: string = '') {\n    // Windows just raises ENOENT in this case, disable for win CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR') {\n      // already know it has a parent by this point\n      const p = this.parent as PathBase\n      p.#markENOTDIR()\n    } else if (code === 'ENOENT') {\n      /* c8 ignore stop */\n      this.#markENOENT()\n    }\n  }\n\n  #readlinkFail(code: string = '') {\n    let ter = this.#type\n    ter |= ENOREADLINK\n    if (code === 'ENOENT') ter |= ENOENT\n    // windows gets a weird error when you try to readlink a file\n    if (code === 'EINVAL' || code === 'UNKNOWN') {\n      // exists, but not a symlink, we don't know WHAT it is, so remove\n      // all IFMT bits.\n      ter &= IFMT_UNKNOWN\n    }\n    this.#type = ter\n    // windows just gets ENOENT in this case.  We do cover the case,\n    // just disabled because it's impossible on Windows CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR' && this.parent) {\n      this.parent.#markENOTDIR()\n    }\n    /* c8 ignore stop */\n  }\n\n  #readdirAddChild(e: Dirent, c: Children) {\n    return (\n      this.#readdirMaybePromoteChild(e, c) ||\n      this.#readdirAddNewChild(e, c)\n    )\n  }\n\n  #readdirAddNewChild(e: Dirent, c: Children): PathBase {\n    // alloc new entry at head, so it's never provisional\n    const type = entToType(e)\n    const child = this.newChild(e.name, type, { parent: this })\n    const ifmt = child.#type & IFMT\n    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n      child.#type |= ENOTDIR\n    }\n    c.unshift(child)\n    c.provisional++\n    return child\n  }\n\n  #readdirMaybePromoteChild(e: Dirent, c: Children): PathBase | undefined {\n    for (let p = c.provisional; p < c.length; p++) {\n      const pchild = c[p]\n      const name = this.nocase\n        ? normalizeNocase(e.name)\n        : normalize(e.name)\n      if (name !== pchild.#matchName) {\n        continue\n      }\n\n      return this.#readdirPromoteChild(e, pchild, p, c)\n    }\n  }\n\n  #readdirPromoteChild(\n    e: Dirent,\n    p: PathBase,\n    index: number,\n    c: Children\n  ): PathBase {\n    const v = p.name\n    // retain any other flags, but set ifmt from dirent\n    p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e)\n    // case sensitivity fixing when we learn the true name.\n    if (v !== e.name) p.name = e.name\n\n    // just advance provisional index (potentially off the list),\n    // otherwise we have to splice/pop it out and re-insert at head\n    if (index !== c.provisional) {\n      if (index === c.length - 1) c.pop()\n      else c.splice(index, 1)\n      c.unshift(p)\n    }\n    c.provisional++\n    return p\n  }\n\n  /**\n   * Call lstat() on this Path, and update all known information that can be\n   * determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(): Promise<PathBase | undefined> {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()))\n        return this\n      } catch (er) {\n        this.#lstatFail((er as NodeJS.ErrnoException).code)\n      }\n    }\n  }\n\n  /**\n   * synchronous {@link PathBase.lstat}\n   */\n  lstatSync(): PathBase | undefined {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(this.#fs.lstatSync(this.fullpath()))\n        return this\n      } catch (er) {\n        this.#lstatFail((er as NodeJS.ErrnoException).code)\n      }\n    }\n  }\n\n  #applyStat(st: Stats) {\n    const {\n      atime,\n      atimeMs,\n      birthtime,\n      birthtimeMs,\n      blksize,\n      blocks,\n      ctime,\n      ctimeMs,\n      dev,\n      gid,\n      ino,\n      mode,\n      mtime,\n      mtimeMs,\n      nlink,\n      rdev,\n      size,\n      uid,\n    } = st\n    this.#atime = atime\n    this.#atimeMs = atimeMs\n    this.#birthtime = birthtime\n    this.#birthtimeMs = birthtimeMs\n    this.#blksize = blksize\n    this.#blocks = blocks\n    this.#ctime = ctime\n    this.#ctimeMs = ctimeMs\n    this.#dev = dev\n    this.#gid = gid\n    this.#ino = ino\n    this.#mode = mode\n    this.#mtime = mtime\n    this.#mtimeMs = mtimeMs\n    this.#nlink = nlink\n    this.#rdev = rdev\n    this.#size = size\n    this.#uid = uid\n    const ifmt = entToType(st)\n    // retain any other flags, but set the ifmt\n    this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED\n    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n      this.#type |= ENOTDIR\n    }\n  }\n\n  #onReaddirCB: ((\n    er: NodeJS.ErrnoException | null,\n    entries: Path[]\n  ) => any)[] = []\n  #readdirCBInFlight: boolean = false\n  #callOnReaddirCB(children: Path[]) {\n    this.#readdirCBInFlight = false\n    const cbs = this.#onReaddirCB.slice()\n    this.#onReaddirCB.length = 0\n    cbs.forEach(cb => cb(null, children))\n  }\n\n  /**\n   * Standard node-style callback interface to get list of directory entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * @param cb The callback called with (er, entries).  Note that the `er`\n   * param is somewhat extraneous, as all readdir() errors are handled and\n   * simply result in an empty set of entries being returned.\n   * @param allowZalgo Boolean indicating that immediately known results should\n   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n   * zalgo at your peril, the dark pony lord is devious and unforgiving.\n   */\n  readdirCB(\n    cb: (er: NodeJS.ErrnoException | null, entries: PathBase[]) => any,\n    allowZalgo: boolean = false\n  ): void {\n    if (!this.canReaddir()) {\n      if (allowZalgo) cb(null, [])\n      else queueMicrotask(() => cb(null, []))\n      return\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      const c = children.slice(0, children.provisional)\n      if (allowZalgo) cb(null, c)\n      else queueMicrotask(() => cb(null, c))\n      return\n    }\n\n    // don't have to worry about zalgo at this point.\n    this.#onReaddirCB.push(cb)\n    if (this.#readdirCBInFlight) {\n      return\n    }\n    this.#readdirCBInFlight = true\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {\n      if (er) {\n        this.#readdirFail((er as NodeJS.ErrnoException).code)\n        children.provisional = 0\n      } else {\n        // if we didn't get an error, we always get entries.\n        //@ts-ignore\n        for (const e of entries) {\n          this.#readdirAddChild(e, children)\n        }\n        this.#readdirSuccess(children)\n      }\n      this.#callOnReaddirCB(children.slice(0, children.provisional))\n      return\n    })\n  }\n\n  #asyncReaddirInFlight?: Promise<void>\n\n  /**\n   * Return an array of known child entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async readdir(): Promise<PathBase[]> {\n    if (!this.canReaddir()) {\n      return []\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional)\n    }\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    if (this.#asyncReaddirInFlight) {\n      await this.#asyncReaddirInFlight\n    } else {\n      /* c8 ignore start */\n      let resolve: () => void = () => {}\n      /* c8 ignore stop */\n      this.#asyncReaddirInFlight = new Promise<void>(\n        res => (resolve = res)\n      )\n      try {\n        for (const e of await this.#fs.promises.readdir(fullpath, {\n          withFileTypes: true,\n        })) {\n          this.#readdirAddChild(e, children)\n        }\n        this.#readdirSuccess(children)\n      } catch (er) {\n        this.#readdirFail((er as NodeJS.ErrnoException).code)\n        children.provisional = 0\n      }\n      this.#asyncReaddirInFlight = undefined\n      resolve()\n    }\n    return children.slice(0, children.provisional)\n  }\n\n  /**\n   * synchronous {@link PathBase.readdir}\n   */\n  readdirSync(): PathBase[] {\n    if (!this.canReaddir()) {\n      return []\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional)\n    }\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    try {\n      for (const e of this.#fs.readdirSync(fullpath, {\n        withFileTypes: true,\n      })) {\n        this.#readdirAddChild(e, children)\n      }\n      this.#readdirSuccess(children)\n    } catch (er) {\n      this.#readdirFail((er as NodeJS.ErrnoException).code)\n      children.provisional = 0\n    }\n    return children.slice(0, children.provisional)\n  }\n\n  canReaddir() {\n    if (this.#type & ENOCHILD) return false\n    const ifmt = IFMT & this.#type\n    // we always set ENOTDIR when setting IFMT, so should be impossible\n    /* c8 ignore start */\n    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n      return false\n    }\n    /* c8 ignore stop */\n    return true\n  }\n\n  shouldWalk(\n    dirs: Set<PathBase | undefined>,\n    walkFilter?: (e: PathBase) => boolean\n  ): boolean {\n    return (\n      (this.#type & IFDIR) === IFDIR &&\n      !(this.#type & ENOCHILD) &&\n      !dirs.has(this) &&\n      (!walkFilter || walkFilter(this))\n    )\n  }\n\n  /**\n   * Return the Path object corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   * On success, returns a Path object.\n   */\n  async realpath(): Promise<PathBase | undefined> {\n    if (this.#realpath) return this.#realpath\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined\n    try {\n      const rp = await this.#fs.promises.realpath(this.fullpath())\n      return (this.#realpath = this.resolve(rp))\n    } catch (_) {\n      this.#markENOREALPATH()\n    }\n  }\n\n  /**\n   * Synchronous {@link realpath}\n   */\n  realpathSync(): PathBase | undefined {\n    if (this.#realpath) return this.#realpath\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined\n    try {\n      const rp = this.#fs.realpathSync(this.fullpath())\n      return (this.#realpath = this.resolve(rp))\n    } catch (_) {\n      this.#markENOREALPATH()\n    }\n  }\n\n  /**\n   * Internal method to mark this Path object as the scurry cwd,\n   * called by {@link PathScurry#chdir}\n   *\n   * @internal\n   */\n  [setAsCwd](oldCwd: PathBase): void {\n    if (oldCwd === this) return\n\n    const changed = new Set<PathBase>([])\n    let rp = []\n    let p: PathBase = this\n    while (p && p.parent) {\n      changed.add(p)\n      p.#relative = rp.join(this.sep)\n      p.#relativePosix = rp.join('/')\n      p = p.parent\n      rp.push('..')\n    }\n    // now un-memoize parents of old cwd\n    p = oldCwd\n    while (p && p.parent && !changed.has(p)) {\n      p.#relative = undefined\n      p.#relativePosix = undefined\n      p = p.parent\n    }\n  }\n}\n\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nexport class PathWin32 extends PathBase {\n  /**\n   * Separator for generating path strings.\n   */\n  sep: '\\\\' = '\\\\'\n  /**\n   * Separator for parsing path strings.\n   */\n  splitSep: RegExp = eitherSep\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts\n  ) {\n    super(name, type, root, roots, nocase, children, opts)\n  }\n\n  /**\n   * @internal\n   */\n  newChild(name: string, type: number = UNKNOWN, opts: PathOpts = {}) {\n    return new PathWin32(\n      name,\n      type,\n      this.root,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      opts\n    )\n  }\n\n  /**\n   * @internal\n   */\n  getRootString(path: string): string {\n    return win32.parse(path).root\n  }\n\n  /**\n   * @internal\n   */\n  getRoot(rootPath: string): PathBase {\n    rootPath = uncToDrive(rootPath.toUpperCase())\n    if (rootPath === this.root.name) {\n      return this.root\n    }\n    // ok, not that one, check if it matches another we know about\n    for (const [compare, root] of Object.entries(this.roots)) {\n      if (this.sameRoot(rootPath, compare)) {\n        return (this.roots[rootPath] = root)\n      }\n    }\n    // otherwise, have to create a new one.\n    return (this.roots[rootPath] = new PathScurryWin32(\n      rootPath,\n      this\n    ).root)\n  }\n\n  /**\n   * @internal\n   */\n  sameRoot(rootPath: string, compare: string = this.root.name): boolean {\n    // windows can (rarely) have case-sensitive filesystem, but\n    // UNC and drive letters are always case-insensitive, and canonically\n    // represented uppercase.\n    rootPath = rootPath\n      .toUpperCase()\n      .replace(/\\//g, '\\\\')\n      .replace(uncDriveRegexp, '$1\\\\')\n    return rootPath === compare\n  }\n}\n\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nexport class PathPosix extends PathBase {\n  /**\n   * separator for parsing path strings\n   */\n  splitSep: '/' = '/'\n  /**\n   * separator for generating path strings\n   */\n  sep: '/' = '/'\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts\n  ) {\n    super(name, type, root, roots, nocase, children, opts)\n  }\n\n  /**\n   * @internal\n   */\n  getRootString(path: string): string {\n    return path.startsWith('/') ? '/' : ''\n  }\n\n  /**\n   * @internal\n   */\n  getRoot(_rootPath: string): PathBase {\n    return this.root\n  }\n\n  /**\n   * @internal\n   */\n  newChild(name: string, type: number = UNKNOWN, opts: PathOpts = {}) {\n    return new PathPosix(\n      name,\n      type,\n      this.root,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      opts\n    )\n  }\n}\n\n/**\n * Options that may be provided to the PathScurry constructor\n */\nexport interface PathScurryOpts {\n  /**\n   * perform case-insensitive path matching. Default based on platform\n   * subclass.\n   */\n  nocase?: boolean\n  /**\n   * Number of Path entries to keep in the cache of Path child references.\n   *\n   * Setting this higher than 65536 will dramatically increase the data\n   * consumption and construction time overhead of each PathScurry.\n   *\n   * Setting this value to 256 or lower will significantly reduce the data\n   * consumption and construction time overhead, but may also reduce resolve()\n   * and readdir() performance on large filesystems.\n   *\n   * Default `16384`.\n   */\n  childrenCacheSize?: number\n  /**\n   * An object that overrides the built-in functions from the fs and\n   * fs/promises modules.\n   *\n   * See {@link FSOption}\n   */\n  fs?: FSOption\n}\n\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nexport abstract class PathScurryBase {\n  /**\n   * The root Path entry for the current working directory of this Scurry\n   */\n  root: PathBase\n  /**\n   * The string path for the root of this Scurry's current working directory\n   */\n  rootPath: string\n  /**\n   * A collection of all roots encountered, referenced by rootPath\n   */\n  roots: { [k: string]: PathBase }\n  /**\n   * The Path entry corresponding to this PathScurry's current working directory.\n   */\n  cwd: PathBase\n  #resolveCache: ResolveCache\n  #resolvePosixCache: ResolveCache\n  #children: ChildrenCache\n  /**\n   * Perform path comparisons case-insensitively.\n   *\n   * Defaults true on Darwin and Windows systems, false elsewhere.\n   */\n  nocase: boolean\n\n  /**\n   * The path separator used for parsing paths\n   *\n   * `'/'` on Posix systems, either `'/'` or `'\\\\'` on Windows\n   */\n  abstract sep: string | RegExp\n\n  #fs: FSValue\n\n  /**\n   * This class should not be instantiated directly.\n   *\n   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n   *\n   * @internal\n   */\n  constructor(\n    cwd: URL | string = process.cwd(),\n    pathImpl: typeof win32 | typeof posix,\n    sep: string | RegExp,\n    {\n      nocase,\n      childrenCacheSize = 16 * 1024,\n      fs = defaultFS,\n    }: PathScurryOpts = {}\n  ) {\n    this.#fs = fsFromOption(fs)\n    if (cwd instanceof URL || cwd.startsWith('file://')) {\n      cwd = fileURLToPath(cwd)\n    }\n    // resolve and split root, and then add to the store.\n    // this is the only time we call path.resolve()\n    const cwdPath = pathImpl.resolve(cwd)\n    this.roots = Object.create(null)\n    this.rootPath = this.parseRootPath(cwdPath)\n    this.#resolveCache = new ResolveCache()\n    this.#resolvePosixCache = new ResolveCache()\n    this.#children = new ChildrenCache(childrenCacheSize)\n\n    const split = cwdPath.substring(this.rootPath.length).split(sep)\n    // resolve('/') leaves '', splits to [''], we don't want that.\n    if (split.length === 1 && !split[0]) {\n      split.pop()\n    }\n    /* c8 ignore start */\n    if (nocase === undefined) {\n      throw new TypeError(\n        'must provide nocase setting to PathScurryBase ctor'\n      )\n    }\n    /* c8 ignore stop */\n    this.nocase = nocase\n    this.root = this.newRoot(this.#fs)\n    this.roots[this.rootPath] = this.root\n    let prev: PathBase = this.root\n    let len = split.length - 1\n    const joinSep = pathImpl.sep\n    let abs = this.rootPath\n    let sawFirst = false\n    for (const part of split) {\n      const l = len--\n      prev = prev.child(part, {\n        relative: new Array(l).fill('..').join(joinSep),\n        relativePosix: new Array(l).fill('..').join('/'),\n        fullpath: (abs += (sawFirst ? '' : joinSep) + part),\n      })\n      sawFirst = true\n    }\n    this.cwd = prev\n  }\n\n  /**\n   * Get the depth of a provided path, string, or the cwd\n   */\n  depth(path: Path | string = this.cwd): number {\n    if (typeof path === 'string') {\n      path = this.cwd.resolve(path)\n    }\n    return path.depth()\n  }\n\n  /**\n   * Parse the root portion of a path string\n   *\n   * @internal\n   */\n  abstract parseRootPath(dir: string): string\n  /**\n   * create a new Path to use as root during construction.\n   *\n   * @internal\n   */\n  abstract newRoot(fs: FSValue): PathBase\n  /**\n   * Determine whether a given path string is absolute\n   */\n  abstract isAbsolute(p: string): boolean\n\n  /**\n   * Return the cache of child entries.  Exposed so subclasses can create\n   * child Path objects in a platform-specific way.\n   *\n   * @internal\n   */\n  childrenCache() {\n    return this.#children\n  }\n\n  /**\n   * Resolve one or more path strings to a resolved string\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolve(...paths: string[]): string {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = ''\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i]\n      if (!p || p === '.') continue\n      r = r ? `${p}/${r}` : p\n      if (this.isAbsolute(p)) {\n        break\n      }\n    }\n    const cached = this.#resolveCache.get(r)\n    if (cached !== undefined) {\n      return cached\n    }\n    const result = this.cwd.resolve(r).fullpath()\n    this.#resolveCache.set(r, result)\n    return result\n  }\n\n  /**\n   * Resolve one or more path strings to a resolved string, returning\n   * the posix path.  Identical to .resolve() on posix systems, but on\n   * windows will return a forward-slash separated UNC path.\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolvePosix(...paths: string[]): string {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = ''\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i]\n      if (!p || p === '.') continue\n      r = r ? `${p}/${r}` : p\n      if (this.isAbsolute(p)) {\n        break\n      }\n    }\n    const cached = this.#resolvePosixCache.get(r)\n    if (cached !== undefined) {\n      return cached\n    }\n    const result = this.cwd.resolve(r).fullpathPosix()\n    this.#resolvePosixCache.set(r, result)\n    return result\n  }\n\n  /**\n   * find the relative path from the cwd to the supplied path string or entry\n   */\n  relative(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.relative()\n  }\n\n  /**\n   * find the relative path from the cwd to the supplied path string or\n   * entry, using / as the path delimiter, even on Windows.\n   */\n  relativePosix(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.relativePosix()\n  }\n\n  /**\n   * Return the basename for the provided string or Path object\n   */\n  basename(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.name\n  }\n\n  /**\n   * Return the dirname for the provided string or Path object\n   */\n  dirname(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return (entry.parent || entry).fullpath()\n  }\n\n  /**\n   * Return an array of known child entries.\n   *\n   * First argument may be either a string, or a Path object.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * Unlike `fs.readdir()`, the `withFileTypes` option defaults to `true`. Set\n   * `{ withFileTypes: false }` to return strings.\n   */\n\n  readdir(): Promise<PathBase[]>\n  readdir(opts: { withFileTypes: true }): Promise<PathBase[]>\n  readdir(opts: { withFileTypes: false }): Promise<string[]>\n  readdir(opts: { withFileTypes: boolean }): Promise<PathBase[] | string[]>\n  readdir(entry: PathBase | string): Promise<PathBase[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: true }\n  ): Promise<PathBase[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: false }\n  ): Promise<string[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: boolean }\n  ): Promise<PathBase[] | string[]>\n  async readdir(\n    entry: PathBase | string | { withFileTypes: boolean } = this.cwd,\n    opts: { withFileTypes: boolean } = {\n      withFileTypes: true,\n    }\n  ): Promise<PathBase[] | string[]> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const { withFileTypes } = opts\n    if (!entry.canReaddir()) {\n      return []\n    } else {\n      const p = await entry.readdir()\n      return withFileTypes ? p : p.map(e => e.name)\n    }\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.readdir}\n   */\n  readdirSync(): PathBase[]\n  readdirSync(opts: { withFileTypes: true }): PathBase[]\n  readdirSync(opts: { withFileTypes: false }): string[]\n  readdirSync(opts: { withFileTypes: boolean }): PathBase[] | string[]\n  readdirSync(entry: PathBase | string): PathBase[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: true }\n  ): PathBase[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: false }\n  ): string[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: boolean }\n  ): PathBase[] | string[]\n  readdirSync(\n    entry: PathBase | string | { withFileTypes: boolean } = this.cwd,\n    opts: { withFileTypes: boolean } = {\n      withFileTypes: true,\n    }\n  ): PathBase[] | string[] {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const { withFileTypes = true } = opts\n    if (!entry.canReaddir()) {\n      return []\n    } else if (withFileTypes) {\n      return entry.readdirSync()\n    } else {\n      return entry.readdirSync().map(e => e.name)\n    }\n  }\n\n  /**\n   * Call lstat() on the string or Path object, and update all known\n   * information that can be determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(\n    entry: string | PathBase = this.cwd\n  ): Promise<PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.lstat()\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.lstat}\n   */\n  lstatSync(entry: string | PathBase = this.cwd): PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.lstatSync()\n  }\n\n  /**\n   * Return the Path object or string path corresponding to the target of a\n   * symbolic link.\n   *\n   * If the path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   *\n   * `{withFileTypes}` option defaults to `false`.\n   *\n   * On success, returns a Path object if `withFileTypes` option is true,\n   * otherwise a string.\n   */\n  readlink(): Promise<string | undefined>\n  readlink(opt: { withFileTypes: false }): Promise<string | undefined>\n  readlink(opt: { withFileTypes: true }): Promise<PathBase | undefined>\n  readlink(opt: {\n    withFileTypes: boolean\n  }): Promise<PathBase | string | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): Promise<string | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): Promise<PathBase | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): Promise<string | PathBase | undefined>\n  async readlink(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): Promise<string | PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = await entry.readlink()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.readlink}\n   */\n  readlinkSync(): string | undefined\n  readlinkSync(opt: { withFileTypes: false }): string | undefined\n  readlinkSync(opt: { withFileTypes: true }): PathBase | undefined\n  readlinkSync(opt: {\n    withFileTypes: boolean\n  }): PathBase | string | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): string | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): PathBase | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): string | PathBase | undefined\n  readlinkSync(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): string | PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = entry.readlinkSync()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * Return the Path object or string path corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   *\n   * `{withFileTypes}` option defaults to `false`.\n   *\n   * On success, returns a Path object if `withFileTypes` option is true,\n   * otherwise a string.\n   */\n  realpath(): Promise<string | undefined>\n  realpath(opt: { withFileTypes: false }): Promise<string | undefined>\n  realpath(opt: { withFileTypes: true }): Promise<PathBase | undefined>\n  realpath(opt: {\n    withFileTypes: boolean\n  }): Promise<PathBase | string | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): Promise<string | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): Promise<PathBase | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): Promise<string | PathBase | undefined>\n  async realpath(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): Promise<string | PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = await entry.realpath()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  realpathSync(): string | undefined\n  realpathSync(opt: { withFileTypes: false }): string | undefined\n  realpathSync(opt: { withFileTypes: true }): PathBase | undefined\n  realpathSync(opt: {\n    withFileTypes: boolean\n  }): PathBase | string | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): string | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): PathBase | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): string | PathBase | undefined\n  realpathSync(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): string | PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = entry.realpathSync()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * Asynchronously walk the directory tree, returning an array of\n   * all path strings or Path objects found.\n   *\n   * Note that this will be extremely memory-hungry on large filesystems.\n   * In such cases, it may be better to use the stream or async iterator\n   * walk implementation.\n   */\n  walk(): Promise<PathBase[]>\n  walk(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Promise<PathBase[]>\n  walk(opts: WalkOptionsWithFileTypesFalse): Promise<string[]>\n  walk(opts: WalkOptions): Promise<string[] | PathBase[]>\n  walk(entry: string | PathBase): Promise<PathBase[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Promise<PathBase[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Promise<string[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Promise<PathBase[] | string[]>\n  async walk(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Promise<PathBase[] | string[]> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results: (string | PathBase)[] = []\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>()\n    const walk = (\n      dir: PathBase,\n      cb: (er?: NodeJS.ErrnoException) => void\n    ) => {\n      dirs.add(dir)\n      dir.readdirCB((er, entries) => {\n        /* c8 ignore start */\n        if (er) {\n          return cb(er)\n        }\n        /* c8 ignore stop */\n        let len = entries.length\n        if (!len) return cb()\n        const next = () => {\n          if (--len === 0) {\n            cb()\n          }\n        }\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            results.push(withFileTypes ? e : e.fullpath())\n          }\n          if (follow && e.isSymbolicLink()) {\n            e.realpath()\n              .then(r => (r?.isUnknown() ? r.lstat() : r))\n              .then(r =>\n                r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next()\n              )\n          } else {\n            if (e.shouldWalk(dirs, walkFilter)) {\n              walk(e, next)\n            } else {\n              next()\n            }\n          }\n        }\n      }, true) // zalgooooooo\n    }\n\n    const start = entry\n    return new Promise<PathBase[] | string[]>((res, rej) => {\n      walk(start, er => {\n        /* c8 ignore start */\n        if (er) return rej(er)\n        /* c8 ignore stop */\n        res(results as PathBase[] | string[])\n      })\n    })\n  }\n\n  /**\n   * Synchronously walk the directory tree, returning an array of\n   * all path strings or Path objects found.\n   *\n   * Note that this will be extremely memory-hungry on large filesystems.\n   * In such cases, it may be better to use the stream or async iterator\n   * walk implementation.\n   */\n  walkSync(): PathBase[]\n  walkSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): PathBase[]\n  walkSync(opts: WalkOptionsWithFileTypesFalse): string[]\n  walkSync(opts: WalkOptions): string[] | PathBase[]\n  walkSync(entry: string | PathBase): PathBase[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue\n  ): PathBase[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): string[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): PathBase[] | string[]\n  walkSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): PathBase[] | string[] {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results: (string | PathBase)[] = []\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>([entry])\n    for (const dir of dirs) {\n      const entries = dir.readdirSync()\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          results.push(withFileTypes ? e : e.fullpath())\n        }\n        let r: PathBase | undefined = e\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue\n          if (r.isUnknown()) r.lstatSync()\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r)\n        }\n      }\n    }\n    return results as string[] | PathBase[]\n  }\n\n  /**\n   * Support for `for await`\n   *\n   * Alias for {@link PathScurryBase.iterate}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  [Symbol.asyncIterator]() {\n    return this.iterate()\n  }\n\n  /**\n   * Async generator form of {@link PathScurryBase.walk}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking, especially if most/all of the directory tree has been previously\n   * walked.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  iterate(): AsyncGenerator<PathBase, void, void>\n  iterate(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): AsyncGenerator<PathBase, void, void>\n  iterate(\n    opts: WalkOptionsWithFileTypesFalse\n  ): AsyncGenerator<string, void, void>\n  iterate(opts: WalkOptions): AsyncGenerator<string | PathBase, void, void>\n  iterate(entry: string | PathBase): AsyncGenerator<PathBase, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): AsyncGenerator<PathBase, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): AsyncGenerator<string, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): AsyncGenerator<PathBase | string, void, void>\n  iterate(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    options: WalkOptions = {}\n  ): AsyncGenerator<PathBase | string, void, void> {\n    // iterating async over the stream is significantly more performant,\n    // especially in the warm-cache scenario, because it buffers up directory\n    // entries in the background instead of waiting for a yield for each one.\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      options = entry\n      entry = this.cwd\n    }\n    return this.stream(entry, options)[Symbol.asyncIterator]()\n  }\n\n  /**\n   * Iterating over a PathScurry performs a synchronous walk.\n   *\n   * Alias for {@link PathScurryBase.iterateSync}\n   */\n  [Symbol.iterator]() {\n    return this.iterateSync()\n  }\n\n  iterateSync(): Generator<PathBase, void, void>\n  iterateSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Generator<PathBase, void, void>\n  iterateSync(\n    opts: WalkOptionsWithFileTypesFalse\n  ): Generator<string, void, void>\n  iterateSync(opts: WalkOptions): Generator<string | PathBase, void, void>\n  iterateSync(entry: string | PathBase): Generator<PathBase, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Generator<PathBase, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Generator<string, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Generator<PathBase | string, void, void>\n  *iterateSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Generator<PathBase | string, void, void> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    if (!filter || filter(entry)) {\n      yield withFileTypes ? entry : entry.fullpath()\n    }\n    const dirs = new Set<PathBase>([entry])\n    for (const dir of dirs) {\n      const entries = dir.readdirSync()\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          yield withFileTypes ? e : e.fullpath()\n        }\n        let r: PathBase | undefined = e\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue\n          if (r.isUnknown()) r.lstatSync()\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r)\n        }\n      }\n    }\n  }\n\n  /**\n   * Stream form of {@link PathScurryBase.walk}\n   *\n   * Returns a Minipass stream that emits {@link PathBase} objects by default,\n   * or strings if `{ withFileTypes: false }` is set in the options.\n   */\n  stream(): Minipass<PathBase>\n  stream(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Minipass<PathBase>\n  stream(opts: WalkOptionsWithFileTypesFalse): Minipass<string>\n  stream(opts: WalkOptions): Minipass<string | PathBase>\n  stream(entry: string | PathBase): Minipass<PathBase>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue\n  ): Minipass<PathBase>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Minipass<string>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Minipass<string> | Minipass<PathBase>\n  stream(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Minipass<string> | Minipass<PathBase> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results = new Minipass<string | PathBase>({ objectMode: true })\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>()\n    const queue: PathBase[] = [entry]\n    let processing = 0\n    const process = () => {\n      let paused = false\n      while (!paused) {\n        const dir = queue.shift()\n        if (!dir) {\n          if (processing === 0) results.end()\n          return\n        }\n\n        processing++\n        dirs.add(dir)\n\n        const onReaddir = (\n          er: null | NodeJS.ErrnoException,\n          entries: PathBase[],\n          didRealpaths: boolean = false\n        ) => {\n          /* c8 ignore start */\n          if (er) return results.emit('error', er)\n          /* c8 ignore stop */\n          if (follow && !didRealpaths) {\n            const promises: Promise<PathBase | undefined>[] = []\n            for (const e of entries) {\n              if (e.isSymbolicLink()) {\n                promises.push(\n                  e\n                    .realpath()\n                    .then((r: PathBase | undefined) =>\n                      r?.isUnknown() ? r.lstat() : r\n                    )\n                )\n              }\n            }\n            if (promises.length) {\n              Promise.all(promises).then(() =>\n                onReaddir(null, entries, true)\n              )\n              return\n            }\n          }\n\n          for (const e of entries) {\n            if (e && (!filter || filter(e))) {\n              if (!results.write(withFileTypes ? e : e.fullpath())) {\n                paused = true\n              }\n            }\n          }\n\n          processing--\n          for (const e of entries) {\n            const r = e.realpathCached() || e\n            if (r.shouldWalk(dirs, walkFilter)) {\n              queue.push(r)\n            }\n          }\n          if (paused && !results.flowing) {\n            results.once('drain', process)\n          } else if (!sync) {\n            process()\n          }\n        }\n\n        // zalgo containment\n        let sync = true\n        dir.readdirCB(onReaddir, true)\n        sync = false\n      }\n    }\n    process()\n    return results as Minipass<string> | Minipass<PathBase>\n  }\n\n  /**\n   * Synchronous form of {@link PathScurryBase.stream}\n   *\n   * Returns a Minipass stream that emits {@link PathBase} objects by default,\n   * or strings if `{ withFileTypes: false }` is set in the options.\n   *\n   * Will complete the walk in a single tick if the stream is consumed fully.\n   * Otherwise, will pause as needed for stream backpressure.\n   */\n  streamSync(): Minipass<PathBase>\n  streamSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Minipass<PathBase>\n  streamSync(opts: WalkOptionsWithFileTypesFalse): Minipass<string>\n  streamSync(opts: WalkOptions): Minipass<string | PathBase>\n  streamSync(entry: string | PathBase): Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue\n  ): Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Minipass<string>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Minipass<string> | Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Minipass<string> | Minipass<PathBase> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results = new Minipass<string | PathBase>({ objectMode: true })\n    const dirs = new Set<PathBase>()\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath())\n    }\n    const queue: PathBase[] = [entry]\n    let processing = 0\n    const process = () => {\n      let paused = false\n      while (!paused) {\n        const dir = queue.shift()\n        if (!dir) {\n          if (processing === 0) results.end()\n          return\n        }\n        processing++\n        dirs.add(dir)\n\n        const entries = dir.readdirSync()\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            if (!results.write(withFileTypes ? e : e.fullpath())) {\n              paused = true\n            }\n          }\n        }\n        processing--\n        for (const e of entries) {\n          let r: PathBase | undefined = e\n          if (e.isSymbolicLink()) {\n            if (!(follow && (r = e.realpathSync()))) continue\n            if (r.isUnknown()) r.lstatSync()\n          }\n          if (r.shouldWalk(dirs, walkFilter)) {\n            queue.push(r)\n          }\n        }\n      }\n      if (paused && !results.flowing) results.once('drain', process)\n    }\n    process()\n    return results as Minipass<string> | Minipass<PathBase>\n  }\n\n  chdir(path: string | Path = this.cwd) {\n    const oldCwd = this.cwd\n    this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path\n    this.cwd[setAsCwd](oldCwd)\n  }\n}\n\n/**\n * Options provided to all walk methods.\n */\nexport interface WalkOptions {\n  /**\n   * Return results as {@link PathBase} objects rather than strings.\n   * When set to false, results are fully resolved paths, as returned by\n   * {@link PathBase.fullpath}.\n   * @default true\n   */\n  withFileTypes?: boolean\n\n  /**\n   *  Attempt to read directory entries from symbolic links. Otherwise, only\n   *  actual directories are traversed. Regardless of this setting, a given\n   *  target path will only ever be walked once, meaning that a symbolic link\n   *  to a previously traversed directory will never be followed.\n   *\n   *  Setting this imposes a slight performance penalty, because `readlink`\n   *  must be called on all symbolic links encountered, in order to avoid\n   *  infinite cycles.\n   * @default false\n   */\n  follow?: boolean\n\n  /**\n   * Only return entries where the provided function returns true.\n   *\n   * This will not prevent directories from being traversed, even if they do\n   * not pass the filter, though it will prevent directories themselves from\n   * being included in the result set.  See {@link walkFilter}\n   *\n   * Asynchronous functions are not supported here.\n   *\n   * By default, if no filter is provided, all entries and traversed\n   * directories are included.\n   */\n  filter?: (entry: PathBase) => boolean\n\n  /**\n   * Only traverse directories (and in the case of {@link follow} being set to\n   * true, symbolic links to directories) if the provided function returns\n   * true.\n   *\n   * This will not prevent directories from being included in the result set,\n   * even if they do not pass the supplied filter function.  See {@link filter}\n   * to do that.\n   *\n   * Asynchronous functions are not supported here.\n   */\n  walkFilter?: (entry: PathBase) => boolean\n}\n\nexport type WalkOptionsWithFileTypesUnset = WalkOptions & {\n  withFileTypes?: undefined\n}\nexport type WalkOptionsWithFileTypesTrue = WalkOptions & {\n  withFileTypes: true\n}\nexport type WalkOptionsWithFileTypesFalse = WalkOptions & {\n  withFileTypes: false\n}\n\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */\nexport class PathScurryWin32 extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep: '\\\\' = '\\\\'\n\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {}\n  ) {\n    const { nocase = true } = opts\n    super(cwd, win32, '\\\\', { ...opts, nocase })\n    this.nocase = nocase\n    for (let p: PathBase | undefined = this.cwd; p; p = p.parent) {\n      p.nocase = this.nocase\n    }\n  }\n\n  /**\n   * @internal\n   */\n  parseRootPath(dir: string): string {\n    // if the path starts with a single separator, it's not a UNC, and we'll\n    // just get separator as the root, and driveFromUNC will return \\\n    // In that case, mount \\ on the root from the cwd.\n    return win32.parse(dir).root.toUpperCase()\n  }\n\n  /**\n   * @internal\n   */\n  newRoot(fs: FSValue) {\n    return new PathWin32(\n      this.rootPath,\n      IFDIR,\n      undefined,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      { fs }\n    )\n  }\n\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p: string): boolean {\n    return (\n      p.startsWith('/') || p.startsWith('\\\\') || /^[a-z]:(\\/|\\\\)/i.test(p)\n    )\n  }\n}\n\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nexport class PathScurryPosix extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep: '/' = '/'\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {}\n  ) {\n    const { nocase = false } = opts\n    super(cwd, posix, '/', { ...opts, nocase })\n    this.nocase = nocase\n  }\n\n  /**\n   * @internal\n   */\n  parseRootPath(_dir: string): string {\n    return '/'\n  }\n\n  /**\n   * @internal\n   */\n  newRoot(fs: FSValue) {\n    return new PathPosix(\n      this.rootPath,\n      IFDIR,\n      undefined,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      { fs }\n    )\n  }\n\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p: string): boolean {\n    return p.startsWith('/')\n  }\n}\n\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nexport class PathScurryDarwin extends PathScurryPosix {\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {}\n  ) {\n    const { nocase = true } = opts\n    super(cwd, { ...opts, nocase })\n  }\n}\n\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */\nexport const Path = process.platform === 'win32' ? PathWin32 : PathPosix\nexport type Path = PathBase | InstanceType<typeof Path>\n\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */\nexport const PathScurry:\n  | typeof PathScurryWin32\n  | typeof PathScurryDarwin\n  | typeof PathScurryPosix =\n  process.platform === 'win32'\n    ? PathScurryWin32\n    : process.platform === 'darwin'\n    ? PathScurryDarwin\n    : PathScurryPosix\nexport type PathScurry = PathScurryBase | InstanceType<typeof PathScurry>\n","const proc =\n  typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n      }\nimport { EventEmitter } from 'events'\nimport Stream from 'stream'\nimport { StringDecoder } from 'string_decoder'\n\n/**\n * Same as StringDecoder, but exposing the `lastNeed` flag on the type\n */\ntype SD = StringDecoder & { lastNeed: boolean }\n\nexport type { SD, Pipe, PipeProxyErrors }\n\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nexport const isStream = (\n  s: any\n): s is Minipass.Readable | Minipass.Writable =>\n  !!s &&\n  typeof s === 'object' &&\n  (s instanceof Minipass ||\n    s instanceof Stream ||\n    isReadable(s) ||\n    isWritable(s))\n\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nexport const isReadable = (s: any): s is Minipass.Readable =>\n  !!s &&\n  typeof s === 'object' &&\n  s instanceof EventEmitter &&\n  typeof (s as Minipass.Readable).pipe === 'function' &&\n  // node core Writable streams have a pipe() method, but it throws\n  (s as Minipass.Readable).pipe !== Stream.Writable.prototype.pipe\n\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nexport const isWritable = (s: any): s is Minipass.Readable =>\n  !!s &&\n  typeof s === 'object' &&\n  s instanceof EventEmitter &&\n  typeof (s as Minipass.Writable).write === 'function' &&\n  typeof (s as Minipass.Writable).end === 'function'\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFER = Symbol('buffer')\nconst PIPES = Symbol('pipes')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed')\n// internal event when stream has an error\nconst ERROR = Symbol('error')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\nconst ABORT = Symbol('abort')\nconst ABORTED = Symbol('aborted')\nconst SIGNAL = Symbol('signal')\nconst DATALISTENERS = Symbol('dataListeners')\nconst DISCARDED = Symbol('discarded')\n\nconst defer = (fn: (...a: any[]) => any) => Promise.resolve().then(fn)\nconst nodefer = (fn: (...a: any[]) => any) => fn()\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\ntype EndishEvent = 'end' | 'finish' | 'prefinish'\nconst isEndish = (ev: any): ev is EndishEvent =>\n  ev === 'end' || ev === 'finish' || ev === 'prefinish'\n\nconst isArrayBufferLike = (b: any): b is ArrayBufferLike =>\n  b instanceof ArrayBuffer ||\n  (!!b &&\n    typeof b === 'object' &&\n    b.constructor &&\n    b.constructor.name === 'ArrayBuffer' &&\n    b.byteLength >= 0)\n\nconst isArrayBufferView = (b: any): b is ArrayBufferView =>\n  !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\n/**\n * Options that may be passed to stream.pipe()\n */\nexport interface PipeOptions {\n  /**\n   * end the destination stream when the source stream ends\n   */\n  end?: boolean\n  /**\n   * proxy errors from the source stream to the destination stream\n   */\n  proxyErrors?: boolean\n}\n\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe<T extends unknown> {\n  src: Minipass<T>\n  dest: Minipass<any, T>\n  opts: PipeOptions\n  ondrain: () => any\n  constructor(\n    src: Minipass<T>,\n    dest: Minipass.Writable,\n    opts: PipeOptions\n  ) {\n    this.src = src\n    this.dest = dest as Minipass<any, T>\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    this.dest.on('drain', this.ondrain)\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // only here for the prototype\n  /* c8 ignore start */\n  proxyErrors(_er: any) {}\n  /* c8 ignore stop */\n  end() {\n    this.unpipe()\n    if (this.opts.end) this.dest.end()\n  }\n}\n\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors<T> extends Pipe<T> {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor(\n    src: Minipass<T>,\n    dest: Minipass.Writable,\n    opts: PipeOptions\n  ) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nexport namespace Minipass {\n  /**\n   * Encoding used to create a stream that outputs strings rather than\n   * Buffer objects.\n   */\n  export type Encoding = BufferEncoding | 'buffer' | null\n\n  /**\n   * Any stream that Minipass can pipe into\n   */\n  export type Writable =\n    | Minipass<any, any, any>\n    | NodeJS.WriteStream\n    | (NodeJS.WriteStream & { fd: number })\n    | (EventEmitter & {\n        end(): any\n        write(chunk: any, ...args: any[]): any\n      })\n\n  /**\n   * Any stream that can be read from\n   */\n  export type Readable =\n    | Minipass<any, any, any>\n    | NodeJS.ReadStream\n    | (NodeJS.ReadStream & { fd: number })\n    | (EventEmitter & {\n        pause(): any\n        resume(): any\n        pipe(...destArgs: any[]): any\n      })\n\n  /**\n   * Utility type that can be iterated sync or async\n   */\n  export type DualIterable<T> = Iterable<T> & AsyncIterable<T>\n\n  type EventArguments = Record<string | symbol, unknown[]>\n\n  /**\n   * The listing of events that a Minipass class can emit.\n   * Extend this when extending the Minipass class, and pass as\n   * the third template argument.  The key is the name of the event,\n   * and the value is the argument list.\n   *\n   * Any undeclared events will still be allowed, but the handler will get\n   * arguments as `unknown[]`.\n   */\n  export interface Events<RType extends any = Buffer>\n    extends EventArguments {\n    readable: []\n    data: [chunk: RType]\n    error: [er: unknown]\n    abort: [reason: unknown]\n    drain: []\n    resume: []\n    end: []\n    finish: []\n    prefinish: []\n    close: []\n    [DESTROYED]: [er?: unknown]\n    [ERROR]: [er: unknown]\n  }\n\n  /**\n   * String or buffer-like data that can be joined and sliced\n   */\n  export type ContiguousData =\n    | Buffer\n    | ArrayBufferLike\n    | ArrayBufferView\n    | string\n  export type BufferOrString = Buffer | string\n\n  /**\n   * Options passed to the Minipass constructor.\n   */\n  export type SharedOptions = {\n    /**\n     * Defer all data emission and other events until the end of the\n     * current tick, similar to Node core streams\n     */\n    async?: boolean\n    /**\n     * A signal which will abort the stream\n     */\n    signal?: AbortSignal\n    /**\n     * Output string encoding. Set to `null` or `'buffer'` (or omit) to\n     * emit Buffer objects rather than strings.\n     *\n     * Conflicts with `objectMode`\n     */\n    encoding?: BufferEncoding | null | 'buffer'\n    /**\n     * Output data exactly as it was written, supporting non-buffer/string\n     * data (such as arbitrary objects, falsey values, etc.)\n     *\n     * Conflicts with `encoding`\n     */\n    objectMode?: boolean\n  }\n\n  /**\n   * Options for a string encoded output\n   */\n  export type EncodingOptions = SharedOptions & {\n    encoding: BufferEncoding\n    objectMode?: false\n  }\n\n  /**\n   * Options for contiguous data buffer output\n   */\n  export type BufferOptions = SharedOptions & {\n    encoding?: null | 'buffer'\n    objectMode?: false\n  }\n\n  /**\n   * Options for objectMode arbitrary output\n   */\n  export type ObjectModeOptions = SharedOptions & {\n    objectMode: true\n    encoding?: null\n  }\n\n  /**\n   * Utility type to determine allowed options based on read type\n   */\n  export type Options<T> = T extends string\n    ? EncodingOptions | ObjectModeOptions\n    : T extends Buffer\n    ? BufferOptions | ObjectModeOptions\n    : SharedOptions\n}\n\nconst isObjectModeOptions = (\n  o: Minipass.SharedOptions\n): o is Minipass.ObjectModeOptions => !!o.objectMode\n\nconst isEncodingOptions = (\n  o: Minipass.SharedOptions\n): o is Minipass.EncodingOptions =>\n  !o.objectMode && !!o.encoding && o.encoding !== 'buffer'\n\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nexport class Minipass<\n    RType extends unknown = Buffer,\n    WType extends unknown = RType extends Minipass.BufferOrString\n      ? Minipass.ContiguousData\n      : RType,\n    Events extends Minipass.Events<RType> = Minipass.Events<RType>\n  >\n  extends EventEmitter\n  implements Minipass.DualIterable<RType>\n{\n  [FLOWING]: boolean = false;\n  [PAUSED]: boolean = false;\n  [PIPES]: Pipe<RType>[] = [];\n  [BUFFER]: RType[] = [];\n  [OBJECTMODE]: boolean;\n  [ENCODING]: BufferEncoding | null;\n  [ASYNC]: boolean;\n  [DECODER]: SD | null;\n  [EOF]: boolean = false;\n  [EMITTED_END]: boolean = false;\n  [EMITTING_END]: boolean = false;\n  [CLOSED]: boolean = false;\n  [EMITTED_ERROR]: unknown = null;\n  [BUFFERLENGTH]: number = 0;\n  [DESTROYED]: boolean = false;\n  [SIGNAL]?: AbortSignal;\n  [ABORTED]: boolean = false;\n  [DATALISTENERS]: number = 0;\n  [DISCARDED]: boolean = false\n\n  /**\n   * true if the stream can be written\n   */\n  writable: boolean = true\n  /**\n   * true if the stream can be read\n   */\n  readable: boolean = true\n\n  /**\n   * If `RType` is Buffer, then options do not need to be provided.\n   * Otherwise, an options object must be provided to specify either\n   * {@link Minipass.SharedOptions.objectMode} or\n   * {@link Minipass.SharedOptions.encoding}, as appropriate.\n   */\n  constructor(\n    ...args: RType extends Buffer\n      ? [] | [Minipass.Options<RType>]\n      : [Minipass.Options<RType>]\n  ) {\n    const options: Minipass.Options<RType> = (args[0] ||\n      {}) as Minipass.Options<RType>\n    super()\n    if (options.objectMode && typeof options.encoding === 'string') {\n      throw new TypeError(\n        'Encoding and objectMode may not be used together'\n      )\n    }\n    if (isObjectModeOptions(options)) {\n      this[OBJECTMODE] = true\n      this[ENCODING] = null\n    } else if (isEncodingOptions(options)) {\n      this[ENCODING] = options.encoding\n      this[OBJECTMODE] = false\n    } else {\n      this[OBJECTMODE] = false\n      this[ENCODING] = null\n    }\n    this[ASYNC] = !!options.async\n    this[DECODER] = this[ENCODING]\n      ? (new StringDecoder(this[ENCODING]) as SD)\n      : null\n\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })\n    }\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })\n    }\n\n    const { signal } = options\n    if (signal) {\n      this[SIGNAL] = signal\n      if (signal.aborted) {\n        this[ABORT]()\n      } else {\n        signal.addEventListener('abort', () => this[ABORT]())\n      }\n    }\n  }\n\n  /**\n   * The amount of data stored in the buffer waiting to be read.\n   *\n   * For Buffer strings, this will be the total byte length.\n   * For string encoding streams, this will be the string character length,\n   * according to JavaScript's `string.length` logic.\n   * For objectMode streams, this is a count of the items waiting to be\n   * emitted.\n   */\n  get bufferLength() {\n    return this[BUFFERLENGTH]\n  }\n\n  /**\n   * The `BufferEncoding` currently in use, or `null`\n   */\n  get encoding() {\n    return this[ENCODING]\n  }\n\n  /**\n   * @deprecated - This is a read only property\n   */\n  set encoding(_enc) {\n    throw new Error('Encoding must be set at instantiation time')\n  }\n\n  /**\n   * @deprecated - Encoding may only be set at instantiation time\n   */\n  setEncoding(_enc: Minipass.Encoding) {\n    throw new Error('Encoding must be set at instantiation time')\n  }\n\n  /**\n   * True if this is an objectMode stream\n   */\n  get objectMode() {\n    return this[OBJECTMODE]\n  }\n\n  /**\n   * @deprecated - This is a read-only property\n   */\n  set objectMode(_om) {\n    throw new Error('objectMode must be set at instantiation time')\n  }\n\n  /**\n   * true if this is an async stream\n   */\n  get ['async'](): boolean {\n    return this[ASYNC]\n  }\n  /**\n   * Set to true to make this stream async.\n   *\n   * Once set, it cannot be unset, as this would potentially cause incorrect\n   * behavior.  Ie, a sync stream can be made async, but an async stream\n   * cannot be safely made sync.\n   */\n  set ['async'](a: boolean) {\n    this[ASYNC] = this[ASYNC] || !!a\n  }\n\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true\n    this.emit('abort', this[SIGNAL]?.reason)\n    this.destroy(this[SIGNAL]?.reason)\n  }\n\n  /**\n   * True if the stream has been aborted.\n   */\n  get aborted() {\n    return this[ABORTED]\n  }\n  /**\n   * No-op setter. Stream aborted status is set via the AbortSignal provided\n   * in the constructor options.\n   */\n  set aborted(_) {}\n\n  /**\n   * Write data into the stream\n   *\n   * If the chunk written is a string, and encoding is not specified, then\n   * `utf8` will be assumed. If the stream encoding matches the encoding of\n   * a written string, and the state of the string decoder allows it, then\n   * the string will be passed through to either the output or the internal\n   * buffer without any processing. Otherwise, it will be turned into a\n   * Buffer object for processing into the desired encoding.\n   *\n   * If provided, `cb` function is called immediately before return for\n   * sync streams, or on next tick for async streams, because for this\n   * base class, a chunk is considered \"processed\" once it is accepted\n   * and either emitted or buffered. That is, the callback does not indicate\n   * that the chunk has been eventually emitted, though of course child\n   * classes can override this function to do whatever processing is required\n   * and call `super.write(...)` only once processing is completed.\n   */\n  write(chunk: WType, cb?: () => void): boolean\n  write(\n    chunk: WType,\n    encoding?: Minipass.Encoding,\n    cb?: () => void\n  ): boolean\n  write(\n    chunk: WType,\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void\n  ): boolean {\n    if (this[ABORTED]) return false\n    if (this[EOF]) throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit(\n        'error',\n        Object.assign(\n          new Error('Cannot call write after a stream was destroyed'),\n          { code: 'ERR_STREAM_DESTROYED' }\n        )\n      )\n      return true\n    }\n\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = 'utf8'\n    }\n\n    if (!encoding) encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : nodefer\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything is only allowed if in object mode, so throw\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(\n          chunk.buffer,\n          chunk.byteOffset,\n          chunk.byteLength\n        )\n      } else if (isArrayBufferLike(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(chunk)\n      } else if (typeof chunk !== 'string') {\n        throw new Error(\n          'Non-contiguous data written to non-objectMode stream'\n        )\n      }\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      // maybe impossible?\n      /* c8 ignore start */\n      if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n      /* c8 ignore stop */\n\n      if (this[FLOWING]) this.emit('data', chunk as unknown as RType)\n      else this[BUFFERPUSH](chunk as unknown as RType)\n\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n      if (cb) fn(cb)\n\n      return this[FLOWING]\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!(chunk as Minipass.BufferOrString).length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n      if (cb) fn(cb)\n      return this[FLOWING]\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (\n      typeof chunk === 'string' &&\n      // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)\n    ) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = this[DECODER].write(chunk)\n    }\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n    if (this[FLOWING]) this.emit('data', chunk as unknown as RType)\n    else this[BUFFERPUSH](chunk as unknown as RType)\n\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n    if (cb) fn(cb)\n\n    return this[FLOWING]\n  }\n\n  /**\n   * Low-level explicit read method.\n   *\n   * In objectMode, the argument is ignored, and one item is returned if\n   * available.\n   *\n   * `n` is the number of bytes (or in the case of encoding streams,\n   * characters) to consume. If `n` is not provided, then the entire buffer\n   * is returned, or `null` is returned if no data is available.\n   *\n   * If `n` is greater that the amount of data in the internal buffer,\n   * then `null` is returned.\n   */\n  read(n?: number | null): RType | null {\n    if (this[DESTROYED]) return null\n    this[DISCARDED] = false\n\n    if (\n      this[BUFFERLENGTH] === 0 ||\n      n === 0 ||\n      (n && n > this[BUFFERLENGTH])\n    ) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE]) n = null\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      // not object mode, so if we have an encoding, then RType is string\n      // otherwise, must be Buffer\n      this[BUFFER] = [\n        (this[ENCODING]\n          ? this[BUFFER].join('')\n          : Buffer.concat(\n              this[BUFFER] as Buffer[],\n              this[BUFFERLENGTH]\n            )) as RType,\n      ]\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0] as RType)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ](n: number | null, chunk: RType) {\n    if (this[OBJECTMODE]) this[BUFFERSHIFT]()\n    else {\n      const c = chunk as Minipass.BufferOrString\n      if (n === c.length || n === null) this[BUFFERSHIFT]()\n      else if (typeof c === 'string') {\n        this[BUFFER][0] = c.slice(n) as RType\n        chunk = c.slice(0, n) as RType\n        this[BUFFERLENGTH] -= n\n      } else {\n        this[BUFFER][0] = c.subarray(n) as RType\n        chunk = c.subarray(0, n) as RType\n        this[BUFFERLENGTH] -= n\n      }\n    }\n\n    this.emit('data', chunk)\n\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')\n\n    return chunk\n  }\n\n  /**\n   * End the stream, optionally providing a final write.\n   *\n   * See {@link Minipass#write} for argument descriptions\n   */\n  end(cb?: () => void): this\n  end(chunk: WType, cb?: () => void): this\n  end(chunk: WType, encoding?: Minipass.Encoding, cb?: () => void): this\n  end(\n    chunk?: WType | (() => void),\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void\n  ) {\n    if (typeof chunk === 'function') {\n      cb = chunk as () => void\n      chunk = undefined\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = 'utf8'\n    }\n    if (chunk !== undefined) this.write(chunk, encoding)\n    if (cb) this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this[FLOWING] || !this[PAUSED]) this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return\n\n    if (!this[DATALISTENERS] && !this[PIPES].length) {\n      this[DISCARDED] = true\n    }\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this[BUFFER].length) this[FLUSH]()\n    else if (this[EOF]) this[MAYBE_EMIT_END]()\n    else this.emit('drain')\n  }\n\n  /**\n   * Resume the stream if it is currently in a paused state\n   *\n   * If called when there are no pipe destinations or `data` event listeners,\n   * this will place the stream in a \"discarded\" state, where all data will\n   * be thrown away. The discarded state is removed if a pipe destination or\n   * data handler is added, if pause() is called, or if any synchronous or\n   * asynchronous iteration is started.\n   */\n  resume() {\n    return this[RESUME]()\n  }\n\n  /**\n   * Pause the stream\n   */\n  pause() {\n    this[FLOWING] = false\n    this[PAUSED] = true\n    this[DISCARDED] = false\n  }\n\n  /**\n   * true if the stream has been forcibly destroyed\n   */\n  get destroyed() {\n    return this[DESTROYED]\n  }\n\n  /**\n   * true if the stream is currently in a flowing state, meaning that\n   * any writes will be immediately emitted.\n   */\n  get flowing() {\n    return this[FLOWING]\n  }\n\n  /**\n   * true if the stream is currently in a paused state\n   */\n  get paused() {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH](chunk: RType) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1\n    else this[BUFFERLENGTH] += (chunk as Minipass.BufferOrString).length\n    this[BUFFER].push(chunk)\n  }\n\n  [BUFFERSHIFT](): RType {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1\n    else\n      this[BUFFERLENGTH] -= (\n        this[BUFFER][0] as Minipass.BufferOrString\n      ).length\n    return this[BUFFER].shift() as RType\n  }\n\n  [FLUSH](noDrain: boolean = false) {\n    do {} while (\n      this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n      this[BUFFER].length\n    )\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')\n  }\n\n  [FLUSHCHUNK](chunk: RType) {\n    this.emit('data', chunk)\n    return this[FLOWING]\n  }\n\n  /**\n   * Pipe all data emitted by this stream into the destination provided.\n   *\n   * Triggers the flow of data.\n   */\n  pipe<W extends Minipass.Writable>(dest: W, opts?: PipeOptions): W {\n    if (this[DESTROYED]) return dest\n    this[DISCARDED] = false\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false\n    else opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end()\n    } else {\n      // \"as\" here just ignores the WType, which pipes don't care about,\n      // since they're only consuming from us, and writing to the dest\n      this[PIPES].push(\n        !opts.proxyErrors\n          ? new Pipe<RType>(this as Minipass<RType>, dest, opts)\n          : new PipeProxyErrors<RType>(this as Minipass<RType>, dest, opts)\n      )\n      if (this[ASYNC]) defer(() => this[RESUME]())\n      else this[RESUME]()\n    }\n\n    return dest\n  }\n\n  /**\n   * Fully unhook a piped destination stream.\n   *\n   * If the destination stream was the only consumer of this stream (ie,\n   * there are no other piped destinations or `'data'` event listeners)\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  unpipe<W extends Minipass.Writable>(dest: W) {\n    const p = this[PIPES].find(p => p.dest === dest)\n    if (p) {\n      if (this[PIPES].length === 1) {\n        if (this[FLOWING] && this[DATALISTENERS] === 0) {\n          this[FLOWING] = false\n        }\n        this[PIPES] = []\n      } else this[PIPES].splice(this[PIPES].indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  /**\n   * Alias for {@link Minipass#on}\n   */\n  addListener<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ): this {\n    return this.on(ev, handler)\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.on`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * - Adding a 'data' event handler will trigger the flow of data\n   *\n   * - Adding a 'readable' event handler when there is data waiting to be read\n   *   will cause 'readable' to be emitted immediately.\n   *\n   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n   *   already passed will cause the event to be emitted immediately and all\n   *   handlers removed.\n   *\n   * - Adding an 'error' event handler after an error has been emitted will\n   *   cause the event to be re-emitted immediately with the error previously\n   *   raised.\n   */\n  on<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ): this {\n    const ret = super.on(\n      ev as string | symbol,\n      handler as (...a: any[]) => any\n    )\n    if (ev === 'data') {\n      this[DISCARDED] = false\n      this[DATALISTENERS]++\n      if (!this[PIPES].length && !this[FLOWING]) {\n        this[RESUME]()\n      }\n    } else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n      super.emit('readable')\n    } else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      const h = handler as (...a: Events['error']) => any\n      if (this[ASYNC]) defer(() => h.call(this, this[EMITTED_ERROR]))\n      else h.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  /**\n   * Alias for {@link Minipass#off}\n   */\n  removeListener<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ) {\n    return this.off(ev, handler)\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.off`\n   *\n   * If a 'data' event handler is removed, and it was the last consumer\n   * (ie, there are no pipe destinations or other 'data' event listeners),\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  off<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ) {\n    const ret = super.off(\n      ev as string | symbol,\n      handler as (...a: any[]) => any\n    )\n    // if we previously had listeners, and now we don't, and we don't\n    // have any pipes, then stop the flow, unless it's been explicitly\n    // put in a discarded flowing state via stream.resume().\n    if (ev === 'data') {\n      this[DATALISTENERS] = this.listeners('data').length\n      if (\n        this[DATALISTENERS] === 0 &&\n        !this[DISCARDED] &&\n        !this[PIPES].length\n      ) {\n        this[FLOWING] = false\n      }\n    }\n    return ret\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.removeAllListeners`\n   *\n   * If all 'data' event handlers are removed, and they were the last consumer\n   * (ie, there are no pipe destinations), then the flow of data will stop\n   * until there is another consumer or {@link Minipass#resume} is explicitly\n   * called.\n   */\n  removeAllListeners<Event extends keyof Events>(ev?: Event) {\n    const ret = super.removeAllListeners(ev as string | symbol | undefined)\n    if (ev === 'data' || ev === undefined) {\n      this[DATALISTENERS] = 0\n      if (!this[DISCARDED] && !this[PIPES].length) {\n        this[FLOWING] = false\n      }\n    }\n    return ret\n  }\n\n  /**\n   * true if the 'end' event has been emitted\n   */\n  get emittedEnd() {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (\n      !this[EMITTING_END] &&\n      !this[EMITTED_END] &&\n      !this[DESTROYED] &&\n      this[BUFFER].length === 0 &&\n      this[EOF]\n    ) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED]) this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.emit`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * If the stream has been destroyed, and the event is something other\n   * than 'close' or 'error', then `false` is returned and no handlers\n   * are called.\n   *\n   * If the event is 'end', and has already been emitted, then the event\n   * is ignored. If the stream is in a paused or non-flowing state, then\n   * the event will be deferred until data flow resumes. If the stream is\n   * async, then handlers will be called on the next tick rather than\n   * immediately.\n   *\n   * If the event is 'close', and 'end' has not yet been emitted, then\n   * the event will be deferred until after 'end' is emitted.\n   *\n   * If the event is 'error', and an AbortSignal was provided for the stream,\n   * and there are no listeners, then the event is ignored, matching the\n   * behavior of node core streams in the presense of an AbortSignal.\n   *\n   * If the event is 'finish' or 'prefinish', then all listeners will be\n   * removed after emitting the event, to prevent double-firing.\n   */\n  emit<Event extends keyof Events>(\n    ev: Event,\n    ...args: Events[Event]\n  ): boolean {\n    const data = args[0]\n    // error and close are only events allowed after calling destroy()\n    if (\n      ev !== 'error' &&\n      ev !== 'close' &&\n      ev !== DESTROYED &&\n      this[DESTROYED]\n    ) {\n      return false\n    } else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data\n        ? false\n        : this[ASYNC]\n        ? (defer(() => this[EMITDATA](data as RType)), true)\n        : this[EMITDATA](data as RType)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return false\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      super.emit(ERROR, data)\n      const ret =\n        !this[SIGNAL] || this.listeners('error').length\n          ? super.emit('error', data)\n          : false\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev as string, ...args)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA](data: RType) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause()\n    }\n    const ret = this[DISCARDED] ? false : super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return false\n\n    this[EMITTED_END] = true\n    this.readable = false\n    return this[ASYNC]\n      ? (defer(() => this[EMITEND2]()), true)\n      : this[EMITEND2]()\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data as RType)\n        }\n        if (!this[DISCARDED]) super.emit('data', data)\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  /**\n   * Return a Promise that resolves to an array of all emitted data once\n   * the stream ends.\n   */\n  async collect(): Promise<RType[] & { dataLength: number }> {\n    const buf: RType[] & { dataLength: number } = Object.assign([], {\n      dataLength: 0,\n    })\n    if (!this[OBJECTMODE]) buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += (c as Minipass.BufferOrString).length\n    })\n    await p\n    return buf\n  }\n\n  /**\n   * Return a Promise that resolves to the concatenation of all emitted data\n   * once the stream ends.\n   *\n   * Not allowed on objectMode streams.\n   */\n  async concat(): Promise<RType> {\n    if (this[OBJECTMODE]) {\n      throw new Error('cannot concat in objectMode')\n    }\n    const buf = await this.collect()\n    return (\n      this[ENCODING]\n        ? buf.join('')\n        : Buffer.concat(buf as Buffer[], buf.dataLength)\n    ) as RType\n  }\n\n  /**\n   * Return a void Promise that resolves once the stream ends.\n   */\n  async promise(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  /**\n   * Asynchronous `for await of` iteration.\n   *\n   * This will continue emitting all chunks until the stream terminates.\n   */\n  [Symbol.asyncIterator](): AsyncGenerator<RType, void, void> {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false\n    let stopped = false\n    const stop = async (): Promise<IteratorReturnResult<void>> => {\n      this.pause()\n      stopped = true\n      return { value: undefined, done: true }\n    }\n    const next = (): Promise<IteratorResult<RType, void>> => {\n      if (stopped) return stop()\n      const res = this.read()\n      if (res !== null) return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF]) return stop()\n\n      let resolve!: (res: IteratorResult<RType>) => void\n      let reject!: (er: unknown) => void\n      const onerr = (er: unknown) => {\n        this.off('data', ondata)\n        this.off('end', onend)\n        this.off(DESTROYED, ondestroy)\n        stop()\n        reject(er)\n      }\n      const ondata = (value: RType) => {\n        this.off('error', onerr)\n        this.off('end', onend)\n        this.off(DESTROYED, ondestroy)\n        this.pause()\n        resolve({ value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.off('error', onerr)\n        this.off('data', ondata)\n        this.off(DESTROYED, ondestroy)\n        stop()\n        resolve({ done: true, value: undefined })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise<IteratorResult<RType>>((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.asyncIterator]() {\n        return this\n      },\n    }\n  }\n\n  /**\n   * Synchronous `for of` iteration.\n   *\n   * The iteration will terminate when the internal buffer runs out, even\n   * if the stream has not yet terminated.\n   */\n  [Symbol.iterator](): Generator<RType, void, void> {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false\n    let stopped = false\n    const stop = (): IteratorReturnResult<void> => {\n      this.pause()\n      this.off(ERROR, stop)\n      this.off(DESTROYED, stop)\n      this.off('end', stop)\n      stopped = true\n      return { done: true, value: undefined }\n    }\n\n    const next = (): IteratorResult<RType, void> => {\n      if (stopped) return stop()\n      const value = this.read()\n      return value === null ? stop() : { done: false, value }\n    }\n\n    this.once('end', stop)\n    this.once(ERROR, stop)\n    this.once(DESTROYED, stop)\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.iterator]() {\n        return this\n      },\n    }\n  }\n\n  /**\n   * Destroy a stream, preventing it from being used for any further purpose.\n   *\n   * If the stream has a `close()` method, then it will be called on\n   * destruction.\n   *\n   * After destruction, any attempt to write data, read data, or emit most\n   * events will be ignored.\n   *\n   * If an error argument is provided, then it will be emitted in an\n   * 'error' event.\n   */\n  destroy(er?: unknown) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er)\n      else this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n    this[DISCARDED] = true\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0\n    this[BUFFERLENGTH] = 0\n\n    const wc = this as Minipass<RType, WType, Events> & {\n      close?: () => void\n    }\n    if (typeof wc.close === 'function' && !this[CLOSED]) wc.close()\n\n    if (er) this.emit('error', er)\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED)\n\n    return this\n  }\n\n  /**\n   * Alias for {@link isStream}\n   *\n   * Former export location, maintained for backwards compatibility.\n   *\n   * @deprecated\n   */\n  static get isStream() {\n    return isStream\n  }\n}\n","import { Minimatch, MinimatchOptions } from 'minimatch'\nimport { Minipass } from 'minipass'\nimport {\n  FSOption,\n  Path,\n  PathScurry,\n  PathScurryDarwin,\n  PathScurryPosix,\n  PathScurryWin32,\n} from 'path-scurry'\nimport { fileURLToPath } from 'url'\nimport { IgnoreLike } from './ignore.js'\nimport { Pattern } from './pattern.js'\nimport { GlobStream, GlobWalker } from './walker.js'\n\nexport type MatchSet = Minimatch['set']\nexport type GlobParts = Exclude<Minimatch['globParts'], undefined>\n\n// if no process global, just call it linux.\n// so we default to case-sensitive, / separators\nconst defaultPlatform: NodeJS.Platform =\n  typeof process === 'object' &&\n  process &&\n  typeof process.platform === 'string'\n    ? process.platform\n    : 'linux'\n\n/**\n * A `GlobOptions` object may be provided to any of the exported methods, and\n * must be provided to the `Glob` constructor.\n *\n * All options are optional, boolean, and false by default, unless otherwise\n * noted.\n *\n * All resolved options are added to the Glob object as properties.\n *\n * If you are running many `glob` operations, you can pass a Glob object as the\n * `options` argument to a subsequent operation to share the previously loaded\n * cache.\n */\nexport interface GlobOptions {\n  /**\n   * Set to `true` to always receive absolute paths for\n   * matched files. Set to `false` to always return relative paths.\n   *\n   * When this option is not set, absolute paths are returned for patterns\n   * that are absolute, and otherwise paths are returned that are relative\n   * to the `cwd` setting.\n   *\n   * This does _not_ make an extra system call to get\n   * the realpath, it only does string path resolution.\n   *\n   * Conflicts with {@link withFileTypes}\n   */\n  absolute?: boolean\n\n  /**\n   * Set to false to enable {@link windowsPathsNoEscape}\n   *\n   * @deprecated\n   */\n  allowWindowsEscape?: boolean\n\n  /**\n   * The current working directory in which to search. Defaults to\n   * `process.cwd()`.\n   *\n   * May be eiher a string path or a `file://` URL object or string.\n   */\n  cwd?: string | URL\n\n  /**\n   * Include `.dot` files in normal matches and `globstar`\n   * matches. Note that an explicit dot in a portion of the pattern\n   * will always match dot files.\n   */\n  dot?: boolean\n\n  /**\n   * Prepend all relative path strings with `./` (or `.\\` on Windows).\n   *\n   * Without this option, returned relative paths are \"bare\", so instead of\n   * returning `'./foo/bar'`, they are returned as `'foo/bar'`.\n   *\n   * Relative patterns starting with `'../'` are not prepended with `./`, even\n   * if this option is set.\n   */\n  dotRelative?: boolean\n\n  /**\n   * Follow symlinked directories when expanding `**`\n   * patterns. This can result in a lot of duplicate references in\n   * the presence of cyclic links, and make performance quite bad.\n   *\n   * By default, a `**` in a pattern will follow 1 symbolic link if\n   * it is not the first item in the pattern, or none if it is the\n   * first item in the pattern, following the same behavior as Bash.\n   */\n  follow?: boolean\n\n  /**\n   * string or string[], or an object with `ignore` and `ignoreChildren`\n   * methods.\n   *\n   * If a string or string[] is provided, then this is treated as a glob\n   * pattern or array of glob patterns to exclude from matches. To ignore all\n   * children within a directory, as well as the entry itself, append `'/**'`\n   * to the ignore pattern.\n   *\n   * **Note** `ignore` patterns are _always_ in `dot:true` mode, regardless of\n   * any other settings.\n   *\n   * If an object is provided that has `ignored(path)` and/or\n   * `childrenIgnored(path)` methods, then these methods will be called to\n   * determine whether any Path is a match or if its children should be\n   * traversed, respectively.\n   */\n  ignore?: string | string[] | IgnoreLike\n\n  /**\n   * Treat brace expansion like `{a,b}` as a \"magic\" pattern. Has no\n   * effect if {@link nobrace} is set.\n   *\n   * Only has effect on the {@link hasMagic} function.\n   */\n  magicalBraces?: boolean\n\n  /**\n   * Add a `/` character to directory matches. Note that this requires\n   * additional stat calls in some cases.\n   */\n  mark?: boolean\n\n  /**\n   * Perform a basename-only match if the pattern does not contain any slash\n   * characters. That is, `*.js` would be treated as equivalent to\n   * `**\\/*.js`, matching all js files in all directories.\n   */\n  matchBase?: boolean\n\n  /**\n   * Limit the directory traversal to a given depth below the cwd.\n   * Note that this does NOT prevent traversal to sibling folders,\n   * root patterns, and so on. It only limits the maximum folder depth\n   * that the walk will descend, relative to the cwd.\n   */\n  maxDepth?: number\n\n  /**\n   * Do not expand `{a,b}` and `{1..3}` brace sets.\n   */\n  nobrace?: boolean\n\n  /**\n   * Perform a case-insensitive match. This defaults to `true` on macOS and\n   * Windows systems, and `false` on all others.\n   *\n   * **Note** `nocase` should only be explicitly set when it is\n   * known that the filesystem's case sensitivity differs from the\n   * platform default. If set `true` on case-sensitive file\n   * systems, or `false` on case-insensitive file systems, then the\n   * walk may return more or less results than expected.\n   */\n  nocase?: boolean\n\n  /**\n   * Do not match directories, only files. (Note: to match\n   * _only_ directories, put a `/` at the end of the pattern.)\n   */\n  nodir?: boolean\n\n  /**\n   * Do not match \"extglob\" patterns such as `+(a|b)`.\n   */\n  noext?: boolean\n\n  /**\n   * Do not match `**` against multiple filenames. (Ie, treat it as a normal\n   * `*` instead.)\n   *\n   * Conflicts with {@link matchBase}\n   */\n  noglobstar?: boolean\n\n  /**\n   * Defaults to value of `process.platform` if available, or `'linux'` if\n   * not. Setting `platform:'win32'` on non-Windows systems may cause strange\n   * behavior.\n   */\n  platform?: NodeJS.Platform\n\n  /**\n   * Set to true to call `fs.realpath` on all of the\n   * results. In the case of an entry that cannot be resolved, the\n   * entry is omitted. This incurs a slight performance penalty, of\n   * course, because of the added system calls.\n   */\n  realpath?: boolean\n\n  /**\n   *\n   * A string path resolved against the `cwd` option, which\n   * is used as the starting point for absolute patterns that start\n   * with `/`, (but not drive letters or UNC paths on Windows).\n   *\n   * Note that this _doesn't_ necessarily limit the walk to the\n   * `root` directory, and doesn't affect the cwd starting point for\n   * non-absolute patterns. A pattern containing `..` will still be\n   * able to traverse out of the root directory, if it is not an\n   * actual root directory on the filesystem, and any non-absolute\n   * patterns will be matched in the `cwd`. For example, the\n   * pattern `/../*` with `{root:'/some/path'}` will return all\n   * files in `/some`, not all files in `/some/path`. The pattern\n   * `*` with `{root:'/some/path'}` will return all the entries in\n   * the cwd, not the entries in `/some/path`.\n   *\n   * To start absolute and non-absolute patterns in the same\n   * path, you can use `{root:''}`. However, be aware that on\n   * Windows systems, a pattern like `x:/*` or `//host/share/*` will\n   * _always_ start in the `x:/` or `//host/share` directory,\n   * regardless of the `root` setting.\n   */\n  root?: string\n\n  /**\n   * A [PathScurry](http://npm.im/path-scurry) object used\n   * to traverse the file system. If the `nocase` option is set\n   * explicitly, then any provided `scurry` object must match this\n   * setting.\n   */\n  scurry?: PathScurry\n\n  /**\n   * Call `lstat()` on all entries, whether required or not to determine\n   * if it's a valid match. When used with {@link withFileTypes}, this means\n   * that matches will include data such as modified time, permissions, and\n   * so on.  Note that this will incur a performance cost due to the added\n   * system calls.\n   */\n  stat?: boolean\n\n  /**\n   * An AbortSignal which will cancel the Glob walk when\n   * triggered.\n   */\n  signal?: AbortSignal\n\n  /**\n   * Use `\\\\` as a path separator _only_, and\n   *  _never_ as an escape character. If set, all `\\\\` characters are\n   *  replaced with `/` in the pattern.\n   *\n   *  Note that this makes it **impossible** to match against paths\n   *  containing literal glob pattern characters, but allows matching\n   *  with patterns constructed using `path.join()` and\n   *  `path.resolve()` on Windows platforms, mimicking the (buggy!)\n   *  behavior of Glob v7 and before on Windows. Please use with\n   *  caution, and be mindful of [the caveat below about Windows\n   *  paths](#windows). (For legacy reasons, this is also set if\n   *  `allowWindowsEscape` is set to the exact value `false`.)\n   */\n  windowsPathsNoEscape?: boolean\n\n  /**\n   * Return [PathScurry](http://npm.im/path-scurry)\n   * `Path` objects instead of strings. These are similar to a\n   * NodeJS `Dirent` object, but with additional methods and\n   * properties.\n   *\n   * Conflicts with {@link absolute}\n   */\n  withFileTypes?: boolean\n\n  /**\n   * An fs implementation to override some or all of the defaults.  See\n   * http://npm.im/path-scurry for details about what can be overridden.\n   */\n  fs?: FSOption\n\n  /**\n   * Just passed along to Minimatch.  Note that this makes all pattern\n   * matching operations slower and *extremely* noisy.\n   */\n  debug?: boolean\n\n  /**\n   * Return `/` delimited paths, even on Windows.\n   *\n   * On posix systems, this has no effect.  But, on Windows, it means that\n   * paths will be `/` delimited, and absolute paths will be their full\n   * resolved UNC forms, eg instead of `'C:\\\\foo\\\\bar'`, it would return\n   * `'//?/C:/foo/bar'`\n   */\n  posix?: boolean\n}\n\nexport type GlobOptionsWithFileTypesTrue = GlobOptions & {\n  withFileTypes: true\n  // string options not relevant if returning Path objects.\n  absolute?: undefined\n  mark?: undefined\n  posix?: undefined\n}\n\nexport type GlobOptionsWithFileTypesFalse = GlobOptions & {\n  withFileTypes?: false\n}\n\nexport type GlobOptionsWithFileTypesUnset = GlobOptions & {\n  withFileTypes?: undefined\n}\n\nexport type Result<Opts> = Opts extends GlobOptionsWithFileTypesTrue\n  ? Path\n  : Opts extends GlobOptionsWithFileTypesFalse\n  ? string\n  : Opts extends GlobOptionsWithFileTypesUnset\n  ? string\n  : string | Path\nexport type Results<Opts> = Result<Opts>[]\n\nexport type FileTypes<Opts> = Opts extends GlobOptionsWithFileTypesTrue\n  ? true\n  : Opts extends GlobOptionsWithFileTypesFalse\n  ? false\n  : Opts extends GlobOptionsWithFileTypesUnset\n  ? false\n  : boolean\n\n/**\n * An object that can perform glob pattern traversals.\n */\nexport class Glob<Opts extends GlobOptions> implements GlobOptions {\n  absolute?: boolean\n  cwd: string\n  root?: string\n  dot: boolean\n  dotRelative: boolean\n  follow: boolean\n  ignore?: string | string[] | IgnoreLike\n  magicalBraces: boolean\n  mark?: boolean\n  matchBase: boolean\n  maxDepth: number\n  nobrace: boolean\n  nocase: boolean\n  nodir: boolean\n  noext: boolean\n  noglobstar: boolean\n  pattern: string[]\n  platform: NodeJS.Platform\n  realpath: boolean\n  scurry: PathScurry\n  stat: boolean\n  signal?: AbortSignal\n  windowsPathsNoEscape: boolean\n  withFileTypes: FileTypes<Opts>\n\n  /**\n   * The options provided to the constructor.\n   */\n  opts: Opts\n\n  /**\n   * An array of parsed immutable {@link Pattern} objects.\n   */\n  patterns: Pattern[]\n\n  /**\n   * All options are stored as properties on the `Glob` object.\n   *\n   * See {@link GlobOptions} for full options descriptions.\n   *\n   * Note that a previous `Glob` object can be passed as the\n   * `GlobOptions` to another `Glob` instantiation to re-use settings\n   * and caches with a new pattern.\n   *\n   * Traversal functions can be called multiple times to run the walk\n   * again.\n   */\n  constructor(pattern: string | string[], opts: Opts) {\n    /* c8 ignore start */\n    if (!opts) throw new TypeError('glob options required')\n    /* c8 ignore stop */\n    this.withFileTypes = !!opts.withFileTypes as FileTypes<Opts>\n    this.signal = opts.signal\n    this.follow = !!opts.follow\n    this.dot = !!opts.dot\n    this.dotRelative = !!opts.dotRelative\n    this.nodir = !!opts.nodir\n    this.mark = !!opts.mark\n    if (!opts.cwd) {\n      this.cwd = ''\n    } else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {\n      opts.cwd = fileURLToPath(opts.cwd)\n    }\n    this.cwd = opts.cwd || ''\n    this.root = opts.root\n    this.magicalBraces = !!opts.magicalBraces\n    this.nobrace = !!opts.nobrace\n    this.noext = !!opts.noext\n    this.realpath = !!opts.realpath\n    this.absolute = opts.absolute\n\n    this.noglobstar = !!opts.noglobstar\n    this.matchBase = !!opts.matchBase\n    this.maxDepth =\n      typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity\n    this.stat = !!opts.stat\n    this.ignore = opts.ignore\n\n    if (this.withFileTypes && this.absolute !== undefined) {\n      throw new Error('cannot set absolute and withFileTypes:true')\n    }\n\n    if (typeof pattern === 'string') {\n      pattern = [pattern]\n    }\n\n    this.windowsPathsNoEscape =\n      !!opts.windowsPathsNoEscape ||\n      (opts as GlobOptions).allowWindowsEscape === false\n\n    if (this.windowsPathsNoEscape) {\n      pattern = pattern.map(p => p.replace(/\\\\/g, '/'))\n    }\n\n    if (this.matchBase) {\n      if (opts.noglobstar) {\n        throw new TypeError('base matching requires globstar')\n      }\n      pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`))\n    }\n\n    this.pattern = pattern\n\n    this.platform = opts.platform || defaultPlatform\n    this.opts = { ...opts, platform: this.platform }\n    if (opts.scurry) {\n      this.scurry = opts.scurry\n      if (\n        opts.nocase !== undefined &&\n        opts.nocase !== opts.scurry.nocase\n      ) {\n        throw new Error('nocase option contradicts provided scurry option')\n      }\n    } else {\n      const Scurry =\n        opts.platform === 'win32'\n          ? PathScurryWin32\n          : opts.platform === 'darwin'\n          ? PathScurryDarwin\n          : opts.platform\n          ? PathScurryPosix\n          : PathScurry\n      this.scurry = new Scurry(this.cwd, {\n        nocase: opts.nocase,\n        fs: opts.fs,\n      })\n    }\n    this.nocase = this.scurry.nocase\n\n    // If you do nocase:true on a case-sensitive file system, then\n    // we need to use regexps instead of strings for non-magic\n    // path portions, because statting `aBc` won't return results\n    // for the file `AbC` for example.\n    const nocaseMagicOnly =\n      this.platform === 'darwin' || this.platform === 'win32'\n\n    const mmo: MinimatchOptions = {\n      // default nocase based on platform\n      ...opts,\n      dot: this.dot,\n      matchBase: this.matchBase,\n      nobrace: this.nobrace,\n      nocase: this.nocase,\n      nocaseMagicOnly,\n      nocomment: true,\n      noext: this.noext,\n      nonegate: true,\n      optimizationLevel: 2,\n      platform: this.platform,\n      windowsPathsNoEscape: this.windowsPathsNoEscape,\n      debug: !!this.opts.debug,\n    }\n\n    const mms = this.pattern.map(p => new Minimatch(p, mmo))\n    const [matchSet, globParts] = mms.reduce(\n      (set: [MatchSet, GlobParts], m) => {\n        set[0].push(...m.set)\n        set[1].push(...m.globParts)\n        return set\n      },\n      [[], []]\n    )\n    this.patterns = matchSet.map((set, i) => {\n      const g = globParts[i]\n      /* c8 ignore start */\n      if (!g) throw new Error('invalid pattern object')\n      /* c8 ignore stop */\n      return new Pattern(set, g, 0, this.platform)\n    })\n  }\n\n  /**\n   * Returns a Promise that resolves to the results array.\n   */\n  async walk(): Promise<Results<Opts>>\n  async walk(): Promise<(string | Path)[]> {\n    // Walkers always return array of Path objects, so we just have to\n    // coerce them into the right shape.  It will have already called\n    // realpath() if the option was set to do so, so we know that's cached.\n    // start out knowing the cwd, at least\n    return [\n      ...(await new GlobWalker(this.patterns, this.scurry.cwd, {\n        ...this.opts,\n        maxDepth:\n          this.maxDepth !== Infinity\n            ? this.maxDepth + this.scurry.cwd.depth()\n            : Infinity,\n        platform: this.platform,\n        nocase: this.nocase,\n      }).walk()),\n    ]\n  }\n\n  /**\n   * synchronous {@link Glob.walk}\n   */\n  walkSync(): Results<Opts>\n  walkSync(): (string | Path)[] {\n    return [\n      ...new GlobWalker(this.patterns, this.scurry.cwd, {\n        ...this.opts,\n        maxDepth:\n          this.maxDepth !== Infinity\n            ? this.maxDepth + this.scurry.cwd.depth()\n            : Infinity,\n        platform: this.platform,\n        nocase: this.nocase,\n      }).walkSync(),\n    ]\n  }\n\n  /**\n   * Stream results asynchronously.\n   */\n  stream(): Minipass<Result<Opts>, Result<Opts>>\n  stream(): Minipass<string | Path, string | Path> {\n    return new GlobStream(this.patterns, this.scurry.cwd, {\n      ...this.opts,\n      maxDepth:\n        this.maxDepth !== Infinity\n          ? this.maxDepth + this.scurry.cwd.depth()\n          : Infinity,\n      platform: this.platform,\n      nocase: this.nocase,\n    }).stream()\n  }\n\n  /**\n   * Stream results synchronously.\n   */\n  streamSync(): Minipass<Result<Opts>, Result<Opts>>\n  streamSync(): Minipass<string | Path, string | Path> {\n    return new GlobStream(this.patterns, this.scurry.cwd, {\n      ...this.opts,\n      maxDepth:\n        this.maxDepth !== Infinity\n          ? this.maxDepth + this.scurry.cwd.depth()\n          : Infinity,\n      platform: this.platform,\n      nocase: this.nocase,\n    }).streamSync()\n  }\n\n  /**\n   * Default sync iteration function. Returns a Generator that\n   * iterates over the results.\n   */\n  iterateSync(): Generator<Result<Opts>, void, void> {\n    return this.streamSync()[Symbol.iterator]()\n  }\n  [Symbol.iterator]() {\n    return this.iterateSync()\n  }\n\n  /**\n   * Default async iteration function. Returns an AsyncGenerator that\n   * iterates over the results.\n   */\n  iterate(): AsyncGenerator<Result<Opts>, void, void> {\n    return this.stream()[Symbol.asyncIterator]()\n  }\n  [Symbol.asyncIterator]() {\n    return this.iterate()\n  }\n}\n","// this is just a very light wrapper around 2 arrays with an offset index\n\nimport { GLOBSTAR } from 'minimatch'\nexport type MMPattern = string | RegExp | typeof GLOBSTAR\n\n// an array of length >= 1\nexport type PatternList = [p: MMPattern, ...rest: MMPattern[]]\nexport type UNCPatternList = [\n  p0: '',\n  p1: '',\n  p2: string,\n  p3: string,\n  ...rest: MMPattern[]\n]\nexport type DrivePatternList = [p0: string, ...rest: MMPattern[]]\nexport type AbsolutePatternList = [p0: '', ...rest: MMPattern[]]\nexport type GlobList = [p: string, ...rest: string[]]\n\nconst isPatternList = (pl: MMPattern[]): pl is PatternList =>\n  pl.length >= 1\nconst isGlobList = (gl: string[]): gl is GlobList => gl.length >= 1\n\n/**\n * An immutable-ish view on an array of glob parts and their parsed\n * results\n */\nexport class Pattern {\n  readonly #patternList: PatternList\n  readonly #globList: GlobList\n  readonly #index: number\n  readonly length: number\n  readonly #platform: NodeJS.Platform\n  #rest?: Pattern | null\n  #globString?: string\n  #isDrive?: boolean\n  #isUNC?: boolean\n  #isAbsolute?: boolean\n  #followGlobstar: boolean = true\n\n  constructor(\n    patternList: MMPattern[],\n    globList: string[],\n    index: number,\n    platform: NodeJS.Platform\n  ) {\n    if (!isPatternList(patternList)) {\n      throw new TypeError('empty pattern list')\n    }\n    if (!isGlobList(globList)) {\n      throw new TypeError('empty glob list')\n    }\n    if (globList.length !== patternList.length) {\n      throw new TypeError('mismatched pattern list and glob list lengths')\n    }\n    this.length = patternList.length\n    if (index < 0 || index >= this.length) {\n      throw new TypeError('index out of range')\n    }\n    this.#patternList = patternList\n    this.#globList = globList\n    this.#index = index\n    this.#platform = platform\n\n    // normalize root entries of absolute patterns on initial creation.\n    if (this.#index === 0) {\n      // c: => ['c:/']\n      // C:/ => ['C:/']\n      // C:/x => ['C:/', 'x']\n      // //host/share => ['//host/share/']\n      // //host/share/ => ['//host/share/']\n      // //host/share/x => ['//host/share/', 'x']\n      // /etc => ['/', 'etc']\n      // / => ['/']\n      if (this.isUNC()) {\n        // '' / '' / 'host' / 'share'\n        const [p0, p1, p2, p3, ...prest] = this.#patternList\n        const [g0, g1, g2, g3, ...grest] = this.#globList\n        if (prest[0] === '') {\n          // ends in /\n          prest.shift()\n          grest.shift()\n        }\n        const p = [p0, p1, p2, p3, ''].join('/')\n        const g = [g0, g1, g2, g3, ''].join('/')\n        this.#patternList = [p, ...prest]\n        this.#globList = [g, ...grest]\n        this.length = this.#patternList.length\n      } else if (this.isDrive() || this.isAbsolute()) {\n        const [p1, ...prest] = this.#patternList\n        const [g1, ...grest] = this.#globList\n        if (prest[0] === '') {\n          // ends in /\n          prest.shift()\n          grest.shift()\n        }\n        const p = (p1 as string) + '/'\n        const g = g1 + '/'\n        this.#patternList = [p, ...prest]\n        this.#globList = [g, ...grest]\n        this.length = this.#patternList.length\n      }\n    }\n  }\n\n  /**\n   * The first entry in the parsed list of patterns\n   */\n  pattern(): MMPattern {\n    return this.#patternList[this.#index] as MMPattern\n  }\n\n  /**\n   * true of if pattern() returns a string\n   */\n  isString(): boolean {\n    return typeof this.#patternList[this.#index] === 'string'\n  }\n  /**\n   * true of if pattern() returns GLOBSTAR\n   */\n  isGlobstar(): boolean {\n    return this.#patternList[this.#index] === GLOBSTAR\n  }\n  /**\n   * true if pattern() returns a regexp\n   */\n  isRegExp(): boolean {\n    return this.#patternList[this.#index] instanceof RegExp\n  }\n\n  /**\n   * The /-joined set of glob parts that make up this pattern\n   */\n  globString(): string {\n    return (this.#globString =\n      this.#globString ||\n      (this.#index === 0\n        ? this.isAbsolute()\n          ? this.#globList[0] + this.#globList.slice(1).join('/')\n          : this.#globList.join('/')\n        : this.#globList.slice(this.#index).join('/')))\n  }\n\n  /**\n   * true if there are more pattern parts after this one\n   */\n  hasMore(): boolean {\n    return this.length > this.#index + 1\n  }\n\n  /**\n   * The rest of the pattern after this part, or null if this is the end\n   */\n  rest(): Pattern | null {\n    if (this.#rest !== undefined) return this.#rest\n    if (!this.hasMore()) return (this.#rest = null)\n    this.#rest = new Pattern(\n      this.#patternList,\n      this.#globList,\n      this.#index + 1,\n      this.#platform\n    )\n    this.#rest.#isAbsolute = this.#isAbsolute\n    this.#rest.#isUNC = this.#isUNC\n    this.#rest.#isDrive = this.#isDrive\n    return this.#rest\n  }\n\n  /**\n   * true if the pattern represents a //unc/path/ on windows\n   */\n  isUNC(): boolean {\n    const pl = this.#patternList\n    return this.#isUNC !== undefined\n      ? this.#isUNC\n      : (this.#isUNC =\n          this.#platform === 'win32' &&\n          this.#index === 0 &&\n          pl[0] === '' &&\n          pl[1] === '' &&\n          typeof pl[2] === 'string' &&\n          !!pl[2] &&\n          typeof pl[3] === 'string' &&\n          !!pl[3])\n  }\n\n  // pattern like C:/...\n  // split = ['C:', ...]\n  // XXX: would be nice to handle patterns like `c:*` to test the cwd\n  // in c: for *, but I don't know of a way to even figure out what that\n  // cwd is without actually chdir'ing into it?\n  /**\n   * True if the pattern starts with a drive letter on Windows\n   */\n  isDrive(): boolean {\n    const pl = this.#patternList\n    return this.#isDrive !== undefined\n      ? this.#isDrive\n      : (this.#isDrive =\n          this.#platform === 'win32' &&\n          this.#index === 0 &&\n          this.length > 1 &&\n          typeof pl[0] === 'string' &&\n          /^[a-z]:$/i.test(pl[0]))\n  }\n\n  // pattern = '/' or '/...' or '/x/...'\n  // split = ['', ''] or ['', ...] or ['', 'x', ...]\n  // Drive and UNC both considered absolute on windows\n  /**\n   * True if the pattern is rooted on an absolute path\n   */\n  isAbsolute(): boolean {\n    const pl = this.#patternList\n    return this.#isAbsolute !== undefined\n      ? this.#isAbsolute\n      : (this.#isAbsolute =\n          (pl[0] === '' && pl.length > 1) ||\n          this.isDrive() ||\n          this.isUNC())\n  }\n\n  /**\n   * consume the root of the pattern, and return it\n   */\n  root(): string {\n    const p = this.#patternList[0]\n    return typeof p === 'string' && this.isAbsolute() && this.#index === 0\n      ? p\n      : ''\n  }\n\n  /**\n   * Check to see if the current globstar pattern is allowed to follow\n   * a symbolic link.\n   */\n  checkFollowGlobstar(): boolean {\n    return !(\n      this.#index === 0 ||\n      !this.isGlobstar() ||\n      !this.#followGlobstar\n    )\n  }\n\n  /**\n   * Mark that the current globstar pattern is following a symbolic link\n   */\n  markFollowGlobstar(): boolean {\n    if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)\n      return false\n    this.#followGlobstar = false\n    return true\n  }\n}\n","// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\n\nimport { Minimatch } from 'minimatch'\nimport { Path } from 'path-scurry'\nimport { Pattern } from './pattern.js'\nimport { GlobWalkerOpts } from './walker.js'\n\nexport interface IgnoreLike {\n  ignored?: (p: Path) => boolean\n  childrenIgnored?: (p: Path) => boolean\n}\n\nconst defaultPlatform: NodeJS.Platform =\n  typeof process === 'object' &&\n  process &&\n  typeof process.platform === 'string'\n    ? process.platform\n    : 'linux'\n\n/**\n * Class used to process ignored patterns\n */\nexport class Ignore implements IgnoreLike {\n  relative: Minimatch[]\n  relativeChildren: Minimatch[]\n  absolute: Minimatch[]\n  absoluteChildren: Minimatch[]\n\n  constructor(\n    ignored: string[],\n    {\n      nobrace,\n      nocase,\n      noext,\n      noglobstar,\n      platform = defaultPlatform,\n    }: GlobWalkerOpts\n  ) {\n    this.relative = []\n    this.absolute = []\n    this.relativeChildren = []\n    this.absoluteChildren = []\n    const mmopts = {\n      dot: true,\n      nobrace,\n      nocase,\n      noext,\n      noglobstar,\n      optimizationLevel: 2,\n      platform,\n      nocomment: true,\n      nonegate: true,\n    }\n\n    // this is a little weird, but it gives us a clean set of optimized\n    // minimatch matchers, without getting tripped up if one of them\n    // ends in /** inside a brace section, and it's only inefficient at\n    // the start of the walk, not along it.\n    // It'd be nice if the Pattern class just had a .test() method, but\n    // handling globstars is a bit of a pita, and that code already lives\n    // in minimatch anyway.\n    // Another way would be if maybe Minimatch could take its set/globParts\n    // as an option, and then we could at least just use Pattern to test\n    // for absolute-ness.\n    // Yet another way, Minimatch could take an array of glob strings, and\n    // a cwd option, and do the right thing.\n    for (const ign of ignored) {\n      const mm = new Minimatch(ign, mmopts)\n      for (let i = 0; i < mm.set.length; i++) {\n        const parsed = mm.set[i]\n        const globParts = mm.globParts[i]\n        /* c8 ignore start */\n        if (!parsed || !globParts) {\n          throw new Error('invalid pattern object')\n        }\n        /* c8 ignore stop */\n        const p = new Pattern(parsed, globParts, 0, platform)\n        const m = new Minimatch(p.globString(), mmopts)\n        const children = globParts[globParts.length - 1] === '**'\n        const absolute = p.isAbsolute()\n        if (absolute) this.absolute.push(m)\n        else this.relative.push(m)\n        if (children) {\n          if (absolute) this.absoluteChildren.push(m)\n          else this.relativeChildren.push(m)\n        }\n      }\n    }\n  }\n\n  ignored(p: Path): boolean {\n    const fullpath = p.fullpath()\n    const fullpaths = `${fullpath}/`\n    const relative = p.relative() || '.'\n    const relatives = `${relative}/`\n    for (const m of this.relative) {\n      if (m.match(relative) || m.match(relatives)) return true\n    }\n    for (const m of this.absolute) {\n      if (m.match(fullpath) || m.match(fullpaths)) return true\n    }\n    return false\n  }\n\n  childrenIgnored(p: Path): boolean {\n    const fullpath = p.fullpath() + '/'\n    const relative = (p.relative() || '.') + '/'\n    for (const m of this.relativeChildren) {\n      if (m.match(relative)) return true\n    }\n    for (const m of this.absoluteChildren) {\n      if (m.match(fullpath)) return true\n    }\n    return false\n  }\n}\n","// synchronous utility for filtering entries and calculating subwalks\n\nimport { GLOBSTAR, MMRegExp } from 'minimatch'\nimport { Path } from 'path-scurry'\nimport { MMPattern, Pattern } from './pattern.js'\nimport { GlobWalkerOpts } from './walker.js'\n\n/**\n * A cache of which patterns have been processed for a given Path\n */\nexport class HasWalkedCache {\n  store: Map<string, Set<string>>\n  constructor(store: Map<string, Set<string>> = new Map()) {\n    this.store = store\n  }\n  copy() {\n    return new HasWalkedCache(new Map(this.store))\n  }\n  hasWalked(target: Path, pattern: Pattern) {\n    return this.store.get(target.fullpath())?.has(pattern.globString())\n  }\n  storeWalked(target: Path, pattern: Pattern) {\n    const fullpath = target.fullpath()\n    const cached = this.store.get(fullpath)\n    if (cached) cached.add(pattern.globString())\n    else this.store.set(fullpath, new Set([pattern.globString()]))\n  }\n}\n\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nexport class MatchRecord {\n  store: Map<Path, number> = new Map()\n  add(target: Path, absolute: boolean, ifDir: boolean) {\n    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0)\n    const current = this.store.get(target)\n    this.store.set(target, current === undefined ? n : n & current)\n  }\n  // match, absolute, ifdir\n  entries(): [Path, boolean, boolean][] {\n    return [...this.store.entries()].map(([path, n]) => [\n      path,\n      !!(n & 2),\n      !!(n & 1),\n    ])\n  }\n}\n\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nexport class SubWalks {\n  store: Map<Path, Pattern[]> = new Map()\n  add(target: Path, pattern: Pattern) {\n    if (!target.canReaddir()) {\n      return\n    }\n    const subs = this.store.get(target)\n    if (subs) {\n      if (!subs.find(p => p.globString() === pattern.globString())) {\n        subs.push(pattern)\n      }\n    } else this.store.set(target, [pattern])\n  }\n  get(target: Path): Pattern[] {\n    const subs = this.store.get(target)\n    /* c8 ignore start */\n    if (!subs) {\n      throw new Error('attempting to walk unknown path')\n    }\n    /* c8 ignore stop */\n    return subs\n  }\n  entries(): [Path, Pattern[]][] {\n    return this.keys().map(k => [k, this.store.get(k) as Pattern[]])\n  }\n  keys(): Path[] {\n    return [...this.store.keys()].filter(t => t.canReaddir())\n  }\n}\n\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nexport class Processor {\n  hasWalkedCache: HasWalkedCache\n  matches = new MatchRecord()\n  subwalks = new SubWalks()\n  patterns?: Pattern[]\n  follow: boolean\n  dot: boolean\n  opts: GlobWalkerOpts\n\n  constructor(opts: GlobWalkerOpts, hasWalkedCache?: HasWalkedCache) {\n    this.opts = opts\n    this.follow = !!opts.follow\n    this.dot = !!opts.dot\n    this.hasWalkedCache = hasWalkedCache\n      ? hasWalkedCache.copy()\n      : new HasWalkedCache()\n  }\n\n  processPatterns(target: Path, patterns: Pattern[]) {\n    this.patterns = patterns\n    const processingSet: [Path, Pattern][] = patterns.map(p => [target, p])\n\n    // map of paths to the magic-starting subwalks they need to walk\n    // first item in patterns is the filter\n\n    for (let [t, pattern] of processingSet) {\n      this.hasWalkedCache.storeWalked(t, pattern)\n\n      const root = pattern.root()\n      const absolute = pattern.isAbsolute() && this.opts.absolute !== false\n\n      // start absolute patterns at root\n      if (root) {\n        t = t.resolve(\n          root === '/' && this.opts.root !== undefined\n            ? this.opts.root\n            : root\n        )\n        const rest = pattern.rest()\n        if (!rest) {\n          this.matches.add(t, true, false)\n          continue\n        } else {\n          pattern = rest\n        }\n      }\n\n      if (t.isENOENT()) continue\n\n      let p: MMPattern\n      let rest: Pattern | null\n      let changed = false\n      while (\n        typeof (p = pattern.pattern()) === 'string' &&\n        (rest = pattern.rest())\n      ) {\n        const c = t.resolve(p)\n        t = c\n        pattern = rest\n        changed = true\n      }\n      p = pattern.pattern()\n      rest = pattern.rest()\n      if (changed) {\n        if (this.hasWalkedCache.hasWalked(t, pattern)) continue\n        this.hasWalkedCache.storeWalked(t, pattern)\n      }\n\n      // now we have either a final string for a known entry,\n      // more strings for an unknown entry,\n      // or a pattern starting with magic, mounted on t.\n      if (typeof p === 'string') {\n        // must not be final entry, otherwise we would have\n        // concatenated it earlier.\n        const ifDir = p === '..' || p === '' || p === '.'\n        this.matches.add(t.resolve(p), absolute, ifDir)\n        continue\n      } else if (p === GLOBSTAR) {\n        // if no rest, match and subwalk pattern\n        // if rest, process rest and subwalk pattern\n        // if it's a symlink, but we didn't get here by way of a\n        // globstar match (meaning it's the first time THIS globstar\n        // has traversed a symlink), then we follow it. Otherwise, stop.\n        if (\n          !t.isSymbolicLink() ||\n          this.follow ||\n          pattern.checkFollowGlobstar()\n        ) {\n          this.subwalks.add(t, pattern)\n        }\n        const rp = rest?.pattern()\n        const rrest = rest?.rest()\n        if (!rest || ((rp === '' || rp === '.') && !rrest)) {\n          // only HAS to be a dir if it ends in **/ or **/.\n          // but ending in ** will match files as well.\n          this.matches.add(t, absolute, rp === '' || rp === '.')\n        } else {\n          if (rp === '..') {\n            // this would mean you're matching **/.. at the fs root,\n            // and no thanks, I'm not gonna test that specific case.\n            /* c8 ignore start */\n            const tp = t.parent || t\n            /* c8 ignore stop */\n            if (!rrest) this.matches.add(tp, absolute, true)\n            else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n              this.subwalks.add(tp, rrest)\n            }\n          }\n        }\n      } else if (p instanceof RegExp) {\n        this.subwalks.add(t, pattern)\n      }\n    }\n\n    return this\n  }\n\n  subwalkTargets(): Path[] {\n    return this.subwalks.keys()\n  }\n\n  child() {\n    return new Processor(this.opts, this.hasWalkedCache)\n  }\n\n  // return a new Processor containing the subwalks for each\n  // child entry, and a set of matches, and\n  // a hasWalkedCache that's a copy of this one\n  // then we're going to call\n  filterEntries(parent: Path, entries: Path[]): Processor {\n    const patterns = this.subwalks.get(parent)\n    // put matches and entry walks into the results processor\n    const results = this.child()\n    for (const e of entries) {\n      for (const pattern of patterns) {\n        const absolute = pattern.isAbsolute()\n        const p = pattern.pattern()\n        const rest = pattern.rest()\n        if (p === GLOBSTAR) {\n          results.testGlobstar(e, pattern, rest, absolute)\n        } else if (p instanceof RegExp) {\n          results.testRegExp(e, p, rest, absolute)\n        } else {\n          results.testString(e, p, rest, absolute)\n        }\n      }\n    }\n    return results\n  }\n\n  testGlobstar(\n    e: Path,\n    pattern: Pattern,\n    rest: Pattern | null,\n    absolute: boolean\n  ) {\n    if (this.dot || !e.name.startsWith('.')) {\n      if (!pattern.hasMore()) {\n        this.matches.add(e, absolute, false)\n      }\n      if (e.canReaddir()) {\n        // if we're in follow mode or it's not a symlink, just keep\n        // testing the same pattern. If there's more after the globstar,\n        // then this symlink consumes the globstar. If not, then we can\n        // follow at most ONE symlink along the way, so we mark it, which\n        // also checks to ensure that it wasn't already marked.\n        if (this.follow || !e.isSymbolicLink()) {\n          this.subwalks.add(e, pattern)\n        } else if (e.isSymbolicLink()) {\n          if (rest && pattern.checkFollowGlobstar()) {\n            this.subwalks.add(e, rest)\n          } else if (pattern.markFollowGlobstar()) {\n            this.subwalks.add(e, pattern)\n          }\n        }\n      }\n    }\n    // if the NEXT thing matches this entry, then also add\n    // the rest.\n    if (rest) {\n      const rp = rest.pattern()\n      if (\n        typeof rp === 'string' &&\n        // dots and empty were handled already\n        rp !== '..' &&\n        rp !== '' &&\n        rp !== '.'\n      ) {\n        this.testString(e, rp, rest.rest(), absolute)\n      } else if (rp === '..') {\n        /* c8 ignore start */\n        const ep = e.parent || e\n        /* c8 ignore stop */\n        this.subwalks.add(ep, rest)\n      } else if (rp instanceof RegExp) {\n        this.testRegExp(e, rp, rest.rest(), absolute)\n      }\n    }\n  }\n\n  testRegExp(\n    e: Path,\n    p: MMRegExp,\n    rest: Pattern | null,\n    absolute: boolean\n  ) {\n    if (!p.test(e.name)) return\n    if (!rest) {\n      this.matches.add(e, absolute, false)\n    } else {\n      this.subwalks.add(e, rest)\n    }\n  }\n\n  testString(e: Path, p: string, rest: Pattern | null, absolute: boolean) {\n    // should never happen?\n    if (!e.isNamed(p)) return\n    if (!rest) {\n      this.matches.add(e, absolute, false)\n    } else {\n      this.subwalks.add(e, rest)\n    }\n  }\n}\n","/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\nimport { Minipass } from 'minipass'\nimport { Path } from 'path-scurry'\nimport { Ignore, IgnoreLike } from './ignore.js'\n\n// XXX can we somehow make it so that it NEVER processes a given path more than\n// once, enough that the match set tracking is no longer needed?  that'd speed\n// things up a lot.  Or maybe bring back nounique, and skip it in that case?\n\n// a single minimatch set entry with 1 or more parts\nimport { Pattern } from './pattern.js'\nimport { Processor } from './processor.js'\n\nexport interface GlobWalkerOpts {\n  absolute?: boolean\n  allowWindowsEscape?: boolean\n  cwd?: string | URL\n  dot?: boolean\n  dotRelative?: boolean\n  follow?: boolean\n  ignore?: string | string[] | IgnoreLike\n  mark?: boolean\n  matchBase?: boolean\n  // Note: maxDepth here means \"maximum actual Path.depth()\",\n  // not \"maximum depth beyond cwd\"\n  maxDepth?: number\n  nobrace?: boolean\n  nocase?: boolean\n  nodir?: boolean\n  noext?: boolean\n  noglobstar?: boolean\n  platform?: NodeJS.Platform\n  posix?: boolean\n  realpath?: boolean\n  root?: string\n  stat?: boolean\n  signal?: AbortSignal\n  windowsPathsNoEscape?: boolean\n  withFileTypes?: boolean\n}\n\nexport type GWOFileTypesTrue = GlobWalkerOpts & {\n  withFileTypes: true\n}\nexport type GWOFileTypesFalse = GlobWalkerOpts & {\n  withFileTypes: false\n}\nexport type GWOFileTypesUnset = GlobWalkerOpts & {\n  withFileTypes?: undefined\n}\n\nexport type Result<O extends GlobWalkerOpts> = O extends GWOFileTypesTrue\n  ? Path\n  : O extends GWOFileTypesFalse\n  ? string\n  : O extends GWOFileTypesUnset\n  ? string\n  : Path | string\n\nexport type Matches<O extends GlobWalkerOpts> = O extends GWOFileTypesTrue\n  ? Set<Path>\n  : O extends GWOFileTypesFalse\n  ? Set<string>\n  : O extends GWOFileTypesUnset\n  ? Set<string>\n  : Set<Path | string>\n\nexport type MatchStream<O extends GlobWalkerOpts> =\n  O extends GWOFileTypesTrue\n    ? Minipass<Path, Path>\n    : O extends GWOFileTypesFalse\n    ? Minipass<string, string>\n    : O extends GWOFileTypesUnset\n    ? Minipass<string, string>\n    : Minipass<Path | string, Path | string>\n\nconst makeIgnore = (\n  ignore: string | string[] | IgnoreLike,\n  opts: GlobWalkerOpts\n): IgnoreLike =>\n  typeof ignore === 'string'\n    ? new Ignore([ignore], opts)\n    : Array.isArray(ignore)\n    ? new Ignore(ignore, opts)\n    : ignore\n\n/**\n * basic walking utilities that all the glob walker types use\n */\nexport abstract class GlobUtil<O extends GlobWalkerOpts = GlobWalkerOpts> {\n  path: Path\n  patterns: Pattern[]\n  opts: O\n  seen: Set<Path> = new Set<Path>()\n  paused: boolean = false\n  aborted: boolean = false\n  #onResume: (() => any)[] = []\n  #ignore?: IgnoreLike\n  #sep: '\\\\' | '/'\n  signal?: AbortSignal\n  maxDepth: number\n\n  constructor(patterns: Pattern[], path: Path, opts: O)\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    this.patterns = patterns\n    this.path = path\n    this.opts = opts\n    this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/'\n    if (opts.ignore) {\n      this.#ignore = makeIgnore(opts.ignore, opts)\n    }\n    // ignore, always set with maxDepth, but it's optional on the\n    // GlobOptions type\n    /* c8 ignore start */\n    this.maxDepth = opts.maxDepth || Infinity\n    /* c8 ignore stop */\n    if (opts.signal) {\n      this.signal = opts.signal\n      this.signal.addEventListener('abort', () => {\n        this.#onResume.length = 0\n      })\n    }\n  }\n\n  #ignored(path: Path): boolean {\n    return this.seen.has(path) || !!this.#ignore?.ignored?.(path)\n  }\n  #childrenIgnored(path: Path): boolean {\n    return !!this.#ignore?.childrenIgnored?.(path)\n  }\n\n  // backpressure mechanism\n  pause() {\n    this.paused = true\n  }\n  resume() {\n    /* c8 ignore start */\n    if (this.signal?.aborted) return\n    /* c8 ignore stop */\n    this.paused = false\n    let fn: (() => any) | undefined = undefined\n    while (!this.paused && (fn = this.#onResume.shift())) {\n      fn()\n    }\n  }\n  onResume(fn: () => any) {\n    if (this.signal?.aborted) return\n    /* c8 ignore start */\n    if (!this.paused) {\n      fn()\n    } else {\n      /* c8 ignore stop */\n      this.#onResume.push(fn)\n    }\n  }\n\n  // do the requisite realpath/stat checking, and return the path\n  // to add or undefined to filter it out.\n  async matchCheck(e: Path, ifDir: boolean): Promise<Path | undefined> {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || (await e.realpath())\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    return this.matchCheckTest(needStat ? await e.lstat() : e, ifDir)\n  }\n\n  matchCheckTest(e: Path | undefined, ifDir: boolean): Path | undefined {\n    return e &&\n      (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&\n      (!ifDir || e.canReaddir()) &&\n      (!this.opts.nodir || !e.isDirectory()) &&\n      !this.#ignored(e)\n      ? e\n      : undefined\n  }\n\n  matchCheckSync(e: Path, ifDir: boolean): Path | undefined {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || e.realpathSync()\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    return this.matchCheckTest(needStat ? e.lstatSync() : e, ifDir)\n  }\n\n  abstract matchEmit(p: Result<O>): void\n  abstract matchEmit(p: string | Path): void\n\n  matchFinish(e: Path, absolute: boolean) {\n    if (this.#ignored(e)) return\n    const abs =\n      this.opts.absolute === undefined ? absolute : this.opts.absolute\n    this.seen.add(e)\n    const mark = this.opts.mark && e.isDirectory() ? this.#sep : ''\n    // ok, we have what we need!\n    if (this.opts.withFileTypes) {\n      this.matchEmit(e)\n    } else if (abs) {\n      const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath()\n      this.matchEmit(abs + mark)\n    } else {\n      const rel = this.opts.posix ? e.relativePosix() : e.relative()\n      const pre =\n        this.opts.dotRelative && !rel.startsWith('..' + this.#sep)\n          ? '.' + this.#sep\n          : ''\n      this.matchEmit(!rel ? '.' + mark : pre + rel + mark)\n    }\n  }\n\n  async match(e: Path, absolute: boolean, ifDir: boolean): Promise<void> {\n    const p = await this.matchCheck(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  matchSync(e: Path, absolute: boolean, ifDir: boolean): void {\n    const p = this.matchCheckSync(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  walkCB(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() => this.walkCB2(target, patterns, processor, cb))\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const childrenCached = t.readdirCached()\n      if (t.calledReaddir())\n        this.walkCB3(t, childrenCached, processor, next)\n      else {\n        t.readdirCB(\n          (_, entries) => this.walkCB3(t, entries, processor, next),\n          true\n        )\n      }\n    }\n\n    next()\n  }\n\n  walkCB3(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n\n  walkCBSync(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2Sync(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2Sync(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() =>\n        this.walkCB2Sync(target, patterns, processor, cb)\n      )\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const children = t.readdirSync()\n      this.walkCB3Sync(t, children, processor, next)\n    }\n\n    next()\n  }\n\n  walkCB3Sync(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2Sync(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n}\n\nexport class GlobWalker<\n  O extends GlobWalkerOpts = GlobWalkerOpts\n> extends GlobUtil<O> {\n  matches: O extends GWOFileTypesTrue\n    ? Set<Path>\n    : O extends GWOFileTypesFalse\n    ? Set<string>\n    : O extends GWOFileTypesUnset\n    ? Set<string>\n    : Set<Path | string>\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n    this.matches = new Set() as Matches<O>\n  }\n\n  matchEmit(e: Result<O>): void\n  matchEmit(e: Path | string): void {\n    this.matches.add(e)\n  }\n\n  async walk(): Promise<Matches<O>> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      await this.path.lstat()\n    }\n    await new Promise((res, rej) => {\n      this.walkCB(this.path, this.patterns, () => {\n        if (this.signal?.aborted) {\n          rej(this.signal.reason)\n        } else {\n          res(this.matches)\n        }\n      })\n    })\n    return this.matches\n  }\n\n  walkSync(): Matches<O> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    // nothing for the callback to do, because this never pauses\n    this.walkCBSync(this.path, this.patterns, () => {\n      if (this.signal?.aborted) throw this.signal.reason\n    })\n    return this.matches\n  }\n}\n\nexport class GlobStream<\n  O extends GlobWalkerOpts = GlobWalkerOpts\n> extends GlobUtil<O> {\n  results: O extends GWOFileTypesTrue\n    ? Minipass<Path, Path>\n    : O extends GWOFileTypesFalse\n    ? Minipass<string, string>\n    : O extends GWOFileTypesUnset\n    ? Minipass<string, string>\n    : Minipass<Path | string, Path | string>\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n    this.results = new Minipass({\n      signal: this.signal,\n      objectMode: true,\n    }) as MatchStream<O>\n    this.results.on('drain', () => this.resume())\n    this.results.on('resume', () => this.resume())\n  }\n\n  matchEmit(e: Result<O>): void\n  matchEmit(e: Path | string): void {\n    this.results.write(e)\n    if (!this.results.flowing) this.pause()\n  }\n\n  stream(): MatchStream<O> {\n    const target = this.path\n    if (target.isUnknown()) {\n      target.lstat().then(() => {\n        this.walkCB(target, this.patterns, () => this.results.end())\n      })\n    } else {\n      this.walkCB(target, this.patterns, () => this.results.end())\n    }\n    return this.results\n  }\n\n  streamSync(): MatchStream<O> {\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    this.walkCBSync(this.path, this.patterns, () => this.results.end())\n    return this.results\n  }\n}\n","import { Minimatch } from 'minimatch'\nimport { GlobOptions } from './glob.js'\n\n/**\n * Return true if the patterns provided contain any magic glob characters,\n * given the options provided.\n *\n * Brace expansion is not considered \"magic\" unless the `magicalBraces` option\n * is set, as brace expansion just turns one string into an array of strings.\n * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and\n * `'xby'` both do not contain any magic glob characters, and it's treated the\n * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`\n * is in the options, brace expansion _is_ treated as a pattern having magic.\n */\nexport const hasMagic = (\n  pattern: string | string[],\n  options: GlobOptions = {}\n): boolean => {\n  if (!Array.isArray(pattern)) {\n    pattern = [pattern]\n  }\n  for (const p of pattern) {\n    if (new Minimatch(p, options).hasMagic()) return true\n  }\n  return false\n}\n","import { escape, unescape } from 'minimatch'\nimport { Minipass } from 'minipass'\nimport { Path } from 'path-scurry'\nimport type {\n  GlobOptions,\n  GlobOptionsWithFileTypesFalse,\n  GlobOptionsWithFileTypesTrue,\n  GlobOptionsWithFileTypesUnset,\n} from './glob.js'\nimport { Glob } from './glob.js'\nimport { hasMagic } from './has-magic.js'\n\n/**\n * Syncronous form of {@link globStream}. Will read all the matches as fast as\n * you consume them, even all in a single tick if you consume them immediately,\n * but will still respond to backpressure if they're not consumed immediately.\n */\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): Minipass<Path, Path>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): Minipass<string, string>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesUnset\n): Minipass<string, string>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptions\n): Minipass<Path, Path> | Minipass<string, string>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).streamSync()\n}\n\n/**\n * Return a stream that emits all the strings or `Path` objects and\n * then emits `end` when completed.\n */\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): Minipass<string, string>\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): Minipass<Path, Path>\nexport function globStream(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined\n): Minipass<string, string>\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptions\n): Minipass<Path, Path> | Minipass<string, string>\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).stream()\n}\n\n/**\n * Synchronous form of {@link glob}\n */\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): string[]\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): Path[]\nexport function globSync(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined\n): string[]\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptions\n): Path[] | string[]\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).walkSync()\n}\n\n/**\n * Perform an asynchronous glob search for the pattern(s) specified. Returns\n * [Path](https://isaacs.github.io/path-scurry/classes/PathBase) objects if the\n * {@link withFileTypes} option is set to `true`. See {@link GlobOptions} for\n * full option descriptions.\n */\nasync function glob_(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined\n): Promise<string[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): Promise<Path[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): Promise<string[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptions\n): Promise<Path[] | string[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).walk()\n}\n\n/**\n * Return a sync iterator for walking glob pattern matches.\n */\nexport function globIterateSync(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined\n): Generator<string, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): Generator<Path, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): Generator<string, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptions\n): Generator<Path, void, void> | Generator<string, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).iterateSync()\n}\n\n/**\n * Return an async iterator for walking glob pattern matches.\n */\nexport function globIterate(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined\n): AsyncGenerator<string, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): AsyncGenerator<Path, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): AsyncGenerator<string, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptions\n): AsyncGenerator<Path, void, void> | AsyncGenerator<string, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).iterate()\n}\n\n// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc\nexport const streamSync = globStreamSync\nexport const stream = Object.assign(globStream, { sync: globStreamSync })\nexport const iterateSync = globIterateSync\nexport const iterate = Object.assign(globIterate, {\n  sync: globIterateSync,\n})\nexport const sync = Object.assign(globSync, {\n  stream: globStreamSync,\n  iterate: globIterateSync,\n})\n\n/* c8 ignore start */\nexport { escape, unescape } from 'minimatch'\nexport { Glob } from './glob.js'\nexport type {\n  GlobOptions,\n  GlobOptionsWithFileTypesFalse,\n  GlobOptionsWithFileTypesTrue,\n  GlobOptionsWithFileTypesUnset,\n} from './glob.js'\nexport { hasMagic } from './has-magic.js'\nexport type { IgnoreLike } from './ignore.js'\nexport type { MatchStream } from './walker.js'\nexport type {\n  Path,\n  WalkOptionsWithFileTypesTrue,\n  WalkOptionsWithFileTypesUnset,\n  WalkOptions,\n  FSOption,\n} from 'path-scurry'\n\n/* c8 ignore stop */\n\nexport const glob = Object.assign(glob_, {\n  glob: glob_,\n  globSync,\n  sync,\n  globStream,\n  stream,\n  globStreamSync,\n  streamSync,\n  globIterate,\n  iterate,\n  globIterateSync,\n  iterateSync,\n  Glob,\n  hasMagic,\n  escape,\n  unescape,\n})\nglob.glob = glob\n","import { createUnplugin } from 'unplugin';\nimport dedent from 'ts-dedent';\nimport { logger } from '@storybook/node-logger';\nimport { extractComponentsFromTemplate } from './extractComponentsFromTemplate';\nimport { TwigComponentConfiguration } from './symfony';\nimport { TwigComponentResolver } from './TwigComponentResolver';\nimport crypto from 'crypto';\n\nconst PLUGIN_NAME = 'twig-loader';\n\nexport type Options = {\n    twigComponentConfiguration: TwigComponentConfiguration;\n};\n\n/**\n * Twig template source loader.\n *\n * Generates JS modules to export raw template source and imports required components.\n */\nexport const TwigLoaderPlugin = createUnplugin<Options>((options) => {\n    const { twigComponentConfiguration } = options;\n    const resolver = new TwigComponentResolver(twigComponentConfiguration);\n    return {\n        name: PLUGIN_NAME,\n        enforce: 'pre',\n        transformInclude: (id) => {\n            return /\\.html\\.twig$/.test(id);\n        },\n        transform: async (code, id) => {\n            const imports: string[] = [];\n\n            try {\n                const components = new Set<string>(extractComponentsFromTemplate(code));\n\n                components.forEach((name) => {\n                    imports.push(resolver.resolveFileFromName(name));\n                });\n            } catch (err) {\n                logger.warn(dedent`\n                Failed to parse template in '${id}': ${err}\n                `);\n            }\n\n            const name = resolver.resolveNameFromFile(id);\n\n            return dedent`\n            ${imports.map((file) => `import '${file}';`).join('\\n')}            \n            export default { \n                name: \\'${name}\\',\n                hash: \\`${crypto.createHash('sha1').update(code).digest('hex')}\\`,\n            }; \n           `;\n        },\n    };\n});\n","import { XMLParser } from 'fast-xml-parser';\n\nexport const extractComponentsFromTemplate = (source: string) => {\n    const reservedNames = ['block'];\n    const tagRe = new RegExp(/twig:[A-Za-z]+(?::[A-Za-z]+)*/);\n    const functionRe = new RegExp(/component\\(\\s*'([A-Za-z]+(?::[A-Za-z]+)*)'\\s*(?:,.*)?\\)/, 'gs');\n\n    const lookupComponents = (obj: { [p: string]: any }): string[] => {\n        return Object.entries(obj).reduce((names, [key, value]) => {\n            if (value !== null && typeof value === 'object') {\n                names.push(...lookupComponents(value));\n            } else if (typeof value === 'string') {\n                for (const m of value.matchAll(functionRe)) {\n                    names.push([...m][1]);\n                }\n            }\n            if (tagRe.test(key)) {\n                names.push(key.replace('twig:', ''));\n            }\n            return names;\n        }, [] as string[]);\n    };\n\n    try {\n        // Dummy div tag to handle templates without any tag\n        const documentObj = new XMLParser().parse(`<div>${source}</div>`);\n\n        return lookupComponents(documentObj).filter((name) => !reservedNames.includes(name));\n    } catch (err) {\n        throw new Error('Invalid XML.', {\n            cause: {\n                parserError: err,\n                template: source,\n            },\n        });\n    }\n};\n","import { TwigComponentConfiguration } from './symfony';\nimport path from 'path';\nimport dedent from 'ts-dedent';\n\nexport class TwigComponentResolver {\n    constructor(private config: TwigComponentConfiguration) {}\n\n    isInAnonymousDirectory(file: string) {\n        return 0 === file.indexOf(this.config.anonymousTemplateDirectory);\n    }\n\n    resolveNameFromFile(file: string) {\n        const stripDirectory = (file: string, dir: string) => {\n            return file\n                .replace(dir, '')\n                .replace(/^\\//, '')\n                .replace('/', ':')\n                .replace('.html.twig', '')\n            ;\n        };\n\n        for (const namespace in this.config.namespaces) {\n            const dir = this.config.namespaces[namespace];\n            if (0 === file.indexOf(dir)) {\n                const trimmed = stripDirectory(file, dir);\n                if ('' !== namespace) {\n                    return `${namespace}:${trimmed}`;\n                }\n                return trimmed;\n            }\n        }\n\n        if (this.isInAnonymousDirectory(file)) {\n            return stripDirectory(file, this.config.anonymousTemplateDirectory);\n        }\n\n        throw new Error(dedent`Unable to determine template name for file \"${file}\":`);\n    }\n\n    resolveFileFromName(name: string) {\n        const nameParts = name.split(':');\n        const dirParts = nameParts.slice(0, -1);\n        const filename = `${nameParts.slice(-1)}.html.twig`;\n\n        const lookupPaths: string[] = [];\n\n        for (const namespace in this.config.namespaces) {\n            if ('' !== namespace && 0 === name.indexOf(namespace)) {\n                lookupPaths.push(path.join(this.config.namespaces[namespace], dirParts.slice(1).join('/')));\n                break;\n            }\n        }\n\n        if (this.config.namespaces[''] !== undefined) {\n            lookupPaths.push(path.join(this.config.namespaces[''], dirParts.join('/')));\n        }\n\n        lookupPaths.push(path.join(this.config.anonymousTemplateDirectory, dirParts.join('/')));\n\n        try {\n            return require.resolve(`./${filename}`, { paths: lookupPaths });\n        } catch (err) {\n            throw new Error(dedent`Unable to find template file for component \"${name}\": ${err}`);\n        }\n    }\n\n    resolvePhpFileFromName(name: string) {\n\n    }\n}\n"]}